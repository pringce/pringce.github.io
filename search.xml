<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL客户端与服务器连接过程]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 我们现在已经知道如何启动MySQL的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！ ​ TCP/IP是客户端和服务器之间最常用的通信方式。真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。MySQL采用TCP作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程有需要采用TCP协议进行网络通信方面的需求，可以向操作系统申请一个端口号，这是一个整数值，它的取值范围是0~65535。这样在网络中的其他进程就可以通过IP地址 + 端口号的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。 ​ MySQL服务器启动的时候会默认申请3306端口号，之后就在这个端口上等待客户端进程进行连接。用书面一点的话来说，MySQL服务器会默认监听3306端口。 ​ 如果3306端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加-P参数来明确指定一下端口号，比如这样： 1mysqld -P3307 如果采用windows服务打开MySQL服务器，则需要修改配置文件my.ini中的默认端口号。这样MySQL服务器在启动时就会去监听我们指定的端口号3307 ​ 如果客户端进程想要使用TCP/IP网络来连接到服务器进程，比如我们在使用mysql来启动客户端程序时，在-h参数后必须跟随IP地址来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用127.0.0.1来代表本机的IP地址。另外，如果服务器进程监听的端口号不是默认的3306，我们也可以在使用mysql启动客户端程序时使用-P参数（大写的P，小写的p是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写： 1mysql -h127.0.0.1 -uroot -P3307 -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站导航]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%85%A8%E7%AB%99%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到本学习交流网站，为了便于自己日后复习查看，特此设置全站导航。 MySQL一、MySQL基础知识 数据库基本操作 MySQL表的基本操作 MySQL数据类型 MySQL初始化与启动 MySQL客户端与服务器连接过程 二、MySQL注意事项与问题 MySQL密码错误如何修改 MySQL语句使用注意事项 算法机器学习算法 决策树 Java一、Java基础知识 1、Java入门 Hexo 利用Hexo搭建个人博客 Hexo博客如何迁移至其它电脑]]></content>
  </entry>
  <entry>
    <title><![CDATA[一、Java入门]]></title>
    <url>%2F2020%2F02%2F06%2F%E4%B8%80%E3%80%81Java%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. Java介绍​ Java是目前全球Top 1的程序开发语言，是SUN公司James Gosling为手持设备开发的嵌入式编程语言，原名Oak，1995年改名为Java正式推出，有最大的开发社区；目前广泛应用于企业和互联网后端开发、Android开发和大数据开发。 1.1 Java的特点 一种面向对象的跨平台编程语言，语法比C++简单 以字节码的形式运行在虚拟机上 自带功能齐全的类库 有非常活跃的开源社区支持 1.2 Java的优缺点优点： 简单(语法比C++简单)、健壮(垃圾收集器让内存管理更容易)、安全(字节码运行在虚拟机上，无法操作硬件，因此安全) 跨平台，一次编写，到处运行 高度优化的虚拟机 缺点： 语法比较繁琐 无法直接操作硬件(不适用于底层操作系统的开发) GUI效果不佳(不适用于桌面应用程序的开发) 1.3 Java的版本 Java SE: Standard Edition(标准版) Java EE: Enterprise Edition(企业版) Java ME: Micro Edition(移动版) 1.4 Java的规范什么是规范？ ​ 比如USB就是一个规范，它规定了电源的正负极、信号线等等 ​ Java的规范是Java Specification Request，简称JSR。有个组织Java Community Process(JCP)，它负责维护JSR规范。 1.5 Java平台​ Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。 Java平台实际上就是运行在各种操作系统上的JVM(虚拟机) 1.6 Java为什么可以跨平台运行？​ 1.首先开发好的java文件经过编译器Compiler的编译变为.class文件，然而这个.class文件并不是真正的本地可以执行的指令 我们可以把这个.class文件称之为“中间码” ​ 2.不同的计算机操作系统有着相应的JVM 比如win32位的、win64位的、linux系统的，.class文件经过Interpreter（解释器，也就是JVM）的解释（或者称之为翻译），变为真正的本地可执行指令（“00101001001…”） 总结：“一处编译，到处运行”是因为程序的中间码.class文件是标准的，一致的，在各个系统对应的JVM上都可以被识别解释然后运行，所以可以实现跨平台 1.7 Java安装 上官网下载对应版本的JDK 官网网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 不更改安装路径，直接安装在C盘 配置JDK环境变量，将C:\ProgramFiles\Java\jdk\bin添加到系统path变量中。打开cmd，输入“javac -version”，如果出现版本号，即代表配置完成 2. Java程序基础2.1 Java程序基本结构Java的基本程序结构如下： 123456789101112/** * 可用来自动创建文档注释 */public class Hello &#123; public static void main(String[] args)&#123; System.out.pringln("Hello world"); /* 多行注释 注释内容 注释结束 */ &#125;&#125; //class定义结束 ​ 类名必须是英文字母、数字和下划线的组合；类名必须以英文字母开头。 ​ Java有三种注释： 单行注释：以双斜线//开头，到当前行尾 多行注释：以/ … /表示，中间所有内容都被视为注释 特殊的多行注释：以/* … /表示，写在类和方法定义处，可用于自动创建文档。 2.2 变量123456public class Hello &#123; public static void main(String[] args)&#123; int n = 100; //基本类型 String s = "Hello,world"; //对象 &#125;&#125; 变量可以持有某个基本类型的数值，或者指向某个对象 变量必须先定义后使用 定义变量 1变量类型 变量名 = 初始值; 变量可被重新赋值 2.3 基本数据类型 整数类型：long、int、short、byte 浮点类型：double、float 布尔类型：boolean 字符类型：char 计算机内存的最小存储单元是字节（byte），一个字节时8位二进制数：00000000 ~ 11111111（0 ~ 255）。内存单元从0开始编号，称为内存地址。 2.3.1 整形 byte：8位，1字节 short：16位，2字节 int：32位，4字节 long：64位，8字节 123456789byte b = 127; //byte范围：-128 ~ 127short s = 32767; //-32768 ~ 32767int i = 2147483647;int i2 = -2147483648;int i3 = 2_000_000_000; //加下划线更容易识别int i4 = 0xff0000; //16进制表示的16711680int i5 = 0b1000000000; //2进制表示的512// 同一个数的不同进制表示完全相同long l = 9000000000000000000L; //由于java默认类型为int，因此需要在结尾加L 2.3.2 浮点类型 float：32位，4字节 double：64位，8字节 1234float f1 = 3.14f; // Java浮点数默认为double类型，float类型需在结尾加ffloat f2 = 3.14e38f; // 科学计数法表示的3.14*10^38double d = 1.79e308;double d1 = 4.9e-324; // 4.9*10^(-324) 2.3.3 布尔类型只有true和false两个值，通常是计算结果 2.3.4 字符类型char：保存一个字符，用单引号表示，如果输入多个字符编译器将会报错。注意区分字符类型和字符串类型的区别。 12char c1 = 'A';char c2 = '中'; 2.4 常量常量就是用final修饰的变量： 常量初始化后不可再次赋值 常量名通常全部大写 常量用来避免意外赋值 常量用来替代Magic Number：魔数导致代码可读性差，修改不方便的问题。 12345678// 常量的好处就是如果需要更改常量的值，只需在定义处修改final double PI = 3.14;double r = 4.0;double area = PI*r*r;//magic number:增加可读性，后续能看懂final double tax_rate = 0.2;double pay = 1-tax_rate; 2.5 基本类型和引用类型Java提供了两种变量类型：基本类型和引用类型。 基本类型：byte、short、int、long、float、double、char、boolean 引用类型：String、类、接口类型、数组类型、枚举类型、注解类型 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。 基本类型的变量是”持有”某个数值，引用类型的变量是”指向“某个对象 2.6 引用类型Java的引用与C++的指针在原理上是相类似的，但Java没有指针，只有引用。 简单的说，引用其实就像是一个对象的名字或者别名 (alias)，一个对象在内存中会请求一块空间来保存数据，根据对象的大小，它可能需要占用的空间大小也不等。访问对象的时候，我们不会直接是访问对象在内存中的数据，而是通过引用去访问。引用也是一种数据类型，我们可以把它想象为类似 C++ 语言中指针的东西，它指示了对象在内存中的地址——只不过我们不能够观察到这个地址究竟是什么。 如果我们定义了不止一个引用指向同一个对象，那么这些引用是不相同的，因为引用也是一种数据类型，需要一定的内存空间（stack，栈空间）来保存。但是它们的值是相同的，都指示同一个对象在内存（heap，堆空间）的中位置。 123String a = "hello";String b = a;//表示a和b是两个不同的引用，但它们的值是一样的，都指向同一个对象"hello" 总结： 引用是一种数据类型（保存在stack中），保存了对象在内存（heap，堆空间）中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)； 不同的引用可能指向同一个对象，换句话说，一个对象可以有多个引用，即该类类型的变量。 2.7 整数运算运算规则： 基本四则运算法则 除法结果为整数 除数为0时，运行将报错 ++运算和—运算 +=运算和-=运算 取余运算% Java源码中经常会使用移位运算来代替乘除运算，因为移位运算的性能比乘除运算的高（PS：对于计算机而言，移位运算只是移了个位置），所以了解移位运算的计算过程对于我们阅读源码会有一定的帮助。 原码：第一位表示符号, 其余位表示值 反码：正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 移位运算（3种）： 左移&lt;&lt;：丢弃左边指定位数，右边补0 带符号右移&gt;&gt;：丢弃右边指定位数，左边补上符号位 不带符号右移&gt;&gt;&gt;：丢弃右边指定位数，左边补上0 byte和short会先转换为int再进行移位 结论：对于机器而言，java中的移位运算都是对补码执行移位运算的，下面以-1&lt;&lt;1=-2为例进行讲解: -1的原码：10000000 00000000 00000000 00000001 -1的反码：11111111 11111111 11111111 11111110 -1的补码：11111111 11111111 11111111 11111111 执行移位操作 -1移位后的补码：11111111 11111111 11111111 11111110 -1移位后的反码：11111111 11111111 11111111 11111101 -1移位后的原码：10000000 00000000 00000000 00000010 得到最后的原码十进制值为-2 举例如下： 12345int n1 = 5;int n2 = n1&lt;&lt;10; //5120int n3 = n2&gt;&gt;11; //2int n4 = n1&lt;&lt;29; //-1610612736int n5 = n4&gt;&gt;29; //-3 类型自动提升与强制转型 在运算过程中，计算结果为较大类型的整型 12short s = 12;int i = 100+s; //100为int型，计算结果自动转为int型 较大类型的整数不能直接赋值给一个较小类型的整数，相反较小类型的整数能直接赋值给较大类型的整数 12long a = 100L;int b = a; //编译错误 可将结果强制转型 123(类型)变量或数值long a = 100L;int b = (int)a; 强制转型可能会丢失精度，因为int是32位，long是64位，所以如果数值大于32位会损失精度 2.8 浮点数运算浮点数运算的特点： 很多浮点数无法精确表示(详情可见另一篇博客：MySQL数据类型) 计算有误差，因为浮点数无法精确表示 1double b = 1-9.0/10; //0.09999999999999998 计算时如果浮点数和整数进行运算，整型可以自动提升为浮点型 浮点数运算特殊值（三种）： 1double d1 = 0.0/0; //NAN，不报错 1double d2 1.0/0; //Infinity 1double d3 = -1.0/0; //Infinity 强制转型 强制转为整型会直接扔掉小数位 12int n1 = (int)12.3; //12int n2 = (int)12.7; //12 四舍五入的技巧 1int n3 = (int)(12.7+0.5); 超出整型范围自动变为最大值 1int n4 = (int)1.2e20; //2147483647 2.9 布尔运算 关系运算符：&gt; , &gt;= , &lt; , &lt;= , == , != 与运算：&amp;&amp; 或运算：|| 非运算：！ 短路运算符： 与运算&amp;&amp;：与运算中，如果有任何一个表达式的计算结果为false，则后面的表达式将不再计算 或运算||：或运算中，如果有任何一个表达式的计算结果为true，则后面的表达式将不再计算 三元运算符：b ? x : y 根据条件b计算x或y，b为true计算x，b为false计算y x和y只计算其中一个 x和y类型必须相同 2.10 字符和字符串 字符类型是基本数据类型，保存一个字符。Java使用Unicode编码，因此可将字符类型直接赋值给一个int类型。还可直接用Unicode编码表示字符类型： 12// '\u####',4位16进制char c = '\u0041'; //'A' 字符串类型不是一个基本类型，是引用类型。String保存一个字符串。 1String s = "ABC"; 字符串连接用+，可以连接字符串和其它数据类型 12String s = "hello" + "world";String a = "age is" + 12; 因为字符串类型是引用类型，所以字符串不可变，只能改变其引用指向的对象。 所有的引用类型可以指向空值null，表示不指向任何对象。空值null和空字符串””是不一样的，注意区分。 1String s = null; 2.11 数组类型当有一组类型相同的变量时，可以用数组表示： 数组类型是：类型[] 数组初始化用new int[数组长度] 数组所有元素初始化为默认值 数组创建后大小不可改变 数组索引从0开始 12345678910public class hello&#123; public static void main(String[] args)&#123; int[] ns = new int[5]; ns[0] = 1; ns[1] = 2; ns[2] = 3; ns[3] = 4; ns[4] = 5; &#125;&#125; 用数组变量.length获取数组大小 12int[] ns = new int[5];System.out.println(ns.length); 数组变量是引用类型 可以指定初始化的元素，由编译器自动推算数组大小 123int[] ns = new int[] &#123;1,2,3,4,5&#125;;//可进一步简写int[] ns = &#123;1,2,3,4,5&#125;; 数组变量是引用类型，数组大小不可变，可指向不同的数组对象 数组元素是值类型（如int[]）或引用类型（如String[]）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表的基本操作]]></title>
    <url>%2F2019%2F11%2F13%2FMySQL%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ 创建表的时候首先需要描述清楚这个表是什么样的，它有哪些列，这些列都是用来存什么类型的数据等等。表中的一行叫做一条记录，一列就做一个字段。 展示当前数据库的表​ 下面的语句用于展示当前数据库中有哪些表： 1mysql&gt; SHOW TABLES; 创建表1、基本语法创建一个表时至少需要完成下列事情： （1）给表起个名 （2）给表定义一些列，并且给这些列都起个名 （3）每个列都需要定义一种数据类型 （4）如果有需要的话，可以给这些列定义一些列的属性，比如不许存储NULL，设置默认值等，具体列可以设置哪些属性可以在后面再详细说一下 创建表的基本语法如下： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 注意事项： 在CREATE TABLE后写清楚我们要创建的表的名称 在小括号 () 中定义这个表各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性(列的属性用中括号 [] 包起来的意思是这部分是可选的) 列名、数据类型、列属性之间用空白字符分开就好，然后各个列的信息之间用逗号分隔开 下面我们建个表为例展示一下： 1234CREATE TABLE first_table( first_column INT, second_column VARCHAR(100)); 执行结果如下： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; );Query OK, 0 rows affected (0.02 sec) 2、为建表语句添加注释​ 我们可以在创建表时将该表的用处以注释的形式添加到语句中，只要在建表语句最后加上COMMIT语句即可： 123CREATE TABLE 表名 ( 各个列的信息 ...) COMMENT '表的注释信息'; 比如我们可以这样写first_table的建表语句： 1234CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100)) COMMENT '第一个表'; 注释没必要太长，言简意赅即可，毕竟是给人看的，让人看明白是个啥意思就好了。为了我们自己的方便，也为了阅读你创建的人的方便，请遵守一下职业道德，写个注释吧～ 3、IF NOT EXISTS​ 和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，我们来试试重复创建一下first_table表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; ) COMMENT '第一个表';ERROR 1050 (42S01): Table 'first_table' already exists 如果想要避免这种错误发生，可以在创建表的时候使用这种形式： 123CREATE TABLE IF NOT EXISTS 表名( 各个列的信息 ...);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库层面基本操作]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ MySQL中把一些标的集合成为一个数据库，MySQL服务器管理着若干个数据库，每个数据库下都可以有若干个表，即 展示数据库​ 在刚安装好MySQL的时候，它内建了许多数据库和表了，我们可以使用下述命令来看一下都有哪些数据库： 1SHOW DATABASES; 创建数据库1CREATE DATABASE 数据库名; ​ 注意如果一个数据库已经存在的情况下再使用CREATE DATABASE去创建这个数据库会产生错误！如果我们并不清楚数据库是否存在，可以使用下边的语句来创建数据库： 1CREATE DATABASE IF NOT EXISTS 数据库名; 上述命令的意思是如果指定数据库不存在的话就创建它，否则什么都不做。 切换当前数据库​ 对于每一个连接到MySQL服务器的客户端，都有一个当前数据库的概念（也可以称之为默认数据库），我们创建的表默认都会被放到当前数据库中，切换当前数据库的命令也贼简单： 1USE 数据库名称; ​ 如果显示了Databases changed，说明当前数据库已经切换成功了。需要注意的是，在退出当前客户端之后，也就是你输入了exit或者quit命令之后或者直接把当前的黑框框页面关掉，当你再次打开MySQL时，相当于重新开启了一个客户端，需要重新调用USE 数据库名称的语句来选择一下当前数据库。 ​ 其实我们在新客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，只要把数据库名称写在启动客户端的命令后面就好，如下： 1mysql -hlocalhost -uroot -p 数据库名称; 删除数据库​ 如果我们觉得某个数据库没用了，可以把它删除掉，语法如下： 1DROP DATABASE 数据库名; ​ 在真实的工作环境里，在删除数据库之前你需要先拿体温计量量是不是发高烧了，然后再找至少两个人核实一下自己是不是发烧了，然后你才敢执行删除数据库的命令。删除数据库意味着里边的表就都被删除了，也就意味着你的数据都没了，所以是个极其危险的操作，使用时需要极其谨慎。 ​ ​ 如果某个数据库并不存在，我们仍旧调用DROP DATABASE语句去删除它，会报错。 ​ 如果想要避免这种报错，可以使用这种形式的语句来删除数据库： 1DROP DATABASE IF EXISTS 数据库名;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F10%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL支持所有的SQL数据类型，主要分为以下四类： 数值类型 字符串类型 时间日期类型 二进制类型 一、数值类型​ MySQL数值类型有9种，其中整数类型有5种（INTEGER、TINYINT、SMALLINT、MEDIUMINT和BIGINT）、浮点类型2种（float(M,D)、double(M,D)）、定点数1种（decimal(M,D)）和bit(M)类型1种。 整数类型 ​ 使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间。根据表示一个数占用字节数的不同，MySQL把整数划分成如下所示的类型： 类型 占用的存储空间（单位：字节） 无符号数取值范围 有符号数取值范围 含义 TINYINT 1 0~255 -128~127 非常小的整数 SMALLINT 2 0~65535 -32768~32767 小的整数 MEDIUMINT 3 0~16777215 -8388608~8388607 中等大小的整数 INT(INTEGER) 4 0~4294967 295 -2147483648~2147483647 标准的整数 BIGINT 8 0~2^64^-1 -2^63^~2^63^-1 大整数 以TINYINT为例，用1个字节，也就是8位表示有符号数的话，就是既可以表示正数，也可以表示负数的话，需要有一个比特位表示正负号。但是如果表示无符号数的话，也就是只表示非负数的话，就不需要表示正负号，这就是有符号数和无符号数的区别。 注意，对于INT(M)类型，M值不代表可以存储的数字长度，代表的是数据在显示时显式的最小长度。 浮点数类型 ​ 浮点数是用来表示小数的，平时用的十进制小数也可以转换成二进制后被计算机存储。比如9.875，这个小数可以被表示成这样： 19.875 = 8 + 1 + 0.5 + 0.25 + 0.125 = 1 × 2³ + 1 × 2⁰ + 1 × 2⁻¹ + 1 × 2⁻² + 1 × 2⁻³ 即，如果十进制小数9.875转换成二进制小数的话就是：1001.111。为了在计算机中存储这种二进制小数，统一把它们表示成 a*2^n 的科学计数法的形式，其中1&lt;=|a|&lt;2，比如1001.111可以表示为1.001111*2^3，我们把小数点后的001111成为尾数，把3称为指数，然后只需要在计算机中的比特位中表示出尾数和指数就行了。另外，小数也有正负之分，我们还需要单独的部分来表示小数的正负号。综上所述，表示一个浮点数需要下边几个部分： 符号部分：占用1个比特位即可 指数部分：视具体浮点数格式而定 尾数部分：视具体浮点数格式而定 ​ 很显然，表示一个浮点数使用的字节数越多，表示尾数和指数的范围就越大，也就是说可以表示的小数范围就越大。MySQL根据表示一个小数需要的不同字节数定义了如下的两种浮点数类型： 类型 占用的存储空间（单位：字节） 绝对值最小非零值 绝对值最大非零值 含义 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 MySQL中，FLOAT占4字节（1位符号位，8位表示指数，23位表示尾数），DOUBLE占8字节（1位符号位，11位表示指数，52位表示尾数）。这里以单精度浮点数类型FLOAT为例，它占用的4个字节的各个组成部分如下图所示： 另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的（即可能存在精度损失的问题）。 ​ 这里我们补充一下浮点数类型在内存中的存储方式： ​ 先来卡一下浮点数二进制表达的三个组成部分： ​ 三个主要部分是： 符号：表示浮点数是正数还是负数，0表示正数，1表示负数 指数部分：类似于科学计数法中的M*10^N^中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中以2^7^-1即127，也即01111111代表指数部分为0，转换时需要根据127作偏移调整。 尾数部分：浮点数中具体数值的实际表示。 ​ 下面展示实际转换过程： step 1：改写整数部分 ​ 以数值5.2为例。先不考虑小数部分，我们先单纯的将十进制数改写成二进制。即5转换为101 step 2：改写小数部分 ​ 把十进制的小数部分乘以2，取整数部分作为作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。 ​ 例如0.2可以转换为： ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ 0.6*2 = 1.2 1 ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ …… ​ 即最后转换结果为：.0011001……（它是一个无限循环的二进制数，明白为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况了吗） step 3：规格化 ​ 现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。 step 4：填充 ​ 指数部分（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。 ​ 尾数部分：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分1在填充时被舍去了。因为规格化后的数值整部部分总是为1。那省略整数部分后岂不是1.010011和0.010011就混淆了么？其实并不会，如果仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。（那么如何表示指数为-2的形式呢？即127-2=125，二进制表示为01111101） 举两个例子吧，比较直观一些（浮点数二进制转换工具） 1、9.875 其中打钩代表对应的二进制位为1，否则为0 2、0.3 ​ 设置最大位数和小数位数 ​ 在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，即 12FLOAT(M,D)DOUBLE(M,D) ​ 对我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M,D)或DOUBLE(M,D)来限制可以存储到本列中的小数范围。其中： M表示该小数最多需要的十进制有效数字个数 注意是有效数字个数，比如对于2.3，有效数字个数是2，对于0.9来说有效数字个数就是1 D表示该小数的小数点后的十进制数字个数 小数点后有几个十进制数字，D的值就是什么 M取值范围为0~255。FLOAT只保证6位有效数字的准确性，所以FLOAT(M,D)中，M&lt;=6时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 D取值范围为0~30，同时必须&lt;=M。double只保证16位有效数字的准确性，所以DOUBLE(M,D)中，M&lt;=16时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 FLOAT和DOUBLE中，若M的定义分别超出7和17，则多出的有效数字部分，取值是不定的，通常数值上会发生错误。因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。 定点数类型 ​ 因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了定点数类型，它也是存储小数的一种方式： 类型 占用的存储空间（单位：字节） 取值范围 DECIMAL(M,D) 取决于M和D 取决于M和D ​ M和D的含义与浮点数中M和D的含义一样。但单精度浮点数类型FLOAT(M,D)占用的字节一直都是4字节，双精度浮点数类型DOUBLE(M,D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动。但对于定点数类型DECIMAL(M,D)来说，它占用的存储空间大小就和M、D的取值有关。 ​ 定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。如何才能保证精确存储呢？只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么。比如对于十进制小数9.85来说，我们可以把小数点左右的两个整数，也就是9和85分别保存起来，那么不就相当于保存了一个精确的小数。 ​ ​ 下面详细说一下DECIMAL(M,D)的存储方式，以DECIMAL(16,4)为例： 1、首先确定小数左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图： 2、从小数点位置出发，每个整数每隔9个十进制位划分为一组，如图： 从上图可以看出，如果不足9个十进制位，也会被划分为一组 3、针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表： 组中包含的十进制位数 占用的存储空间大小（单位：字节） 1或2 1 3或4 2 5或6 3 7或8或9 4 所以DECIMAL(16,4)共需要占用8个字节的存储空间大小，这8个字节由下边三个部分组成： 第一组包含3个十进制位，需要2个字节 第二组包含9个十进制位，需要4个字节 第三组包含4个十进制位，需要2个字节 4、 将转换完成的比特位序列的最高位设置为1 举个例子吧，要不这咋可能弄得懂嘛，哼！ 比如用DECIMAL(M,D)存储十进制小数1234567890.1234，这个小数会被分为三部分： 11 234567890 1234 然后将每一组中的十进制数字转换成对应的二进制数字 第一组占用2个字节，即对应的二进制数为： 100000000 00000001(0x0001) 第二组占用4个字节，整数234567890对应的十六进制数为 10x0DFB38D2 第三组占用2个字节，整数1234对应的十六进制数为 10x04D2 所以将这些十六进制数字连起来之后就是： 10x00010DFB38D204D2 ​ 最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(M,D)存储时共占用8个字节，具体为： 10x80010DFB38D204D2 ​ 如果用定点数类型DECIMAL(16,4)存储一个负数怎么办？比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就行，即 10x7FFEF204C72DFB2D ​ 对于定点数类型，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。 ​ 对于定点数类型DECIMAL(M,D)来说，M和D都是可选的，默认的M的值是10，默认的D的值为0，即 12DECIMAL = DECIMAL(10) = DECIMAL(10,0)DECIMAL(n) = DECIMAL(n,0) M的范围是1-65，D的范围是0-30，且D的值不能超过M。 ​ 注意：比如DECIMAL(5,2)，取值范围为-999.99~999.99 如果存储时，整数部分超出了范围（如1000.01）,MySQL就会报错，不允许存这样的值。 如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。 如：999.994实际被保存为999.99。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如999.995和-999.995都会报错。 无符号数值类型 ​ unsigned是MySQL自定义的类型，主要有以下用途： 起到约束数值的作用，即非负数 增加数值范围 unsigned可以用于整数、浮点数和定点数。MySQL提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词unsigned 1数值类型 unsigned 注意：在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。 二、日期时间类型​ MySQL提供了多种关于时间和日期的类型，各种类型能表示的范围如下： 类型 存储空间要求（单位：字节） 取值范围 含义 YEAR 1 1901~2155 年份值 DATE 3 ‘1000-01-01’ ~ ‘9999-12-31’ 日期值 TIME 3 ‘-838:59:59’ ~ ‘838:59:59’ 时间值 DATETIME 8 ‘1000-01-01 00:00:00’ ～ ‘9999-12-31 23:59:59’ 日期加时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ ～ ‘2038-01-19 03:14:07’ 时间戳 ​ 在MySQL5.6.4这个版本后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持，称为小数秒。MySQL最多支持6为小数秒的支持，各个位代表的意思如下： 如果想让TIME、DATETIME、TIMESTAMP支持小数秒，可以这样写： 12类型(小数秒位数)其中的小数秒位数可以在0,1,2,3,4,5,6中选择 比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果多了小数秒，就需要额外的存储空间： 保留的小数秒位数 额外需要的存储空间（单位：字节） 0 0 1或2 1 3或4 2 5或6 3 注意，要特别注意下DATETIME和TIMESTAMP的区别 占用空间不同，datetime占8字节，timestamp占用4字节 表示范围不同，timestamp表示当前时间到Unix元年（1970 年 1 月 1 日 0 时 0 分 0 秒）的秒数。 时区。timestamp以UTC的格式存储，它会自动检索当前时区并进行转换，datetime不会进行时区的检索。也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。比如 1set time_zone = "+9:00";(时区设为东九区) 此时就相当于是改变了时区。 如果存进去的是NULL，timestamp会自动存储当前时间，而datetime会储存NULL timestamp类型可以在修改时自动更新 1uptime timestamp default current_timestamp on update current_timestamp 三、字符串类型​ 字符是面向人的概念，如果想在计算机中表示字符，那就需要将该字符与一个特定的二进制序列对应起来，这个映射过程称为编码。但这种映射关系不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种： 固定长度的编码方案 表示不同的字符所需要的字节数量是相同的。比方说ASCII编码方案采用1个字节来编码一个字符，usc2采用2个字节来编码一个字符。 变长的编码方案 表示不同的字符所需要的字节数量是不同的。比如utf8编码方案采用1-3个字节来编码一个字符，gb2312采用1-2个字节来编码一个字符。 MySQL的字符串类型 ​ 下表示MySQL中提供的字符串类型，其中M代表该数据类型最多能存储的字符数量，L代表实际向该类型中存储的字符串在特定字符集下所占的字节数，W代表该特定字符集下，编码一个字符最多需要的字节数： 类型 最大程度 存储空间要求 含义 CHAR(M) M个字符 M*W个字节 固定长度字符串 VARCHAR(M) M个字符 L+1或L+2个字节 可变长度字符串 TINYTEXT 2^8^-1个字节 L+1个字节 非常小型的字符串 TEXT 2^18^-1个字节 L+2个字节 小型的字符串 MEDIUMTEXT 2^24^-1个字节 L+3个字节 中等大小的字符串 LONGTEXT 2^32^-1个字节 L+4个字节 大型的字符串 CHAR(M) ​ M是该类型最多可以存储的字符数量（非字节数量），M的取值范围是0-255。如果省略掉M的值，那它的默认值就是1，也就是说CHAR和CHAR(1)是一个意思。CHAR(0)是一种特别的类型，它只能存储空字符串或者NULL值。 ​ CHAR(M)在不同的字符集下需要的存储空间也是不一样的，我们假设某个字符集编码一个字符最多需要W个字节，那么类型CHAR(M)占用的存储空间大小就是M×W个字符。比方说： 对于采用ASCII字符集的CHAR(5)类型来说，ASCII字符集编码一个字符最多需要1个字节，也就是M=5，W=1，所以占用的内存空间大小是5*1=5个字节。 对于采用gbk字符集的CHAR(5)类型来说，gbk字符集编码一个字符最多需要2个字节，也就是M=5，W=2，所以占用的内存空间大小是5*2=10个字节。 对于采用utf8字符集的CHAR(5)类型来说，utf8字符集编码一个字符最多需要3个字节，也就是M=5，W=3，所以占用的内存空间大小是5*3=15个字节。 ​ 如果我们实际存储的字符串在特定字符集编码下占用的字节数不足M*W，那么剩余的那些存储空间用空格字符补齐。即一旦确定了CHAR(M)类型的M，如果M的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费。 VARCHAR(M) ​ 如果某个列存储的字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，因此可以使用VARCHAR(M)。 ​ VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是1-65535。但是，MySQL中有一个规定，表中某一行包含的所有列中存储的数据大小总共不能超过65535个字节，也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。 ​ VARCHAR(M)类型表示的数据由以下两部分组成： 1、真正的字符串内容 ​ 假设真正的字符串在特定字符集编码后占用的字节数为L 2、占用字节数 ​ 假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么： 当M*W&lt;256时，只需要一个字节来表示占用的字节数 当M*W&gt;=256且M*W&lt;65536时，需要两个字节来表示占用的字节数 （因为一个字节能表示的最大无符号数是255，两个字节能表示的最大无符号数十65535） 各种TEXT类型 ​ 虽然VARCHAR(M)已经可以存储很长的字符串了，可有时候还是不够怎么办？对于很长的字符串，可以用TEXT存储大型字符串，它们都是变长类型。 ​ MySQL有个规定，某一行包含的所有列中存储的数据大小总和不得超过65535个字节。这个规定对于这些TEXT类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了。 ENUM类型和SET类型 ENUM类型称为枚举类型，它表示在给定的字符串列表里选择一个。比如性别，只能在’男’和’女’里面选一个，相当于一个单选框 1ENUM('str1','str2','str3',...) SET类型表示可以在给定的字符串列表里选择多个。比如兴趣列表，相当于一个多选框 1SET('str1','str2','str3',...) 综上所述，ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。 四、二进制类型 BIT类型 ​ 有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型： 类型 字节数 含义 BIT(M) 近似为(M+7)/8 存储M个比特位的值 M默认为1，M的取值范围为1~64，M可以省略，即BIT和BIT(1)一样。 BINARY(M)和VARBINARY(M) ​ 前者是固定长度的类型，后者是可变长度的类型，其中M代表该类型最多能存放的字节数量。 其它的二进制类型 ​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB是针对数据量很大的二进制数据提出的，比如图片、音乐、压缩文件啥的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句使用注意事项]]></title>
    <url>%2F2019%2F10%2F25%2FMySQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[​ MySQL的基本运行过程是：通过客户端发送命令给服务器程序，服务器程序按照接收的命令去操作实际的数据。在我们使用黑框框启动了MySQL客户端程序之后，界面上会一直显示一行字儿：mysql&gt;，这是一个提示符，你可以在它后边输入我们的命令然后按下回车键就把命令从客户端程序发送到了服务器程序，在书写命令的时候需要注意下边这几点： 1、命令结束符号 ​ 在书写完一个命令后需要以下面几个符号之一结尾： ； \g \G 其中；和\g的效果一样，如下所示： 123456789101112131415161718192021mysql&gt; show tables;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+mysql&gt; show tables\g+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 其中\G有一点特殊，它并不以表格的形式返回查询结果，而是以垂直的形式将每个列都展示在单独的一行中： 1234567891011mysql&gt; show tables\G*************************** 1. row ***************************Tables_in_run: student_info*************************** 2. row ***************************Tables_in_run: student_score*************************** 3. row ***************************Tables_in_run: t1*************************** 4. row ***************************Tables_in_run: t1_view*************************** 5. row ***************************Tables_in_run: t2 如果查询结果的列数非常多的话，使用\G可以让我们看清结果。 注意：使用Navicat第三方工具是不支持\g和\G的，只能在cmd界面中使用。 2、命令可以随意换行 ​ 并不是按了回车键就提交命令了，只要按回车键的时候输入的语句里没有；、\g或\G这些语句结束符号，该语句就算是没有结束。比如上面的语句可以写成： 123456789101112mysql&gt; show -&gt; tables -&gt;;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 3、可以一次提交多个命令 ​ 我们可以在一条语句里面写多个命令（命令之间用上面说的结束符间隔，但记住在写完前不要回车），只要没按回车键，就不会提交命令，如： 1234567891011121314151617181920212223mysql&gt; SELECT NOW(); SELECT NOW(); SELECT NOW();+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)mysql&gt; 4、使用 \c 放弃本次操作 ​ 如果你想放弃本次编写的命令，可以在输入的命令后边加上\c，比如 12mysql&gt; SELECT NOW()\cmysql&gt; 如果不使用\c，那客户端会以为这是一个多行命令，还在一直傻傻的等你输入命令。 注意：\c在Navicat第三方软件中不能用，只能用于cmd窗口中。 5、大小写 ​ MySQL默认对命令的大小写并没有限制。但是如果是表、列的名称就会对大小写敏感了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL密码错误如何修改？]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[​ 前两天我在用MySQL的时候，出现了一个小问题：就是我在注册完windows服务后，然后用net start MySQL80登录到数据库服务器，却无法使得客户端连接到服务器，即在输入完mysql -uroot -p后，会报如下的错误： (这种问题一般是由于密码错误引起的) ​ 于是我就查了一个解决方法，特此记录一下： 1、首先打开一个cmd窗口A： 首先关闭MySQL服务器 1net stop MySQL80 无密码启动MySQL服务 1mysqld --console --skip-grant-tables --shared-memory 2、再开一个cmd窗口B： 无密码登录（密码处直接enter） 12mysql -uroot -p//注意下面出现密码时，直接enter即可连接至MySQL 免密码登录设置空密码 ​ 设置空密码 1UPDATE mysql.user SET authentication_string=&apos;&apos; WHERE user=&apos;root&apos; and host=&apos;localhost&apos;; ​ 刷新 1flush privileges; 设置加密的密码 ​ 以caching_sha2_password加密密码并设置 1ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH caching_sha2_password BY &apos;新密码&apos;; ​ 刷新 1flush privileges; 这样修改完之后，就可以设置新的密码了，也就可以解决上述问题。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初始化与启动那些事]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL采用客户端/服务端架构，即它是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可以有多种形式，比如手机APP，电脑软件或者网页版微信。每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器程序，我们平时操作微信其实都是用客户端来和这个服务器来打交道。 ​ MySQL的使用过程大概为：它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器程序就响应这些请求，从而操作它维护的数据。日常使用MySQL的场景一般是这样的： 启动MySQL服务器程序 启动MySQL客户端程序并连接到服务器程序 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。 MySQL默认安装位置：C:\Program Files\MySQL\MySQL Server 8.0\，也可以自定义安装路径，为了方便就按照默认路径来安装吧~ 如何启动MySQL服务器程序？​ 这里以windows系统为例介绍。在windows系统下提供了手动启动和以服务的形式启动两种启动方式。 以服务的形式启动 ​ 什么是windows服务呢？如果需要长时间的运行某个程序，而且需要在计算机启动的时候启动它，一般我们都会把它注册为一个windows服务，操作系统会帮助我们管理它。 在MySQL根目录下(C:\Program Files\MySQL\MySQL Server 8.0)手动创建一个data文件夹 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld install MySQL80 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld --initialize-insecure --user=mysql80 打开MySQL服务器程序： 12net start MySQL80 //打开net stop MySQL80 //关闭 手动启动 ​ MySQL安装目录下的bin目录下的mysqld可执行文件代表着服务器程序，我们运行这个可执行文件就会启动MySQL服务器。 ​ MySQL服务器运行过程中严重依赖一个称之为数据目录的路径，不过我们安装MySQL时使用的MySQL Installer把这个数据目录的路径设置为了： 1C:\ProgramData\MySQL\MySQL Server 8.0\data 当然不同版本的MySQL Installer可能将数据目录的路径设置为不同的值。 ​ 在使用mysqld可执行文件启动MySQL服务器程序时，它默认并不会将上述路径设置为数据目录的路径，此时需要我们在启动MySQL服务器时显式地指定一个称之为datadir的参数，该参数就代表着数据目录的路径，所以使用下面的命令启动MySQL服务器： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; 特别要注意的是，当我们按下回车键后，cmd命令窗似乎卡住不动了，这就意味着MySQL服务器启动了，如果此时我们把这个cmd命令窗关掉，或者按下Ctrl+C键，就会停止MySQL服务器程序的运行。因此，还是推荐使用windows服务的方式来启动或停止MySQL服务器程序。 ​ 如果想查看使用mysqld启动MySQL服务器的过程中输出的日志信息，可以在上述命令后边加上—console： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; --console 如何启动MySQL客户端程序？​ 在服务器程序启动之后（不管是使用mysqld可执行文件启动的还是使用Windows服务的方式启动的），就可以接着启动客户端程序来连接到这个服务器喽。bin目录下有许多客户端程序，比方说mysqladmin、mysqldump、mysqlcheck等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件mysql.exe，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求以及接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下： 1mysql -h主机名 -u用户名 -p密码 参数意义： 参数名 含义 -h 表示启动服务器程序的计算机的域名或者IP地址，如果服务器程序就运行在本机的话，可以省略这个参数，也可以填localhost或127.0.0.1。也可以写成—host=主机名 -u 表示用户名，作为超级管理员的我们的用户名是root。也可以写成—user=root -p 表示密码。也可以写成—password=密码 连接注意事项 最好不要再一行命令中输入密码 这样容易导致密码泄露，可以这样写 1mysql -hlocalhost -uroot -p 如果非要显示的把密码写出来，那密码值和-p之间不能有空格，其他参数之间可以有空格。且各个参数的摆放顺序没有硬性规定。 如果你的服务器和客户端安装在同一台机器上，-h参数可以忽略，就像这样 1mysql -uroot -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客如何迁移至其它电脑]]></title>
    <url>%2F2019%2F07%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[​ 当你在一台电脑上写博客写的蛮爽的，但突然有一天你的电脑坏了或者被偷了咋办？你那些本地的博客可咋整！一想到这种有可能发生的危险，我就夜不能寐呀。于是我就开始疯狂地查找资料，但网上的资料良莠不齐。于是本人就自己慢慢的摸索嘛，这是一个程序员最基本的素质(其实还是自己太菜了)。下面我就把我的总结写一下，希望能对以后的自己和大家有帮助。 1、在新电脑上安装NodeJs和Git​ 这一步很简单，具体怎么安装，可以参见我的上一篇博文：利用hexo框架搭建个人博客(手把手教学) 2、GitHub新建分支​ 在pringce.github.io仓库下： 这里的分支名可以任意设置。 3、设置分支为默认仓库当前仓库-&gt;Settings-&gt;Branches-&gt;Default Branch 4、clone至本地​ 将该分支克隆至本地 1git clone https://github.com/pringce/pringce.github.io.git ​ cd进入 clone 下来的pringce.github.io文件夹，在此文件夹目录下git bash执行git branch命令，应该是新建的分支名 new。 5、新电脑生成ssh key并添加至GitHub​ 依次按照下述步骤生成本机ssh key： 1git config --global user.email "GitHub注册并验证时的邮箱" 1git config --global user.name "GitHub用户名" 1ssh-keygen // 一直按enter就行 在本机目录“C:\Users\10530\.ssh”会生成两个文件：id_rsa(私钥)和id_rsa.pub(公钥)。打开id_rsa.pub，复制里面的内容到GitHub: Settings -&gt; SSH and GPG keys -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key 测试是否成功： 1ssh -T git@github.com 输出 You’ve successfully authenticated 表示添加key 成功。 6、安装hexo1npm install hexo-cli -g 7、将原博客文件拷贝至pringce.github.io文件夹​ 将原博客文件夹下的文件拷贝至pringce.github.io，需要拷贝6个：_config.yml（站点配置文件）、themes\（主题）、source\（博客源文件）、scaffolds\（文章的模板）、package.json、.gitignore。 此时，我们不需要再用hexo init来生成博客了，因为需要的文件我们已经拷贝过来了。 8、提交本地至new分支​ 进入pringce.github.io文件夹，依次执行 1git add . 1git commit -m &quot;新电脑&quot; 1git push 这样，master分支用于保存博客静态资源，提供博客页面供人访问；new分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突。 9、安装hexo依赖的包1npm install ​ 所依赖的包都在上一步中的package.json备份文件里，所以直接这一个命令就可以了。就可以把你以前配置的那些包都安装上了。 10、新旧电脑更新博客​ 依次按照以下步骤来更新博客： 1git pull 1hexo new &quot;name&quot; 1hexo clean 1hexo g 1hexo s(测试时候在localhost看一下) 1hexo d(部署) 1git add . 1git commit -m &quot;新电脑&quot; 1git push //保证new分支版本为最新 因此，如果我们电脑又坏了或者又被偷了。。。那我们可以先获得新电脑的ssh key，然后添加到GitHub。然后把new分支下文件git clone下来，然后再新建、编辑、部署一步一步来即可。 好啦，心理的最大隐患解除了，可以安心睡觉啦。大家晚安！！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树全解析]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言​ 其实大家都说决策树简单，但个人觉得如果想学好这个算法其实还是需要下一些功夫的。决策树是一种基本的分类与回归方法(不要觉得决策树只能分类哦，它也可以做回归的)。 ​ 为了方便下面的讨论，我们先做一下说明： ​ 假设有一组训练数据 D=(x1,y1),(x2,y2),\cdots,(xn,yn)​ 表示有n个样本，样本共分为K类情况下，yi的取值来自K个类别值 (C1,C2,\cdots,Ck) ​ 另外，无论是ID3树、C4.5树还是CART树都是差不多的，都由特征选择(分裂特征选择算法)、树的生成和剪枝组成。它们之间的区别主要是特征选择和剪枝算法不同，这些我们后面会详细讨论，这里先留个伏笔。 ID3树​ 在介绍ID3决策树之前，我想先说一个概念：信息增益。 ​ 一个离散型随机变量x的概率分布为 P(x=x_i)=p_i​ ，则x的信息熵定义为 H(x)=-\sum_{i=1}^{n}{p_i}​ 数据集的熵表征其类别的不确定程度，而数据集关于某个特征的条件熵则表征着给定某个特征后，其类别的不确定程度： 数据集的熵—条件熵 = 该特征使数据集不确定性减小程度 设数据集D的熵为H(D)，关于特征Am的条件熵为H(D|Am)，因此可以获得信息增益为 g(D|A_m)=H(D)-H(D|A_m)其中， H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|}}log_2\frac{|C_k|}{|D_k|} H(D|A_m)=\sum_{i=1}^{K}{\frac{|D_i|}{|D|}}H(D_i)​ Di 表示训练样本中特征A取值为 ai 的样本点集合(比如说特征A有三个可能的取值，则K为3)。 ID3决策树构建​ 自根节点开始，选择信息增益最大的特征作为节点的分类特征，并根据该特征的可能取值将训练数据分配到不同的子节点(对子节点进行同样的操作)。 ​ 若子节点的所有样本属于同一类别或该子节点处所有特征的信息增益均小于给定阈值或无可供选择的特征，此时我们判定该子节点为一个叶节点，将该叶节点的样本数量最多的类别作为该叶节点的类别。 ​ 算法步骤如下： 若D中样本特征为空，那么树T为一棵单节点树，将样本数量最大的类别作为节点类别，返回T。否则转到第二步； 计算D关于所有特征的信息增益，若信息增益均小于某一阈值，则T为单节点树。否则转到第三步； 选择信息增益最大的特征作为分裂特征，依据该分裂特征的所有可能取值建立相应子节点。若子节点样本全为同一类别，则子节点为叶节点。若均为叶节点，返回T。否则转到第四步； 对非叶节点 i，以 Di 为训练集，将特征集减去刚才的分裂特征(这里特别需要注意一点，如果该特征是类别特征，则在分裂完成后删除该特征；如果为连续特征，则不删除该特征)，以得到新的特征集，然后递归调用第一步至第三步。 总结 ID3树在选取分裂特征时采用信息增益原则(其实个人理解，无论是ID3、C4.5还是CART树，在选取分裂特征时，基于的总原则都是使分裂前后的数据复杂度减少程度最多，因为选取该特征才能使得这样构建出来的决策树分类或回归效果最好)。 ID3树后剪枝的策略是PEP(悲观误差剪枝)，这里后面再介绍，这里先占个坑哈哈哈。 C4.5树​ 上述ID3树采用的是信息增益来进行节点分裂特征的选取。信息增益原则对于每个分支节点，都会乘以其权重，也就是说，由于权重之和为1，所以分支节点分的越多，即每个节点数据越少，纯度可能越高。这样会导致信息增益准则偏爱那些取值数目较多的属性。 ​ 为了解决该问题，引入了信息增益率，这个也就是C4.5树的分裂准则。C4.5树的基本构建流程与ID3树类似，唯一的区别就是C4.5树采用信息增益率进行特征选择，而ID3树采用信息增益进行特征选择。 ​ 信息增益率的定义如下： G_{ratio}=\frac{g(D|A_m)}{H_{A_m}(D)}​ 其中， H_{A_m}(D)=-\sum_{i=1}^{K}\frac{|D_i|}{|D|}log2{\frac{|D_i|}{|D|}}​ 需要注意的是，信息增益率原则可能对取值数目较少的属性更加偏爱。因此，C4.5并不是直接选择增益最大的候选划分属性。为了解决这个问题，C4.5采用了一种启发式算法，可以先从候选划分属性中找出信息增益在平均值以上的属性，再从中选择信息增益率最高的。 CART树​ 这里先强调一点，CART树是二叉树。与ID3和C4.5的决策树所不同的是，ID3和C4.5生成的决策树可以是多叉的，每个节点下的叉树由该节点特征的取值种类而定，比如特征年龄分为(青年，中年，老年)，那么该节点下可分为3叉。而CART决策树为二叉树，内部节点特征取值为“是”和“否”。左分支取值为“是”，右分支取值为“否”。因此在搜索分裂特征时，是递归地二分每一个特征。个人理解为不仅要遍历每一个特征，还要遍历每一个特征的二分取值，等于是做了一次双层遍历。相比于ID3和C4.5要更加复杂一些。 ​ 另外，我们还需要注意一点，ID3和C4.5只能用于分类，而CART树既可以用于分类，也能用于回归。 ​ CART树的基本构建流程与ID3树和C4.5树类似。唯一的区别就在于特征选择准则不同，另外CART树不仅要选择最优特征，还要选择最优二值切分点。别的都一样哈哈哈！！ ​ CART分类树特征选择​ CART分类树通过基尼指数选择最优特征，同时决定该特征的最优二值切分点，而ID3和C4.5直接选择最有特征，不用划分二值点。 ​ 这里先介绍一下基尼指数，我个人的理解是基尼指数和前面的信息熵的概念是一样的，都是表征数据集的不纯度，因此我们如何选择最优特征和最优二值切分点呢？也就是分裂后如何使基尼指数下降最大！ ​ 分类问题，假设有数据集D有K个类，样本点属于第k个类的概率为 pk，则基尼指数定义为 Gini(D)=1-\sum_{k=1}^{K}p_k^2​ 在特征A下，集合D的基尼指数定义为 Gini_A(D)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)​ 那么如何选择最优特征和最优二值切分点呢？就是使切分前后的不确定性下降最大！即切分前的基尼指数和在特征A下切分后的基尼指数之间的差越大，越应该为最优特征和最优二值切分点。同理也可以得到，在特征A下切分后的基尼指数越小，越应该为最优特征和最优二值切分点。 CART回归树特征选择​ 跟CART分类树大致相同，区别主要在以下几点： ​ 分裂准则：选择特征A以及对应的属性值s将当前节点分到两个区域 R1 和 R2 中， R_1={(x|x_is)}​ 如何选择呢？就是使上述两个区域的均方误差和最小！ ​ 最终预测值：最终节点值为该节点下所有数据的平均值。 剪枝​ 剪枝很好理解，它的目的就是防止过拟合。它主要分为预剪枝和后剪枝。 预剪枝 通过提前停止树的构建而对树剪枝。一旦停止，节点就是叶节点。 停止决策树生长最简单的方法有： 定义一个高度，当决策树达到该高度时就停止决策树的生长； 当节点实例个数小于某一阈值； 当分裂增益小于某一阈值。 后剪枝 ​ 它首先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的结点子树用叶子结点来代替，该叶子的类标号用该结点子树中最频繁的类标记。相比于先剪枝，这种方法更常用，正是因为在先剪枝方法中精确地估计何时停止树增长很困难。 ​ 后剪枝方法主要有以下几个方法： ​ Reduced-Error Pruning(REP，错误率降低剪枝） ​ Pessimistic-Error Pruning(PEP，悲观错误剪枝） ​ Cost-Complexity Pruning（CCP，代价复杂度剪枝) REP REP方法是一种最简单的后剪枝方法，对每个非叶子节点，从下往上遍历，尝试将该子树从叶子节点代替。然后利用验证集进行验证，看精度是否提升。若提升，则剪枝。这种方法一般不采用。 PEP PEP的策略主要用于ID3和C4.5树。悲观错误剪枝法是根据剪枝前后的错误率来判定子树的修剪。 把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代的话，在训练集上的误判率肯定是上升的，但是在新数据上不一定。于是我们需要把子树的误判计算加上一个经验性的惩罚因子。 对一个叶子节点，有n个样本，其中e个错误，则该叶子节点错误率为 (e+0.5)/n其中，0.5为惩罚因子 对一棵子树，有L个叶子节点，则该子树的错误率为 err\_ratio=\frac{(\sum_{i=1}^{L}e_i)+0.5L}{\sum_{i=1}^{L}n_i}这样的话，我们可以看到一颗子树虽然具有多个子节点，但由于加上了惩罚因子，所以子树的误判率计算未必占到便宜。 我们可以得到子树的错误次数均值和标准差 err\_mean=err\_ratio*\sum_{i=1}^{L}n_i err\_std=\sqrt{err\_ratio*\sum_{i=1}^{L}n_i*(1-err\_ratio)}当把子树替换成叶子节点后，该叶子节点的错误率和错误次数均值为 err\_ratio^{'}=\frac{(\sum_{i=1}^{L}e_i)+0.5}{\sum_{i=1}^{L}n_i} err\_mean^{'}=err\_ratio^{'}*\sum_{i=1}^{L}n_i剪枝条件为： err\_mean+err\_std>=err\_mean^{'}PEP的缺点： PEP算法采用的是自上而下的剪枝策略，这种剪枝会导致和预剪枝同样的问题，即剪枝过度。 CCP CCP的策略主要用于CART树。 代价指在剪枝过程中因子树 Tt 叶节点替代而增加的错分样本，复杂度表示剪枝后子树 Tt 减少的叶结点数，则定义每个非叶节点剪枝后树的复杂度降低程度与代价间的关系： α(t)=\frac{C(t)-C(T_t)}{|T_t|-1}其中， C(t) = r(t) * p(t)代表剪枝后叶子节点的误差代价 对于分类树，r(t) 为该节点的错误率；对于回归树，代表该节点的均方误差。 p(t) 为该节点数据占总数据的比例。 C(T_t)=\sum_{i=1}^{m}r_i(t)p_i(t)代表剪枝前的子树误差代价 对于分类树，ri(t) 为该子树某叶子节点的错误率；对于回归树，代表该子树某叶子节点的均方误差。 pi(t) 为该子树某叶子节点占总数据的比例。 CCP剪枝算法分为两个步骤： 对于完全决策树 T 自下而上的计算每个非叶结点的 α 值，然后自上而下的循环(注意，每剪枝一次，就重新计算表面误差增益率，再循环第一步)剪掉具有最小 α 值的子树(自上而下代表若有多个非叶子节点的表面误差率增益值相同小，则选择非叶子节点中子节点数最多的非叶子节点进行剪枝)，直到剩下根节点。在该步可得到一系列的剪枝树序列｛T0，T1，T2……Tn｝,其中 T0 为原有的完全决策树，Tn为根结点，Ti+1为对 Ti 进行剪枝的结果； 从子树序列中，根据真实的验证集误差选择最佳剪枝后决策树。 例. 下图是一棵子树，设决策树的总数据量为40 C(t)=\frac{8}{18}*\frac{18}{40}=\frac{1}{5} C(T_t)=\frac{1}{3}*\frac{3}{40}+\frac{4}{9}*\frac{9}{40}+\frac{1}{6}*\frac{6}{40}=\frac{6}{40} α(t)=\frac{\frac{1}{5}-\frac{6}{40}}{3-1}=\frac{1}{40}​ 好啦，到了这里，基本就把所有的决策树知识说完啦！希望能对大家有帮助。]]></content>
      <categories>
        <category>机器学习算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo框架搭建个人博客]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%88%A9%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言​ 本文是在Windows 10环境下搭建个人博客，对于Linux和Mac环境，搭建工作基本类似，区别无非在于个别命令行指令的区别，读者只需作相应的调整即可。 1. 安装NodeJs​ hexo是基于NodeJs环境的静态博客，里面的npm工具很有用（个人感觉类似于python里面的pip或者anaconda里面的conda，是一个包管理工具），所以说NodeJs是搭建个人博客的第一步。 下载地址：https://nodejs.org/en/ 下载下图的10.16.0 LTS即可。 然后点击下载的安装包，无脑点yes安装即可。至此NodeJs已经全部安装完成。 2. 安装Git Bash​ 由于本人使用的是Windows环境，cmd指令过于难用（也难怪众多开发者投入了Linux的怀抱）。所以本人下载了Git Bash（其实也就是下载了Git工具）。在网上搜索Git可以下载一个下面这个应用程序： ​ 然后依旧无脑点yes，安装完成后，在左面点击鼠标右键，如果出现了Git Bash和Git GUI即代表Git安装成功。 ​ 然后打开Git Bash可以查看NodeJs和npm的版本： NodeJs版本 1$ node -v npm版本 1$ npm -v 3. 安装hexo​ 我们是需要借助npm来安装hexo框架的。但是由于墙的原因，国内使用npm的下载速度很慢。因此我们需要更换源（使用淘宝的那个源），利用npm来安装一个cnpm。安装完成后，后面完全可以用cnpm全面取代npm。 ​ 如何安装cnpm？ 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 安装完成后，可以查看一下cnpm的版本 1$ cnpm -v ​ 随后，开始正式安装hexo框架 1$ cnpm install -g hexo-cli ​ 如何判断hexo是否安装成功，我们只需要查看hexo的版本，如果出现版本信息，则代表hexo安装成功 1$ hexo -v 4. 开始正式搭建博客​ 首先我们需要先建立一个空的目录，存储我们的博客信息。这样的好处就是，一旦这个博客出错了或者你不想要了，直接把这个文件夹删除即可，不会影响其他的文件，保持独立性。 12$ mkdir blog$ cd blog ​ 随后在blog目录下利用hexo生成博客，很简单 1$ hexo init ​ 可以看到，生成完成后会出现下面这些文件 ​ 随后启动博客 1$ hexo s ​ 可以看到，博客可以在本地的4000端口进行访问 ​ 我们利用浏览器打开该端口，即可访问到我们最初始的博客。该博客默认有一篇hello word的博文 ​ 随后我们可以新建一篇文章，里面写上我们想要的内容即可。如何新建一篇文章？ 1$ hexo new &quot;我的第一篇文章&quot; ​ 生成完成后，便可以在blog/source/_post目录下找到我们生成的这篇文章，文件名为”我的第一篇文章.md”。随后便可以用Typora来写该博客了（markdown语法）。 ​ 因为我们现在新建了一篇文章，如何把它上传呢？（即在浏览器中也可以看到改文章）。这里就要用到hexo中著名的“素质三连”指令了 123$ hexo clean (清理)$ hexo g (生成)$ hexo s (启动) ​ 随后便可以在本地4000端口看见我们刚才新建的那篇文章了。 一切都是这么简单，一切都是这么优雅！ 5. 远端部署​ 我们写个人博客的目的不是为了只自己访问，也希望别人能看见，因此需要部署到远端服务器。这里有一种免费的部署方式，即把我们的博客部署到github上公开使用。 5.1 新建仓库 ​ 一定要注意仓库的命名方式，仓库的名称一定要和你的github昵称保持一致，否则将无法访问。例如我的github昵称为pringce，那么仓库的名称一定要命名为pringce.github.io。如下图 5.2 安装Git部署插件1$ cnpm install hexo-deployer-git --save 5.3 配置config文件​ 在我们的blog目录下，找到_config.yml这个文件，然后到文件的最底部，写入如下配置 5.4 部署到远端1$ hexo d ​ 随后输入”https://pringce.github.io&quot;，即可访问我们部署到远端服务器上的博客了。至此任何人都可以访问你的博客了，博客的部署工作完成。 一切都是这么简单，一切都是这么优雅！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
