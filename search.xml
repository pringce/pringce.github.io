<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSON在开发中的使用]]></title>
    <url>%2F2020%2F08%2F04%2FJSON%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是JSON？JavaScript Object Notation，简称JSON。是一种数据交换格式 JSON主要的作用是一种标准的数据交换格式。系统A和系统B交换数据的话，都是采用JSON JSON是一种标准的轻量级的数据交换格式，特点是体积小，易解析 在实际的开发中，有两种数据交换格式使用最多，分别是JSON和XML。XML体积较大，解析麻烦，但是语法严谨（通常银行相关的系统之间进行数据交换时采用XML） 下面展示一下XML的格式： 12345678910111213141516&lt;!--students.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;students&gt; &lt;student sno="110"&gt; &lt;name&gt;张三&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt; &lt;student sno="120"&gt; &lt;name&gt;李四&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt; &lt;student sno="130"&gt; &lt;name&gt;王五&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 可以看到XML和HTML很相似，其实HTML和XML有一个父亲：SGML（标准通用的标记语言） HTML主要做页面展示，所以语法松散，很随意 XML主要做数据存储和数据描述的，所以语法相当严格 再展示一下JSON的格式： 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; //创建JSON对象 var studentObj = &#123; "sno" : "110", "sname" : "张三", "sex" : "男" &#125;; //访问JSON对象的属性 alert(studentObj.sno+","+studentObj.sname+","+studentObj.sex) //JSON数组 var students = [ &#123;"sno" : "110","sname" : "张三","sex" : "男"&#125;, &#123;"sno" : "120","sname" : "李四","sex" : "男"&#125;, &#123;"sno" : "130","sname" : "王五","sex" : "男"&#125; ]; //遍历 for(var i = 0;i&lt;studens.length;i++)&#123; var stuObj = students[i]; alert(stuObj.sno+","+stuObj.sname+","+stuObj.sex) &#125;&lt;/script&gt; JSON语法格式： 1234567var Obj = &#123; "属性名" : 属性值, "属性名" : 属性值, "属性名" : 属性值, "属性名" : 属性值 ...&#125; 复杂一些的JSON JSON嵌套 123456789101112var user = &#123; "usercode" : 110, "username" : "张三", "sex" : true, "address" : &#123; "city" : "北京", "street" : "大兴区" &#125;&#125;//访问居住城市alert(user.address.city); eval函数 将字符串当作一段JS代码解释并执行 1234&lt;script&gt; window.eval("var i = 100;"); alert("i="+i); //i=100&lt;/script&gt; 为什么要说这个呢？ 因为java连接数据库，查询数据之后，将数据在java程序中拼接成JSON格式的字符串，将JSON格式的字符串响应到浏览器。也就是说，java响应到浏览器上的仅仅是一个JSON格式的字符串，还不是一个JSON对象。可以使用eval函数，将JSON格式的字符串转换成JSON对象 123456&lt;script&gt; //这是从java发过来的json格式字符串 var fromJava = "&#123;\"name\":\"zhangsan\",\"pwd\":123&#125;"; //转换成json对象 window.eval("var jsonObj"+fromJava);&lt;/script&gt; 在JS中，[]和{}有什么区别？ []是数组 {}是JSON java中的数组：int[] arr = {1,2,3,4,5}; JS中的数组：var arr = [1,2,3,4,5]; JSON：var jsonObj = {“name” : “张三”, “age” : 25}; 下面写一个JSON常用的场景设置table的tbody（即点击按钮之后，在表格中显示从后台传来的数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;设置table的tbody&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var data = &#123; "total" : 4, "emps" : [ &#123;"empno":1,"ename":"smith","sal":800&#125;, &#123;"empno":2,"ename":"jack","sal":900&#125;, &#123;"empno":3,"ename":"rose","sal":1200&#125;, &#123;"empno":4,"ename":"jenny","sal":700&#125; ] &#125;; //把数据展示到table中 window.onload = function()&#123; var displayBtnElt = document.getElementById("displayBtn"); displayBtnElt.onclick = function()&#123; var emps = data.emps; var html = ""; for(var i=0;i&lt;emps.length;i++)&#123; var emp = emps[i]; html += "&lt;tr&gt;"; html += "&lt;td&gt;"+emp.empno+"&lt;/td&gt;"; html += "&lt;td&gt;"+emp.ename+"&lt;/td&gt;"; html += "&lt;td&gt;"+emp.sal+"&lt;/td&gt;"; html += "&lt;/tr&gt;"; &#125; document.getElementById("emptbody").innerHTML = html; document.getElementById("count").innerHTML = data.total; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="员工信息列表" id="displayBtn" /&gt; &lt;h2&gt;员工信息列表&lt;/h2&gt; &lt;hr&gt; &lt;table border="1px" width="50%"&gt; &lt;tr&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工名字&lt;/th&gt; &lt;th&gt;员工薪资&lt;/th&gt; &lt;/tr&gt; &lt;tbody id="emptbody"&gt;&lt;/tbody&gt; &lt;/table&gt; 总共&lt;span id="count"&gt;0&lt;/span&gt;条数 &lt;/body&gt;&lt;/html&gt; 点击按钮前的效果： 点击按钮后的效果：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[history和location对象]]></title>
    <url>%2F2020%2F07%2F14%2Fhistory%E5%92%8Clocation%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[history对象通常用来前进和后退页面 hello.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;顶级窗口&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="login.html"&gt;login页面&lt;/a&gt; &lt;!--前进--&gt; &lt;input type="button" value="前进" onclick="window.history.go(1)"&gt; &lt;/body&gt;&lt;/html&gt; login.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;history&lt;/title&gt; &lt;/head&gt; &lt;body&gt; login page! &lt;!--以下两种方式均可以回退--&gt; &lt;input type="button" value="后退" onclick="window.history.back()"&gt; &lt;input type="button" value="后退" onclick="window.history.go(-1)"&gt; &lt;/body&gt;&lt;/html&gt; 在hello页面中点击超链接会跳转至login页面，然后点击后退按钮会回退至hello页面 刚打开hello页面时，点击前进按钮不会有任何反应，因为没有history；当点击超链接跳转之后再回退至hello页面，此时点击前进按钮，就会前进至login页面 location对象设置浏览器地址栏上的URL 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;顶级窗口&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function goBaidu()&#123; //以下两种方式均可 window.location.href = "https://www.baidu.com"; //document.location.href = "https://www.baidu.com"; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="百度" onclick="goBaidu()"&gt; &lt;/body&gt;&lt;/html&gt; 此时点击”百度”按钮之后，就会跳转至百度页面 总结：有哪些方法可以通过浏览器往服务器发请求？ 表单form的提交 超链接 document.location window.location window.open(“url”) 直接在浏览器地址栏上输入url，然后回车 注意：以上所有的请求方式均可以携带数据给服务器，只有通过表单提交的数据才是动态的，其余就是直接将数据写进url，例如url?name1=pwd1&amp;name2=pwd2…]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将当前窗口设置为顶级窗口]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%B0%86%E5%BD%93%E5%89%8D%E7%AA%97%E5%8F%A3%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%A1%B6%E7%BA%A7%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通常有这样的需求：一个操作员正在使用系统（通常是有窗口嵌套的），出去了，隔了很久才回来，再次回来的时候会继续操作，此时会跳转到登录页面让你重新登录（因为之前的登录已经超时了）。如果没有做任何的特殊设置，登录页面将显示在本窗口中。因此需要将当前窗口中的登录页面设置为顶级窗口 hello.html文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;顶级窗口&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--嵌套子窗口，嵌套了login.html--&gt; &lt;iframe src="login.html" width="500px" height="500px"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; login.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;嵌套窗口&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function setTop()&#123; //将当前窗口设置为顶级窗口 if(window.top!=window.self) window.top.location = window.self.location; &#125; &lt;/script&gt; &lt;input type="button" value="设置为顶级窗口" onclick="setTop()"&gt; &lt;/body&gt;&lt;/html&gt; 点击子窗口中的button之后，会将该窗口设置为顶级窗口]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹出确认框]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BC%B9%E5%87%BA%E7%A1%AE%E8%AE%A4%E6%A1%86%2F</url>
    <content type="text"><![CDATA[在执行删除操作的时候，必须要弹出确认框！！！ 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;弹出确认框&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function del()&#123; //点击确认，返回true；点击取消，返回false var ok = window.confirm("确认删除么?"); &#125; &lt;/script&gt; &lt;input type="button" value="删除数据" onclick="del()"&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window的open和close]]></title>
    <url>%2F2020%2F07%2F14%2Fwindow%E7%9A%84open%E5%92%8Cclose%2F</url>
    <content type="text"><![CDATA[BOM编程中，window对象是顶级对象，代表浏览器窗口 window有open和close方法，可以开启窗口和关闭窗口 open方法 12345678&lt;body&gt; &lt;!--默认打开新窗口--&gt; &lt;input type="button" value="新窗口" onclick="window.open('https://www.baidu.com')"&gt; &lt;input type="button" value="当前窗口" onclick="window.open('https://www.baidu.com','_self')"&gt; &lt;input type="button" value="新窗口" onclick="window.open('https://www.baidu.com','_blank')"&gt; &lt;input type="button" value="父窗口" onclick="window.open('https://www.baidu.com','_parent')"&gt; &lt;input type="button" value="顶级窗口" onclick="window.open('https://www.baidu.com','_top')"&gt; &lt;/body&gt; close方法 关闭当前窗口 1&lt;input type="button" value="关闭" onclick="window.close()" /&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置支持类Array]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%86%85%E7%BD%AE%E6%94%AF%E6%8C%81%E7%B1%BBArray%2F</url>
    <content type="text"><![CDATA[创建数组，有两种方式： 第一种 123//创建数组长度为0的数组var arr = [];var array = [false,true,1,2,"abc"]; JS中的数组的数据类型随意，元素个数随意，可以自动扩容，这里和Java是有区别的 12var arr = [1,2,3,false,3.14];arr[5] = "test";//这里不会报错，因为数组会自动扩容 遍历数组 123for(var i=0;i&lt;array.length;i++)&#123; alert(array[i]);&#125; 第二种 123456//创建长度为0的数组var a = new Array();//创建长度为3的数组var b = new Array(3);//长度为2的数组，两个元素分别为3和2var c = new Array(3,2); 数组的常用函数 1234567891011121314&lt;script type="text/javascript"&gt; var a = [1,2,3]; var str = a.join("-");//"1-2-3" //在数组的末尾添加一个元素(数组长度+1) a.push(10); //将数组末尾的元素弹出(数组长度-1) //JS的数组会自动模拟栈，后进先出 var endElt = a.pop(); //反转数组 a.reverse();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周期函数setInterval]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0setInterval%2F</url>
    <content type="text"><![CDATA[关于JS终内置的支持类：Date，可以用来获取时间/日期 获取系统当前时间 12345678&lt;body&gt; &lt;script type="text/javascript"&gt; //获取系统当前时间 var nowTime = new Date(); //输出 document.write(nowTime); &lt;/script&gt;&lt;/body&gt; 效果如下： 调整时间输出格式： 1234567&lt;script type="text/javascript"&gt; //获取系统当前时间 var nowTime = new Date(); //转换成具有本地语言环境的日期格式 nowTime = nowTime.toLocaleString(); document.write(nowTime);&lt;/script&gt; 输出效果如下： 自定义输出格式： 1234567891011&lt;script type="text/javascript"&gt; //获取系统当前时间 var nowTime = new Date(); //获取年 var year = nowTime.getFullYear(); //获取月,范围是0~11，需要加1 var month = nowTime.getMonth(); //获取日 var day = nowTime.getDate(); document.write(year+"年"+(month+1)+"月"+day+"日");&lt;/script&gt; 效果如下： 获取毫秒数 1234567&lt;script type="text/javascript"&gt; //获取系统当前时间 var nowTime = new Date(); //获取毫秒数 var time = nowTime.getTime(); document.write(time);//毫秒数通常被用来当时间戳&lt;/script&gt; 下面来了一个需求 有一个显示系统时间按钮，点击之后在div中显示当前系统时间 同时，该时间会自动更新并显示，即每一秒改变一次 还有一个系统时间停止按钮，点击之后，系统时间会停止更新 代码如下： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;显示时间&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function disPlayTime()&#123; var time = new Date(); time = time.toLocaleString(); document.getElementById("timeDiv").innerHTML = time; &#125; function start()&#123; //setInterval是周期函数 //每隔1000ms(1s)调用disPlayTime函数 //res是全局变量 res = window.setInterval("disPlayTime()",1000); &#125; function stop()&#123; //停止周期函数 window.clearInterval(res); &#125; &lt;/script&gt; &lt;input type="button" value="显示系统时间" onclick="start();" /&gt; &lt;input type="button" value="系统时间停止" onclick="stop();" /&gt; &lt;div id="timeDiv"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取下拉列表选中项的value]]></title>
    <url>%2F2020%2F07%2F13%2F%E8%8E%B7%E5%8F%96%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E9%80%89%E4%B8%AD%E9%A1%B9%E7%9A%84value%2F</url>
    <content type="text"><![CDATA[通常会有这样的需求：前端浏览器首先展示一个下拉列表，用户可以 选择对应的省份；选择之后，需要获取到该下拉列表选中项value；将 该value提交给服务器，服务器底层执行一条SQL语句，返回一个List 集合：List&lt; City&gt; cityList。cityList响应浏览器，浏览器再解析cityList 集合转换成一个新的下拉列表展示在前端，让用户可以进一步选择相 应的城市 那么如何获取选中项的value传递给服务器呢？ 有两种方式： 第一种 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;复选框的全选和取消全选&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;select onchange="alert(this.value)"&gt; &lt;option value=""&gt;----请选择省份----&lt;/option&gt; &lt;option value="hb"&gt;河北省&lt;/option&gt; &lt;option value="hn"&gt;河南省&lt;/option&gt; &lt;option value="sd"&gt;山东省&lt;/option&gt; &lt;option value="sx"&gt;陕西省&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 第二种 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;复选框的全选和取消全选&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var province = document.getElementById("province"); province.onchange = function()&#123; alert(province.value); &#125; &#125; &lt;/script&gt; &lt;select id="province"&gt; &lt;option value=""&gt;----请选择省份----&lt;/option&gt; &lt;option value="hb"&gt;河北省&lt;/option&gt; &lt;option value="hn"&gt;河南省&lt;/option&gt; &lt;option value="sd"&gt;山东省&lt;/option&gt; &lt;option value="sx"&gt;陕西省&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复选框的全选和取消全选]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84%E5%85%A8%E9%80%89%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%A8%E9%80%89%2F</url>
    <content type="text"><![CDATA[需求如下： 有多个复选框，并且设置一个全选按钮，点击该按钮会使得所有的复选框全部被选中或者全部被取消选中 如果不点击全选按钮，一个一个全部点击复选框，当全部被选中时，全选按钮会自动被选中；否则全选按钮自动不被选中 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;复选框的全选和取消全选&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //获取全选框 var allCheck = document.getElementById("all"); //根据name获取所有元素 var interest = document.getElementsByName("interest"); allCheck.onclick = function()&#123; for(var i=0;i&lt;interest.length;i++)&#123; interest[i].checked = allCheck.checked; &#125; &#125; for(var i =0;i&lt;interest.length;i++)&#123; interest[i].onclick = function()&#123; var checkCount = 0; for(var j=0;j&lt;interest.length;j++)&#123; if(interest[j].checked) checkCount++; &#125; //总数量和选中的数量相等时，第一个框被选中 allCheck.checked = (checkCount==interest.length); &#125; &#125; &#125; &lt;/script&gt; &lt;input type="checkbox" id="all" /&gt;全选&lt;br&gt; &lt;input type="checkbox" name="interest" value="smoke" /&gt;抽烟&lt;br&gt; &lt;input type="checkbox" name="interest" value="drink" /&gt;喝酒&lt;br&gt; &lt;input type="checkbox" name="interest" value="hair" /&gt;烫头&lt;br&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单验证]]></title>
    <url>%2F2020%2F07%2F12%2F%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[本文写一个表单验证的项目，算是对前面所学的所有知识的一个小检验，设计HTML、CSS以及JavaScript 表单验证任务需求： 用户名不为空 用户名必须在6-14位之间 用户名只能由数字或字母组成，不能含有其它符号（正则表达式） 密码和确认密码一致，邮箱地址合法 统一失去焦点验证 验证错误提示信息统一在span标签中提示，并且要求字体12号，红色 文本框再次获得焦点后，清空错误提示信息，如果文本框中数据不合法，要求清空文本框的value 最终表单中所有项均合法方可提交（重点） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表单验证&lt;/title&gt; &lt;style type="text/css"&gt; span&#123; color: red; font-size: 12; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //获取username的span标签 var usernameErrorSpan = document.getElementById("usernameError"); //给用户名文本框绑定blur事件 var usernameElt = document.getElementById("username") usernameElt.onblur = function()&#123; //获取用户名 var username = usernameElt.value; //去除前后空白 username = username.trim(); //判断用户名是否为空 if(username.length == 0) usernameErrorSpan.innerText = "用户名不能为空"; else&#123; if(username.length&lt;6 || username.length&gt;14) usernameErrorSpan.innerText = "用户名长度应为6~14"; else&#123; var regExp = /^[0-9a-zA-Z]+$/; var ok = regExp.test(username); if(!ok) usernameErrorSpan.innerText = "用户名只能由数字和字母组成"; &#125; &#125; &#125; usernameElt.onfocus = function()&#123; //清空非法的value if(usernameErrorSpan.innerText!="") usernameElt.value = ""; //清空span usernameErrorSpan.innerText = ""; &#125; //验证密码是否一致 var pwdErrorSpan = document.getElementById("pwdError"); var pwd2Elt = document.getElementById("pwd2"); pwd2Elt.onblur = function()&#123; var pwd = document.getElementById("pwd").value; var pwd2 = pwd2Elt.value; if(pwd != pwd2) pwdErrorSpan.innerText = "密码不一致"; &#125; pwd2Elt.onfocus = function()&#123; if(pwdErrorSpan.innerText!="") pwd2Elt.value = ""; pwdErrorSpan.innerText = ""; &#125; //验证邮箱 var emailErrorSpan = document.getElementById("emailError"); var emailElt = document.getElementById("email"); emailElt.onblur = function()&#123; var emailReg = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/; var ok = emailReg.test(emailElt.value); if(!ok) emailErrorSpan.innerText = "邮箱不合法"; &#125; emailElt.onfocus = function()&#123; if(emailErrorSpan.innerText!="") emailElt.value = ""; emailErrorSpan.innerText = ""; &#125; //给注册按钮绑定鼠标点击事件 var submitBtnElt = document.getElementById("submitBtn"); submitBtnElt.onclick = function()&#123; //当所有表单项都是合法时，提交表单 //手动触发focus和blur事件 usernameElt.focus(); usernameElt.blur(); pwd2Elt.focus(); pwd2Elt.blur(); emailElt.focus(); emailElt.blur(); if(usernameErrorSpan.innerText=="" &amp;&amp; pwdErrorSpan.innerText=="" &amp;&amp; emailErrorSpan.innerText=="") //提交表单 document.getElementById("userform").submit(); &#125; &#125; &lt;/script&gt; &lt;!--表单提交最好使用post，这里为了方便演示采用默认get方式--&gt; &lt;form id="userform" action="https://www.baidu.com"&gt; 用户名：&amp;nbsp;&amp;nbsp; &lt;input type="text" name="username" id="username" /&gt;&lt;span id="usernameError"&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&amp;nbsp;&amp;nbsp; &lt;input type="text" name="email" id="email"&gt;&lt;span id="emailError"&gt;&lt;/span&gt;&lt;br&gt; 密码：&amp;nbsp;&amp;nbsp; &lt;input type="text" name="pwd" id="pwd"&gt;&lt;br&gt; 确认密码：&amp;nbsp;&amp;nbsp; &lt;input type="text" id="pwd2" /&gt;&lt;span id="pwdError"&gt;&lt;/span&gt;&lt;br&gt; &lt;!--这里为了实现最终表单中所有项均合法方可提交的功能，不能用submit 如果用了submit，即使不合法，点击注册也会提交表单 --&gt; &lt;input type="button" value="注册" id="submitBtn" /&gt; &lt;input type="reset" value="重置" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除字符串的前后空白-trim]]></title>
    <url>%2F2020%2F07%2F12%2F%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E5%90%8E%E7%A9%BA%E7%99%BD-trim%2F</url>
    <content type="text"><![CDATA[在做表单验证的时候，通常需要对字符串进行去除前后空白的操作，String类中有trim()方法可以完成上述操作，例如： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;RegExp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var user = document.getElementById("user").value; var newUser = user.trim(); alert("-------&gt;"+newUser+"&lt;-------"); &#125; &#125; &lt;/script&gt; &lt;input type="button" value="click" id="btn" /&gt; &lt;input type="text" id="user" /&gt; &lt;/body&gt;&lt;/html&gt; 注意：上述的代码在Chorme、FireFox可以正常运行，但是对于低版本的IE（比如IE8）却不能正常运行。解决方案如下： 即对String类扩展trim方法，这样就会覆盖String类自带的trim方法 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;RegExp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //低版本的IE浏览器不支持字符串的trim函数，怎么办？ //可以自己对String类扩展一个全新的trim()函数 String.prototype.trim = function() &#123; //在当前的方法中，this代表的是当前字符串 //先去除前空白，再去除后空白 return this.replace(/^\s+/,"").replace(/\s+$/,""); &#125;; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var user = document.getElementById("user").value; var newUser = user.trim(); alert("-------&gt;"+newUser+"&lt;-------"); &#125; &#125; &lt;/script&gt; &lt;input type="button" value="click" id="btn" /&gt; &lt;input type="text" id="user" /&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是正则表达式Regular Expression，正则表达式主要用在字符串格式匹配方面 正则表达式是一门独立的技术，在Java、C++、JavaScript中都支持，大部分编程语言都支持正则表达式 常见的正则表达式符号匹配符号： . ：匹配除换行符以外的任意字符 \w：匹配字母或数字或下划线或汉字 \s：匹配任意的空白符 \d：匹配数字 \b：匹配单词的开始或结束 |：表示或者 ^：匹配字符串的开始 $：匹配字符串的结束 匹配次数： *：重复零次或更多次 +：重复一次或更多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n到m次 反义词： \W：匹配不是字母、数字、下划线、汉字的字符 \S：匹配任意不是空白符的字符 \D：匹配任意非数字的字符 \B：匹配不是单词开头或结束的位置 x：匹配除了x以外的任意字符 aeiou：匹配除了aeiou这几个字母以外的任意字符 字符簇： [a-z] ：匹配所有的小写字母 [A-Z] ：匹配所有的大写字母 [a-zA-Z] ：匹配所有的字母 [0-9] ：匹配所有的数字 [0-9.-] ：匹配所有的数字，句号和减号 （注意：-必须写在括号的最左边或最右边，否则将被认为是一个区间；写在中间也可以，但要加\，例如[0-9.\-+]代表匹配0-9、点、加号和减号） [ \f\r\t\n] ：匹配所有的白字符 a-z //除了小写字母以外的所有字符 简单的正则表达式 QQ号的正则表达式：^ [1-9] [0-9]{4,}$ 邮箱地址正则表达式：^\w+([-+.]\w+)@\w+([-.]\w+) \.\w+([-.]\w+) *$ JS创建正则表达式对象 第一种 1var regExp = /正则表达式/flags; 第二种：使用内置支持类RegExp 1var regExp = new RegExp("正则表达式","flags"); 关于flags的取值： g：全文查找出现的所有pattern i：忽略大小写 m：多行查找（ES规范制定之后才支持），当前面是正则表达式的时候，m不能用；只有当前面是普通字符串的时候才可以用m，如/abc/m 上面创建正则表达式时可以使用单一flags，也可以是组合flags，例如： 12var regExp = /正则表达式/g;var regExp = /正则表达式/gi; 正则表达式对象的test方法用法： 1正则表达式对象.test(用户填写的字符串) 返回结果为true或false。true表示字符串格式匹配成功，反之则为失败 写个例子，进行字符串匹配： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;RegExp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var regExp = /[0-9a-zA-Z.\-+]&#123;1&#125;/; var res = regExp.test(document.getElementById("user").value); alert(res); &#125; &#125; &lt;/script&gt; &lt;input type="button" value="click" id="btn" /&gt; &lt;input type="text" id="user" /&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[innerHTML和innerText操作div和span]]></title>
    <url>%2F2020%2F07%2F11%2FinnerHTML%E5%92%8CinnerText%E6%93%8D%E4%BD%9Cdiv%E5%92%8Cspan%2F</url>
    <content type="text"><![CDATA[innerText和innerHTML属性有什么区别？ 相同点： ​ 都是设置或获取元素内部的内容 不同点： ​ 几乎所有的元素都有innerHTML属性，它是一个字符串，用来设置或获取位于对象起始和结束标签内的HTML(包含html标签)。当设置的时候，innerHTML会把后面的“字符串”当作一段HTML代码解释并执行。例如： 1234&lt;!--如果通过id获取到div标签对象divElt，那么divElt.innerHTML就是："&lt;span&gt;i love&lt;/span&gt;"--&gt;&lt;div id="div"&gt; &lt;span&gt;i love&lt;/span&gt;&lt;/div&gt; ​ innerText可获取或设置指定元素标签内的文本值，从该元素标签的起始位置到终止位置的全部文本内容(不包含html标签)。当设置的时候，innerText即使后面是一段HTML代码，也只是将其当作普通的字符串来看待。例如： 1234&lt;!--如果通过id获取到div标签对象divElt，那么divElt.innerText就是："i love"--&gt;&lt;div id="div"&gt; &lt;span&gt;i love&lt;/span&gt;&lt;/div&gt; innerHTML属性12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;innerHTML和innerText&lt;/title&gt; &lt;style type="text/css"&gt; #div1&#123; background-color: aquamarine; height : 300px; width : 300px; position : absolute; top : 100px; left : 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var divElt = document.getElementById("div1"); divElt.innerHTML = "I LOVE YOU"; divElt.innerHTML = "&lt;font color='red'&gt;I LOVE YOU&lt;/font&gt;"; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="click" id="btn" /&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： innerText属性123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;innerHTML和innerText&lt;/title&gt; &lt;style type="text/css"&gt; #div1&#123; background-color: aquamarine; height : 300px; width : 300px; position : absolute; top : 100px; left : 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var divElt = document.getElementById("div1"); divElt.innerText = "&lt;font color='red'&gt;I LOVE YOU&lt;/font&gt;"; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="click" id="btn" /&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： 上面是设置innerHTML和innerText。下面写一个获取innerHTML和innerText的例子 123456789101112131415&lt;script type="text/javascript"&gt; window.onload = function()&#123; document.getElementById("btn").onclick = function()&#123; var divElt = document.getElementById("div"); document.getElementById("user").value = divElt.innerText; alert(divElt.innerHTML); &#125; &#125;&lt;/script&gt;&lt;input type="button" value="click" id="btn" /&gt;&lt;input type="text" id="user" /&gt;&lt;div id="div"&gt; &lt;span&gt;i love&lt;/span&gt;love&lt;/div&gt; 效果如下： 可以看到，点击click按钮之后，文本框被写入了div标签内的全部文本内容（不包括html标签）；而弹出的窗口中则是div标签内的html语句（包括html标签）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置和获取文本框的value]]></title>
    <url>%2F2020%2F07%2F11%2F%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E6%A1%86%E7%9A%84value%2F</url>
    <content type="text"><![CDATA[获取文本框的value1234567891011&lt;script&gt; window.onload = function()&#123; var btmElt = document.getElementById("btn"). btn.onclick = function()&#123; alert(document.getElementById("user").value) &#125; &#125;&lt;/script&gt;&lt;input type="text" id="user" /&gt;&lt;input type="button" id="btn" value="click!" /&gt; 还有一种情形： 12&lt;!--这里也是获取文本框的value，this指的是文本框对象，blur是失去焦点事件--&gt;&lt;input type="text" value="name" onblur="alert(this.value)" /&gt; 设置文本框的value1234567891011&lt;script&gt; window.onload = function()&#123; var btmElt = document.getElementById("btn"). btn.onclick = function()&#123; document.getElementById("user").value = "set name!" &#125; &#125;&lt;/script&gt;&lt;input type="text" id="user" /&gt;&lt;input type="button" id="btn" value="click!" /&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件]]></title>
    <url>%2F2020%2F07%2F07%2FJS%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JS常用事件 blur：失去焦点 focus：获得焦点 click：鼠标单击 dblclick：鼠标双击 keydown：键盘按下 keyup：键盘弹起 mousedown：鼠标按下 mouseover：鼠标经过 mousemove：鼠标移动 mouseout：鼠标离开 mouseup：鼠标弹起 reset：表单重置 submit：表单提交 change：下拉列表选中项改变，或文本框内容改变 select：文本被选定 load：页面加载完毕，整个HTML页面中所有的元素全部即在完毕之后发生 任何一个事件都会对应一个事件句柄，事件句柄是在事件前面添加on，事件句柄出现在一个标签的属性位置上，以属性的形式存在 注册事件 第一种方式：直接在标签中使用事件句柄 1234567891011&lt;script type="text/javascript"&gt; function sayHello()&#123; alert("hello"); &#125;&lt;/script&gt;&lt;!--对于当前程序来说，sayHello函数被称为回调函数（callback函数）回调函数的特点：自己把这个函数代码写出来了，但是这个函数不是自己负责调用，由其它程序负责调用该函数--&gt;&lt;input type="button" value="click" onclick="sayhello()"&gt; 回调函数：一般写程序是你调用系统的API，如果把关系反过来，你写一个函数，让系统调用你的函数，那就是回调了，那个被系统调用的函数就是回调函数。 同理，如果你调用系统写好的函数，那么对于该系统而言，该函数就是回调函数了 第二种方式：使用纯JS代码完成事件的注册 第一步：先获取按钮对象 第二步：给按钮对象onclick赋值 12345678910&lt;input type="button" value="click" id="mybtn" /&gt;&lt;script type="text/javascript"&gt; function doSome()&#123; alert("do some"); &#125; //第一步：获取按钮对象，document就代表整个HTML页面 var btnObj = document.getElementById("mybtn"); //第二步：给按钮对象的onclick属性赋值，将回调函数doSome注册到click事件上 btnObj.onclick = doSome;//注意：千万别加小括号&lt;/script&gt; 注意：script脚本只能放在button定义下面才可以执行成功。因为浏览器是从上往下执行的，如果放在button上面的话，浏览器找不到mybtn的按钮，所以就不会给它添加事件了，会出现bug 针对上述注意所产生的问题，当然可以把button标签写在JS代码前。但是还有另外一种解决方式：采用load事件！（这种方式最为常用） 123456789101112&lt;script type="text/javascript"&gt; //页面加载的过程中，将a函数注册给了load事件 //页面加载完毕之后，load事件发生了，此时执行回调函数a //回调函数a执行的过程中，将b函数注册给了mybtn的click事件 //当mybtn的节点发生了click事件十周，b函数被调用并执行 window.onload = function()&#123;//回调函数a document.getElementById("mybtn").onclick = function()&#123;//回调函数b alert("do some"); &#125; &#125;&lt;/script&gt;&lt;input type="button" value="click" id="mybtn" /&gt; 也可以直接使用匿名函数注册事件 12345678&lt;input type="button" value="click" id="mybtn" /&gt;&lt;script type="text/javascript"&gt; var btnObj = document.getElementById("mybtn"); //匿名函数的方式 btnObj.onclick = function()&#123; alert("test"); &#125;&lt;/script&gt; 捕捉回车键回车键的键值是13 ESC键的键值是27 123456789101112&lt;script type="text/javascript"&gt; window.onload = function()&#123; var Elt = document.getElementById("username").onkeydown = function(event)&#123; //浏览器执行事件，调用回调函数时，会传过来一个事件对象，这里用event接收该事件对象 //对于键盘事件对象来说，都有keyCode属性来获取键值 //获取键值 if(event.keyCode===13) alert("正在登录")； &#125; &#125;&lt;/script&gt;&lt;input type="text" id="username" /&gt; Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 当一个事件发生的时候，和当前这个对象发生的这个事件有关的一些详细信息（包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息等。这个对象是在执行事件时，浏览器通过函数传递过来的。）都会被临时保存到一个指定的地方——event对象，供我们在需要的时候调用 在 W3C 规范中，event 对象是随事件处理函数传入的，Chrome、FireFox、Opera、Safari、IE9.0及其以上版本都支持这种方式；但是对于 IE8.0 及其以下版本，event 对象必须作为 window 对象的一个属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型]]></title>
    <url>%2F2020%2F07%2F06%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[虽然JS的变量在声明的时候不需要指定数据类型，但是在赋值的时候，每一个数据还是有类型的 JS的数据类型包括原始类型和引用类型 原始类型 Undefined：只有一个值，就是undefined。当一个变量没有手动赋值，系统默认赋值undefined，或者也可以给一个变量手动赋值undefined Number：包括数字（整数和小数）、NaN（不是数字）、Infinity（无穷大）。 什么情况下结果是NaN？运算结果本来应该是一个数字，最后算完不是一个数字的时候，结果是NaN。例如 1234var a = 10;var b = "char";alert(a/b);//除号显然最后结果应该是数字，但是运算的过程中导致最后不是一个数字，结果是NaNalert(a+b);//这里会做字符串拼接，结果不是NaN，是"10char" 当除数为0时，结果为Infinity isNaN()函数，用法：isNaN(数据)，结果为true表示不是一个数字，false表示是一个数字。isNaN=is not a Number parseInt()函数：可以将字符串自动转换成数字，并且取整数位 parseFloat()函数：可以将字符串自动转换成数字 Math.ceil（)函数：向上取整 String ：可以使用单引号，也可以使用双引号。其父类是Object 怎么创建字符串对象？ 第一种：var s1 = “abc”;s1是String类型（小String），属于原始类型Stirng 第二种：var s2 = new String(“abc”);s2是Object类型（大String） 无论小String还是大String，它们的属性和函数都是通用的 length属性，可以获取字符串长度，如s1.length；结果为3 prototype属性，下面介绍Object的时候会说 String类型常用函数： indexOf：获取指定字符串在当前字符串中第一次出现处的索引 lastIndexOf：获取指定字符串在当前字符串中最后一次出现处的索引 replace：替换（如果存在多个要替换，只会替换第一个；如果想全部替换，用正则表达式，即加一个flags：g，代表全局匹配，比如/\s+/g代表替换全部的空白符）。和Java的replace不太一样，Java中的是全部替换的，且Java还有repalceAll方法，而JS中没有该方法 substr：截取字符串，substr(2,4)：从2开始截取4个字符 substring：截取字符串，substring(2,4)，截取从2到4的字符串，不包括4 toLowerCse：转换小写 toUpperCase：转换大写 split：切分字符串 Boolean：只有两个值：true和false。在Boolean类型中有一个函数叫：Boolean(数据)，其作用是将非Boolean类型转换为Boolean类型。if语句的小括号里面的数据必须是Boolean类型，如果该数据是非Boolean类型，会自动调用Boolean()函数，将其转换成Boolean类型 Boolean()函数将哪些数据转换成true？转换规律：”有”就转换成true，”没有”就转换成false。例如1就是有，0就是没有；””就是没有，”jack”就是有；null、NaN、undefined就是没有，Infinity就是有 Null：只有一个值，就是null。 Symbol(ES6及其之后版本才有这个类型) 引用类型 Object以及Object的子类 Object类型是所有类的超类，自定义的任何类，默认继承Object 包括哪些属性？ prototype（常用）:给类动态的扩展属性和函数 constructor 包括哪些函数？ toString() valueOf() toLocalString() 在JS中定义的类默认继承Object，会继承Object类中所有的属性和函数，因此自定义的类中也有prototype属性 定义类的语法： 1234567891011121314//第一种方式function 类名(形参)&#123; &#125;//第二种方式类名 = function(形参)&#123; &#125;//创建对象的语法var o = new 类名(实参);//o是一个引用，指向堆内存的对象/*定义类和定义函数的方式一样重点看怎么使用：如果没有用new，那就是函数调用；如果使用了new，那就是创建对象*/ JS当中类的定义，同时又是一个构造函数的定义。在JS中类的定义和构造函数的定义是放在一起来完成的 1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt; function user(a,b,c) &#123; //必须要加this //如果不加this，就代表该变量是全局变量 this.r = a; this.e = b; this.q = c; m = a; //定义类函数 this.getA = function()&#123; return this.a; &#125; &#125; var o = new user(10,20,30); alert(o.r); //10 //这里类中并没有定义m属性，为什么不报错？ //因为这里是获取对象属性，对象是存在的，如果没有声明该属性，就会是undefined //如果alert(o.t),则还是undefined；但是如果alert(t)，就会报错，因为没有定义该变量 //这里需要注意！！！ alert(o.m);//undefined，因为m属性不属于user类，m是全局变量(没有用this) var pro = o.getA();//调用类中的函数 alert(pro); //10 //访问一个对象的属性，还可以使用如下语法: alert(o["r"]);&lt;/script&gt; 可以通过prototype这个属性给类动态扩展属性以及函数，如果扩展的新函数与类中的函数重名，那么会进行覆盖 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; function User(name)&#123; this.name = name; &#125; var pro = new user("lisi"); //动态扩展函数 User.prototype.getName = function()&#123; return this.name; &#125; var pname = pro.getName(); alert(pname);//"lisi" //动态扩展属性 User.prototype.no = 1314； alert(pro.no);//1314 //由于String的父类是Object，所以也可以这样动态扩展 String.prototype.add = function()&#123; alert("new add"); &#125; "abc".add();//"new add"&lt;/script&gt; JS中有一个运算符typeof，可以在程序的运行阶段动态的获取变量的数据类型，语法格式为：typeof 变量名 typeof运算结果是以下6个字符串之一，注意字符串都是小写： “undefined” “number” “string” “boolean” “object” “function” 在JS中比较字符串是否相等，采用== 1234567891011121314151617var a;typeof a; //"undefined"var b = 10;typeof b; //"number"var c = "abc";typeof c; //"string"var d = null;typeof d; //"object",但null属于Null类型，这里要注意var f = false;typeof f; //"boolean"function say()&#123;&#125;typeof say; //"function" null、NaN和undefined的区别 数据类型不一致 null和undefined可以等同 NaN与任何值都不相等，与自己也不相等 1234alert(null==NaN) //falsealert(null==undefined) //truealert(NaN==undefined) //falsealert(NaN==NaN) //false 在JS中有两个比较特殊的运算符： ==：等同运算符，只判断值是否相等 ===：全等运算符，即判断值是否相等，又判断数据类型是否相等]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数]]></title>
    <url>%2F2020%2F07%2F06%2FJS%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JS中的函数等同于Java语言中的方法，函数也是一段可以被重复利用的代码片段 函数一般都是可以完成某个特定功能的 回顾Java中的方法：[修饰符列表] 返回值类型 方法名（形式参数列表）{方法体} JS函数定义 语法格式如下： 123456789//第一种方式function 函数名(形式参数列表)&#123; 函数体&#125;//第二种方式函数名 = function(形式参数列表)&#123; 函数体&#125; JS中的函数不需要指定返回值类型，返回什么类型都行 举个例子： 12345function sum(a,b)&#123; //a和b都是局部变量，形参(a和b都是变量名，不需要类型) //不用写成function(var a,var b) alert(a+b);&#125; 函数必须手动调用才能执行！！不调用是不会执行的 123456789&lt;script type="text/javascript"&gt; function sum(a,b)&#123; alert(a+b); &#125;&lt;/script&gt;&lt;!--这里调用了sum函数--&gt;&lt;!--这里和直接写alert函数一样，只不过alert是在自带的函数，而sum是我们自定义的--&gt;&lt;input type="button" onclick="sum(10,20);"&gt; Java中的方法有重载机制 JS中的函数在调用的时候，参数的类型和个数都没有限制。但是不能重载，JS中如果出现两个同名函数，后面的函数会覆盖前面的函数 1234567891011&lt;script&gt; function test(username)&#123; alert("test"); &#125; function test()&#123; alert("test test") &#125; //函数调用 test("lisi");//test test，调用的是第二个函数&lt;/script&gt; 在JS中分辨两个函数就是通过函数名，其余都不用 123456789101112131415161718&lt;script&gt; function sum(a,b)&#123; alert(a+b); &#125; var ret1 = sum(1,2); alert(ret1);//3 var ret2 = sum("jack");//jack赋值给a，b采用系统默认赋值undefined alert(ret2);//jackundefined var ret3 = sum(); alert(ret3);//NaN,是一个具体存在的值，该值表示不是数字(Not a Number) var ret4 = sum(1,2,3);//3没有被赋值 alert(ret4);//3 &lt;/script&gt; 从上面可以看到，一个函数可以被反复使用，根据在调用时不同的实参，会出现不同的结果]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS变量]]></title>
    <url>%2F2020%2F07%2F06%2FJS%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[JS的标识符命名规则和规范按照java执行： 命名规则：标识符必须是英文字母、数字、下划线和美元符号$的组合；且不能以数字开头；不能使用关键字 标识符命名规范（驼峰）：首字母小写，后面每个单词首字母大写 java语言是一种强类型语言，强类型怎么理解？ java语言存在编译阶段，假设有代码：int i； 那么在java中有一个特点是：java程序在编译阶段就已经确定了i变量的数据类型，该i变量的数据类型在编译阶段是int类型。那么这个变量直到最终内存释放，一直都是int类型，不可能变成其它类型 JS声明变量 1var 变量名; JS变量赋值 1变量名 = 值; JavaScript是一种弱类型语言，没有编译阶段，一个变量可以随意赋值，赋什么类型的值都行 变量的类型取决于等号右边，赋什么类型的值，该变量就是什么类型，可以动态的改变。但是java就不行，变量的类型取决于等号左边，在编译阶段就已经确定 变量如果没有手动赋值，系统默认赋值undefined（undefined在JS中是一个具体存在值） 变量必须声明之后才可以访问！否则会有语法错误 注意：多个变量声明应注意以下内容 12//a、b都是undefined，c是200var a,b,c = 200; 全局变量和局部变量 全局变量：在函数体之外声明的变量，生命周期是浏览器从打开到关闭，尽量少用，太占浏览器的内存。能使用局部变量尽量使用局部变量 局部变量：在函数体内声明的变量，包括一个函数的形参。局部变量的生命周期是：函数开始执行时局部变量的内存空间开辟，函数执行结束之后，局部变量的内存空间释放 注意：全局变量和局部变量重名时，在函数体内访问该变量，局部变量会覆盖全局变量，即访问的是局部变量 注意：如果一个变量在声明时没有使用var关键字，不管在哪里声明，该变量都是全局变量 123function myfun()&#123; name = "lisi";//name是全局变量&#125; JS创建数组 123//创建数组长度为0的数组var arr = [];var array = [false,true,1,2,"abc"]; JS中的数组的数据类型随意，元素个数随意，可以自动扩容，这里和Java是有区别的 遍历数组 123for(var i=0;i&lt;array.length;i++)&#123; alert(array[i]);&#125; 运算符之void 需求：既保留住超链接的样式，同时用户点击该超链接的时候执行一段JS代码，但页面还不能跳转 先尝试写一下 1&lt;a href="https://www.baidu.com" onclick="alert(test)"&gt;百度&lt;/a&gt; 上述代码执行之后，会有超链接的样式；点击该超链接之后会执行JS代码，产生弹窗；但是关闭该弹窗之后，还是会跳转 为了解决上述问题，使用void关键字 1&lt;a href="javascript:void(0)" onclick="alert(test)"&gt;百度&lt;/a&gt; void运算符的语法：void(表达式)。运算原理：执行表达式，但不返回任何结果 JS控制语句 if switch while do while for循环 break、continue for…in语句（JS特有） 用for…in遍历数组 1234for(var i in array)&#123; //这里的i是数组下标，不同于java的for...each alert(arr[i]);&#125; with语句（JS特有） 123456789101112function user(a,b,c) &#123; this.r = a; this.e = b; this.q = c; &#125; var o = new user(10,20,30); alert(o.r); //10 //使用with语句 with(o)&#123; alert(r);//10 &#125; 前6个和java的控制语句一模一样]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML嵌入JS代码]]></title>
    <url>%2F2020%2F07%2F06%2FHTML%E5%B5%8C%E5%85%A5JS%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[共有三种方式在HTML中嵌入JS代码 第一种要实现的功能：用户点击按钮，弹出消息框 JS是一门事件驱动型的编程语言，依靠事件去驱动，然后执行对应的程序。在JS中有很多事件，其中有一个事件叫做：鼠标单击（click）。并且任何时间都会对应一个事件句柄（事件和事件句柄的区别是：事件句柄是在事件单词的前面添加一个on）。click事件对应的事件句柄是onclick。事件句柄是以HTML标签属性的方式存在 onclick=”JS代码”的执行原理是什么？页面打开的时候，js代码并不会执行，只是把这段js代码注册到按钮的click事件上了，等这个按钮发生click事件之后，注册在onclick后面的js代码会被浏览器自动调用 JS中的字符串可以使用双引号，也可以使用单引号 JS中的一条语句结束之后，可以使用分号，也可以不使用 1&lt;input type="button" onclikc="alert('hello')" value="Click me!"&gt; 其中alert(‘hello’)就是注册到click事件上的JS代码 也可以写多个alert，点击按钮之后会依次弹出，即第一个关闭之后就会弹出第二个，依次进行 第二种脚本块方式 暴露在脚本块中的程序，在页面打开的时候执行 并且遵循自上而下的顺序依次执行（这个代码的执行不需要事件） JavaScript的脚本块在一个页面中可以出现多次，没有要求 JavaScript的脚本块出现位置也没有要求，随意（任意位置都可以），但不同脚本块遵循自上而下的执行原则 123&lt;script type="text/javascript"&gt; alert("hello");&lt;/script&gt; alert函数会阻塞整个HTML页面的加载，只有把弹窗点击之后，才会继续加载 第三种引入外部独立的JS文件，推荐使用 外部js文件（放在和html文件同级目录中的js文件夹中），文件名为1.js： 12//1.jsalert("hello"); html文件： 123456789&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;第三种方式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src=“js/1.js&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在需要的位置引入js脚本文件 引入外部独立的js文件的时候，js文件中的代码会遵循自上而下的顺序依次逐行执行 同一个js文件可以被引入多次，但实际开发中这种需求很少 当引入外部js文件时，不能在该&lt; script&gt;标签中写js代码了 123&lt;script type="text/javascript" src=“js/1.js&gt; alert("test");&lt;/script&gt; 这里的alert(“test”)是不会被执行的！！ 如果引入了外部js文件，在html文件中依旧可以用第二种方式嵌入js代码，但是遵循自上而下原则 123456&lt;script type="text/javascript" src=“js/1.js&gt; alert("test");&lt;/script&gt;&lt;script type="text/javascript"&gt; alert("jack");&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript概述]]></title>
    <url>%2F2020%2F07%2F06%2FJavaScript%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是JavaScriptJavaScript是运行在浏览器上的脚本语言，简称JS JavaScript是网景公司（NetScape）的布兰登艾奇开发的，最初叫LiveScript LiveScript的出现让浏览器更加生动，不再是单纯的静态页面了，更具有交互性 和Java没关系，Java运行在JVM当中，JavaScript运行在浏览器的内存当中 JavaScript不需要手动编译，编写完源代码之后，浏览器直接打开解释执行 JavaScript的目标程序（能够被执行的程序）以普通文本形式保存，这种语言都成为脚本语言 Java的目标程序以.class的形式存在，不能使用文本编辑器打开，不是脚本语言 LiveScript的出现，最初的时候是为Navigator浏览器（网景公司开发的）量身定做的，不支持其它浏览器。为此，微软开发了一种只支持IE浏览器的脚本语言，叫做JScript。 JavaScript和JScript语言并存的时代，程序员十分痛苦，因为要写两套程序。在这种情况下，一个非盈利性组织站了出来，叫做ECMA组织（欧洲计算机协会），ECMA根据JavaScript制定了ECMA-262标准，叫做ECMA-Script（简称ES），因此也可以认为现在的ES就是标准化的JavaScript语言 JS代码的单行注释和多行注释方法与Java一样！！ JavaScript的组成由三部分组成：ECMAScript，BOM，DOM。ECMAScript是核心解释器（JS核心语法）、DOM(Document Object Model)是文档对象模型、BOM(Browser Object Model)是浏览器对象模型 ECMAScriptJavscript，JScript，ActionScript等脚本语言都是基于ECMAScript标准实现的。ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。 它本身不包含输入输出定义；ECMA-262规定了语法、类型、语句、关键词、保留字、操作符、对象，ECMAScript就是对实现该规定的各个方面内容的语言的描述。javascript实现了ECMAScript。 DOMDOM 是“ Document Object Model ”的缩写，简称“ 文件对象模型 ”，由W3C制定规范。 DOM 定义了 JavaScript 操作 HTML 文档的接口，提供了访问 HTML 文档（如body、form、div、textarea等）的途径以及操作方法。 DOM树上的每一个节点都有唯一的id属性 对网页当中的节点进行增删改的过程，HTML文档被当做一棵DOM树来看待。例如： 1var domObj = document.getElementById("id"); BOMBOM 是“ Browser Object Model ”的缩写，简称“ 浏览器对象模型 ”。 BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录、后退、关闭浏览器窗口、打开新窗口、浏览器地址栏上地址等）的途径以及操作方法。 遗憾的是，BOM 只是 ECMAScript 的一个扩展，没有任何相关标准，W3C也没有对该部分作出规范，每个浏览器厂商都有自己的 BOM 实现，这可以说是 BOM 的软肋所在。 通常情况下，浏览器特定的（即非 W3C 标准规定的）JavaScript 扩展都被看作 BOM 的一部分，主要包括： 关闭、移动浏览器及调整浏览器窗口大小； 弹出新的浏览器窗口； 提供浏览器详细信息的定位对象； 提供载入到浏览器窗口的文档详细信息的定位对象； 提供用户屏幕分辨率详细信息的屏幕对象； 提供对cookie的支持； 加入ActiveXObject类扩展BOM，通过JavaScript实例化ActiveX对象。 DOM和BOM的区别和联系BOM的顶级对象是Window，DOM的顶级对象是Document 实际上BOM是包含DOM的，如图所示：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML引入CSS样式的三种方式]]></title>
    <url>%2F2020%2F07%2F06%2FHTML%E5%BC%95%E5%85%A5CSS%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[内联定义第一种方式，在标签内部使用style属性来设置元素的CSS样式。语法格式为： 1&lt;标签 style="样式名:样式值;样式名:样式值;..."&gt;&lt;/标签&gt; 样式块方式第二种方式，在head标签中使用style块，这种方式被称为样式块方式，语法格式为： 1234567891011121314&lt;head&gt; &lt;style type="text/css"&gt; 选择器&#123; 样式名:样式值; 样式名:样式值; ... &#125; 选择器&#123; 样式名:样式值; 样式名:样式值; ... &#125; &lt;/style&gt;&lt;/head&gt; 选择器： id选择器：只针对某一个id的元素设置样式，格式为#id{} 标签选择器：针对html文件中所有该标签，设置所有该标签的样式，格式为标签名{} 类选择器：针对同一class名的元素，设置其样式，格式为.类名{}。但注意，需要在写html元素时设置其类名属性，如： 12345&lt;input type="text" class="myclass"&gt;&lt;select class="myclass"&gt; &lt;option&gt;a&lt;/option&gt; &lt;option&gt;b&lt;/option&gt;&lt;/select&gt; 此时，上面两个元素是同一个类，所以使用类选择器便可以实现两个不同的元素的统一样式设置： 12345&lt;style type="text/css"&gt; .myclass&#123; font : 20px; &#125;&lt;/style&gt; 链入外部样式表文件将样式写到一个独立的xx.css文件当中（定义方式和上述的样式块方式一样），在需要的html文件中的head标签内直接引入css文件，样式就引入了，这种方式最常用，这种方式易维护，维护成本较低。语法格式如下： 1&lt;link type="text/css" rel="stylesheet" href="css文件的路径" /&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS概述]]></title>
    <url>%2F2020%2F07%2F06%2FCSS%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是CSSCSS（Cascading Style Sheet），层叠样式表语言 CSS的作用修饰HTML页面，设置HTML页面中某些元素的样式，让HTML页面更好看 CSS好比是HTML的化妆品一样 HTML还是主体，CSS依赖HTML。CSS的存在就是修饰HTML，所以新建的文件还是xx.html文件]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML列表]]></title>
    <url>%2F2020%2F07%2F04%2FHTML%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表分为有序列表和无序列表 无序列表 12345678910111213141516&lt;ul&gt; &lt;li&gt;中国 &lt;ul&gt; &lt;li&gt;北京 &lt;ul&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;li&gt;东城区&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;li&gt;日本&lt;/li&gt;&lt;/ul&gt; 无序列表可以嵌套 效果如下： 看到坐标有小圆点、小方块等，可以设置每一级列表的标识，有三种：circle、square和disc。设置方式为： 1&lt;ul type="square"&gt;&lt;/ul&gt; 有序列表 12345678910111213141516&lt;ol&gt; &lt;li&gt;中国 &lt;ol&gt; &lt;li&gt;北京 &lt;ol&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;li&gt;东城区&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;li&gt;日本&lt;/li&gt;&lt;/ol&gt; 有序列表也可以嵌套 效果如下： 也可以设置前面的标识：比如a或A代表字母，1代表数字（默认），i或I代表罗马数字 1&lt;ol type="a"&gt;&lt;/ol&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div和span在网页中的应用]]></title>
    <url>%2F2020%2F07%2F04%2Fdiv%E5%92%8Cspan%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[div和span是什么div和span都可以称为“图层” 图层就是一个一个的盒子，div嵌套div就是盒子套盒子 div和span有什么用图层的作用是为了保证页面可以灵活的布局 最早的网页是使用table进行布局，但是table不灵活，太死板 div和span是可以定位的（利用CSS样式），只要定下div的左上角的x轴和y轴坐标即可 默认情况下，div是一个块级元素，它包含的元素会自动换行；span是行内元素，不会自动换行 div可以嵌套div，也可以嵌套span span只能嵌套span，不能嵌套div HTML 块元素大多数 HTML 元素被定义为块级元素或内联元素。 编者注：“块级元素”译为 block level element，“内联元素”译为 inline element。 块级元素在浏览器显示时，通常会以新行来开始和结束，即会自动换行 例子：&lt; h1&gt;, &lt; p&gt;, &lt; ul&gt;, &lt; table&gt; HTML 内联元素内联元素在显示时不会以新行开始。 例子：&lt; b&gt;, &lt; td&gt;, &lt; a&gt;, &lt; img&gt; 注意：块元素相当于内嵌元素在前后各加一个&lt; br&gt;换行 HTML &lt; div&gt; 元素HTML &lt; div&gt; 元素是块级元素，它是可用于组合其他 HTML 元素的容器。 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会自动换行 如果与 CSS 一同使用，&lt; div&gt; 元素可用于对大的内容块设置样式属性。 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt; table&gt; 元素进行文档布局不是表格的正确用法。&lt; table&gt; 元素的作用是显示表格化的数据。 HTML &lt; span&gt; 元素HTML &lt; span&gt; 元素是内联元素，可用作文本的容器，不会自动换行 &lt; span&gt; 元素也没有特定的含义。 当与 CSS 一同使用时，&lt; span&gt; 元素可用于为部分文本设置样式属性 注意：span元素宽度是被包围的内容宽度决定，不建议给span设置宽度属性width]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML文档中元素的ID属性]]></title>
    <url>%2F2020%2F07%2F04%2FHTML%E6%96%87%E6%A1%A3%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84ID%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在HTML文档中，任何元素（节点）都有id属性，比如&lt; html&gt;、&lt; head&gt;、&lt; body&gt;、&lt; form&gt;等。id属性是该节点的唯一标识，所以在同一个HTML文档当中id值不能重复 注意：表单提交数据的时候，只和name有关系，和id没关系 id属性有什么用？ javascript语言，可以对HTML文档中的任意节点进行增删改操作 在进行增删改之前，需要先拿到这个节点，通过id来获取节点 id的存在让我们获取节点更方便 HTML文档是一棵树（DOM树，即Document树），树上有很多节点，每一个节点都有唯一的id javascript主要就是对这棵DOM树进行增删改]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTMLL表单]]></title>
    <url>%2F2020%2F07%2F03%2FHTMLL%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[表单的作用收集不同类型的用户输入。表单展现之后，用户填写表单，点击提交按钮提交数据给服务器 &lt; form &gt; 标签HTML 表单用于收集用户输入。 元素定义 HTML 表单： 实例 12345&lt;form&gt; . form elements .&lt;/form&gt; Action属性action属性定义向哪个服务器提交表单，用来指定服务器地址 action属性和超链接中的href属性一样，都可以向服务器发送请求 向服务器提交表单的通常做法是使用提交按钮。 通常，表单会被提交到 web 服务器上的网页。 注意：如果省略 action 属性，则 action 会被设置为当前页面。 Method 属性method属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）： 1&lt;form action="action_page.php" method="GET"&gt; 或： 1&lt;form action="action_page.php" method="POST"&gt; 何时使用 GET？ 默认方法 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。 当您使用 GET 时，表单数据在页面地址栏中是可见的： 1action_page.php?firstname=Mickey&amp;lastname=Mouse 注释：GET 最适合少量数据的提交。浏览器会设定容量限制。 何时使用POST？ 如果表单正在更新数据，或者包含敏感信息（例如密码）。 POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 采用post方式，表单提交数据的格式同get一样，区别在于是否显示出来 &lt; form&gt;属性列表： 属性 描述 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集） action 规定向何处提交表单的地址（URL）（提交页面） autocomplete 规定浏览器应该自动完成表单（默认：开启） enctype 规定被提交数据的编码（默认：url-encoded） method 规定在提交表单时所用的 HTTP 方法（默认：GET） name 规定识别表单的名称（对于 DOM 使用：document.forms.name） novalidate 规定浏览器不验证表单 target 规定 action 属性中地址的目标（默认：_self） HTML 表单包含表单元素表单元素指的是不同类型的 input 元素、文本域、下拉列表等等。 注意：如果要正确地被提交，该表单元素必须设置一个 name 属性。否则无法被提交 input元素最重要的表单元素是 &lt; input &gt;元素。 &lt; input &gt; 元素根据不同的 type属性，可以变化为多种形态。下面详细介绍一下&lt; input &gt;元素所有的输入类型 text：&lt; input type=”text” &gt;定义供文本输入的单行输入字段 1234567&lt;form&gt; First name:&lt;br&gt; &lt;input type="text" name="firstname"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type="text" name="lastname"&gt;&lt;/form&gt; password：&lt; input type=”password” &gt; 定义密码字段： 1234567&lt;form&gt; User name:&lt;br&gt; &lt;input type="text" name="username"&gt; &lt;br&gt; User password:&lt;br&gt; &lt;input type="password" name="psw"&gt;&lt;/form&gt; 注意：password 字段中的字符会被做掩码处理（显示为星号或实心圆）。 submit：&lt; input type=”submit” &gt; 定义提交表单数据至表单处理程序的按钮 value设置提交按钮的显示文本 表单处理程序（form-handler）通常是包含处理输入数据的脚本的服务器页面。 在表单form的 action 属性中规定表单处理程序（form-handler） 12345678910&lt;!--这里的action就是表单处理程序--&gt;&lt;form action="action_page.php"&gt; First name:&lt;br&gt; &lt;input type="text" name="firstname" value="Mickey"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type="text" name="lastname" value="Mouse"&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" value="Submit"&gt;&lt;/form&gt; 注意：如果省略了提交按钮的 value 属性，那么该按钮将使用默认文本显示 reset：&lt; input type=”radio” &gt; 定义清空按钮 value设置清空按钮的显示文本 1&lt;input type="reset"&gt;&lt;/input&gt; radio：&lt; input type=”radio” &gt; 定义单选按钮。单选按钮的value必须手动指定 12345&lt;form&gt;&lt;input type="radio" name="sex" value="male" checked&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt; 注意：checked表示默认选择了该单选按钮，此例中为男。如果不加checked，则不会默认选择 checkbox：&lt; input type=”checkbox”&gt; 定义复选框，允许用户在有限数量的选项中选择零个或多个选项 12345&lt;form&gt; &lt;input type="checkbox" name="vehicle" value="Bike"&gt;I have a bike &lt;br&gt; &lt;input type="checkbox" name="vehicle" value="Car"&gt;I have a car &lt;/form&gt; 注意：加checked可以默认选中，如 123456&lt;!--默认Bike被选中--&gt;&lt;form&gt; &lt;input type="checkbox" name="vehicle" value="Bike" checked=true&gt;I have a bike &lt;br&gt; &lt;input type="checkbox" name="vehicle" value="Car"&gt;I have a car &lt;/form&gt; button：&lt;input type=”button&gt; 定义按钮 1&lt;input type="button" onclick="alert('Hello World!')" value="Click Me!"&gt; 点击之后，浏览器会弹出helloworld！的提示信息 HTML5新增输入类型 HTML5 增加了多个新的输入类型： color：&lt; input type=”color”&gt; 用于应该包含颜色的输入字段。根据浏览器支持，颜色选择器会出现输入字段中 1234&lt;form&gt; Select your favorite color: &lt;input type="color" name="favcolor"&gt;&lt;/form&gt; date：&lt; input type=”date”&gt; 用于应该包含日期的输入字段。根据浏览器支持，日期选择器会出现输入字段中。 1234&lt;form&gt; Birthday: &lt;input type="date" name="bday"&gt;&lt;/form&gt; 可以向输入添加限制 123456&lt;form&gt; Enter a date before 1980-01-01: &lt;input type="date" name="bday" max="1979-12-31"&gt;&lt;br&gt; Enter a date after 2000-01-01: &lt;input type="date" name="bday" min="2000-01-02"&gt;&lt;br&gt;&lt;/form&gt; 这样，在日期选择当中只会出现符合限制条件的日期供选择 datetime：&lt; input type=”datetime”&gt; 允许用户选择日期和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中 1234&lt;form&gt; Birthday (date and time): &lt;input type="datetime" name="bdaytime"&gt;&lt;/form&gt; 注意：Chrome、Firefox 或 Internet Explorer 不支持 type=”datetime”。 datetime-local：&lt; input type=”datetime-local”&gt; 允许用户选择日期和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中 1234&lt;form&gt; Birthday (date and time): &lt;input type="datetime-local" name="bdaytime"&gt;&lt;/form&gt; 注意：Firefox 或者 Internet Explorer 不支持 type=”datetime-local”。 email：&lt; input type=”email”&gt; 用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证 1234&lt;form&gt; E-mail: &lt;input type="email" name="email"&gt;&lt;/form&gt; month：&lt; input type=”month”&gt; 允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中 1234&lt;form&gt; Birthday (month and year): &lt;input type="month" name="bdaymonth"&gt;&lt;/form&gt; number：&lt; input type=”number” &gt; 用于应该包含数字值的输入字段。能够对数字做出限制，如果超出范围会提示超出范围 1234&lt;form&gt; Quantity (between 1 and 5): &lt;input type="number" name="quantity" min="1" max="5"&gt;&lt;/form&gt; range：&lt; input type=”range”&gt; 用于包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件 123&lt;form&gt; &lt;input type="range" name="points" min="0" max="10"&gt;&lt;/form&gt; 注意：能够使用如下属性来规定限制：min、max、step、value（输入限制字段下面会介绍） search：&lt; input type=”search”&gt; 用于搜索字段（搜索字段的表现类似常规文本字段） 1234&lt;form&gt; Search Google: &lt;input type="search" name="googlesearch"&gt;&lt;/form&gt; tel：&lt; input type=”tel”&gt; 用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型 time：&lt; input type=”time”&gt; 允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中 1234&lt;form&gt; Select a time: &lt;input type="time" name="usr_time"&gt;&lt;/form&gt; url：&lt; input type=”url”&gt; 用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段 week：&lt; input type=”week”&gt; 允许用户选择周和年。 根据浏览器支持，日期选择器会出现输入字段中。 1234&lt;form&gt; Select a week: &lt;input type="week" name="week_year"&gt;&lt;/form&gt; 注意：老式 web 浏览器不支持的输入类型，会被视为输入类型 text file：&lt; input type=”file”&gt; 用于选择文件上传 12&lt;!--添加multiple，允许选择多个文件上传--&gt;&lt;input type="file" name="myfile" multiple="multiple"&gt; hidden：&lt; input type=”file”&gt; ，隐藏域，网页上看不到，但是表单提交时数据会自动提交给服务器 1&lt;input type="hidden" name="userID" value="111"&gt; 输入限制 属性 描述 disabled 规定输入字段应该被禁用 max 规定输入字段的最大值 maxlength 规定输入字段的最大字符数 min 规定输入字段的最小值 pattern 规定通过其检查输入值的正则表达式 readonly 规定输入字段为只读（无法修改） required 规定输入字段是必需的（必需填写） size 规定输入字段的宽度（以字符计） step 规定输入字段的合法数字间隔 value 规定输入字段的默认值 disabled和readonly的异同点： 相同点：都是只读，不能修改 不同点：readonly可以提交给服务器，disabled数据不会提交（即使有name属性也不会提交） select元素&lt; select&gt; 元素定义下拉列表： 123456&lt;select name="cars"&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;option value="fiat"&gt;Fiat&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; &lt; option&gt; 元素定义待选择的选项。 列表通常会把首个选项显示为默认选项，即volvo。所以为了好看，通常可以这么写 1234567&lt;select name="cars"&gt; &lt;option value=""&gt;----请选择----&lt;/option&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;option value="fiat"&gt;Fiat&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; 您能够通过添加 selected 属性来定义默认选项。 1&lt;option value="fiat" selected&gt;Fiat&lt;/option&gt; 此时默认选项为fiat size可以设置默认显示的条数，默认是1 1&lt;select name="cars" size="2"&gt;&lt;/select&gt; 此时默认显示的条数就是2 下拉列表如何支持多选？ 1&lt;select name="cars" multiple="multiple"&gt;&lt;/select&gt; 按住ctrl键便可实现多选 textarea元素&lt; textarea&gt; 元素定义多行输入字段（文本域）： 123&lt;textarea name="message" rows="10" cols="30"&gt;The cat was playing in the garden.&lt;/textarea&gt; 注意：rows代表行数，cols代表列数 button元素&lt; button&gt; 元素定义可点击的按钮： 1&lt;button type="button" onclick="alert('Hello World!')"&gt;Click Me!&lt;/button&gt; 和input元素中的type=button效果一样，点击之后会有弹窗！ HTML5新增元素 datalist：&lt; datalist&gt; 元素为 &lt; input&gt; 元素规定预定义选项列表。用户会在他们输入数据时看到预定义选项的下拉列表（相当于智能提醒，你在输入几个字母后会提示带匹配的选项）。&lt; input&gt; 元素的 list 属性必须引用 &lt; datalist&gt; 元素的 id 属性。 1234567891011&lt;form action="https://www.baidu.com"&gt; &lt;input type="text" list="browsers" name="browser"&gt; &lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;/datalist&gt; &lt;input type="submit"&gt;&lt;/input&gt;&lt;/form&gt; keygen output 用 &lt; fieldset&gt; 组合表单数据&lt; fieldset&gt; 元素组合表单中的相关数据 当一组表单元素放到 &lt; fieldset&gt; 标签内时，浏览器会以特殊方式来显示它们，它们可能有特殊的边界 &lt; legend&gt; 元素为 &lt; fieldset&gt; 元素定义标题。 123456789101112&lt;form action="action_page.php"&gt; &lt;fieldset&gt; &lt;legend&gt;Personal information:&lt;/legend&gt; First name:&lt;br&gt; &lt;input type="text" name="firstname" value="Mickey"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type="text" name="lastname" value="Mouse"&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" value="Submit"&gt; &lt;/fieldset&gt;&lt;/form&gt; 表单以何种格式提交数据给服务器以name和value的键值对形式进行提交 格式：action?name=value&amp;name=value&amp;name=value… 例如：https://www.baidu.com?username=abc&amp;pwd=111 超链接和表单都是向服务器发送请求，但是表单会同时携带数据进行提交。 超链接也可以进行数据提交： 1&lt;a href="https://www.baidu.com?username=zhang&amp;pwd=123"&gt;提交&lt;/a&gt; 注意：超链接提交的数据都是固定不变的（在代码里写死了），且超链接是get请求 用户注册表单的实现12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用户注册：用户名、姓名、密码、确认密码、性别、兴趣爱好、学历和简介 --&gt; &lt;form action="https://www.baidu.com"&gt; 用户名 &lt;input type="text" name="username"&gt;&lt;/input&gt;&lt;br&gt; 密码 &lt;input type="text" name="pwd"&gt;&lt;/input&gt;&lt;br&gt; 确认密码 &lt;!--（不需要提交，浏览器就能判断）--&gt; &lt;input type="text"&gt;&lt;/input&gt;&lt;br&gt; 性别 &lt;input type="radio" name="sex" value="male"&gt;男&lt;/input&gt; &lt;input type="radio" name="sex" value="female" &gt;女&lt;/input&gt;&lt;br&gt; 兴趣爱好 &lt;input type="checkbox" name="interest" value="football"&gt;足球&lt;/input&gt; &lt;input type="checkbox" name="interest" value="basketball"&gt;篮球&lt;/input&gt;&lt;br&gt; 学历 &lt;select name="grade"&gt; &lt;option value="gz"&gt;高中&lt;/option&gt; &lt;option value="bk"&gt;本科&lt;/option&gt; &lt;option value="sh"&gt;硕士&lt;/option&gt; &lt;/select&gt;&lt;br&gt; 简介 &lt;!--文本域没有value属性，用户填写的内容就是value--&gt; &lt;textarea name="message" rows="10" cols="60"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type="submit" value="注册"&gt;&lt;/input&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type="reset" value="清空"&gt;&lt;/input&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果如下：]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML超链接]]></title>
    <url>%2F2020%2F07%2F03%2FHTML%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。 当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。 我们通过使用 &lt; a &gt; 标签在 HTML 中创建链接。 有两种使用 &lt; a &gt; 标签的方式： 通过使用 href 属性 - 创建指向另一个文档的链接 通过使用 name 属性 - 创建文档内的书签 HTML 链接语法链接的 HTML 代码很简单。它类似这样： 12&lt;!--如果href=""，代表跳转至当前页面--&gt;&lt;a href="url"&gt;Link text&lt;/a&gt; href 属性规定链接的目标。 开始标签和结束标签之间的文字被作为超级链接来显示。 提示：“链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 例如： 以文本作为链接显示 1&lt;a href="https://www.baidu.com"&gt;百度&lt;/a&gt; 以图片作为链接显示 123&lt;a href="https://www.baidu.com"&gt; &lt;img src="图片url&gt;&lt;/a&gt; herf的属性值可取： 绝对 URL - 指向另一个站点，绝对路径（比如 href=”http://www.baidu.com&quot;） 相对 URL - 指向站点内的某个文件，相对路径（href=”index.html”） 锚 URL - 指向页面中的锚（href=”#top”） HTML 链接 - target 属性使用 Target 属性，你可以定义被链接的文档在何处显示。 可取值： _blank：新窗口 _self：当前窗口（默认） _top：顶级窗口 _parent：父窗口 HTML 链接 - name 属性name 属性规定锚（anchor）的名称。 您可以使用 name 属性创建 HTML 页面中的书签。 书签不会以任何特殊方式显示，它对读者是不可见的。 当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。即快速定位 命名锚的语法： 1&lt;a name="label"&gt;锚（显示在页面上的文本）&lt;/a&gt; 提示：锚的名称可以是任何你喜欢的名字。 提示：您可以使用 id 属性来替代 name 属性，命名锚同样有效。 实例： 首先，我们在 HTML 文档中对锚进行命名（创建一个书签）： 1&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt; 然后，我们在同一个文档中创建指向该锚的链接： 1&lt;a href="#tips"&gt;有用的提示&lt;/a&gt; 您也可以在其他页面中创建指向该锚的链接： 1&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt; 在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML图片img标签]]></title>
    <url>%2F2020%2F07%2F03%2FHTML%E5%9B%BE%E7%89%87img%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[图像标签（img）和源属性（Src）在 HTML 中，图像由 &lt; img &gt; 标签定义。 &lt; img &gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。 要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的url。 定义图像的语法是： 1&lt;img src="url"&gt; src既可以是绝对路径，也可以是相对路径 浏览器将图像显示在文档中图像标签出现的地方。如果你将图像标签置于两个段落之间，那么浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。 图像标签常用属性 宽度width和高度height 1&lt;img src="url" width="100px"&gt; 注意：设置图片宽度和高度的时候，只设置宽度，高度会进行等比例缩放。就不要再设置高度了，否则图片会湿失真 title属性：设置鼠标悬停时显示的信息 alt属性：在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。 1&lt;img src="url" alt="图片加载失败！"&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背景颜色和背景图片]]></title>
    <url>%2F2020%2F07%2F02%2F%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E5%92%8C%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[背景颜色背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB 值或颜色名。 123&lt;body bgcolor="#000000"&gt;&lt;body bgcolor="rgb(0,0,0)"&gt;&lt;body bgcolor="black"&gt; 以上的代码均将背景颜色设置为黑色。 背景图片背景属性将背景设置为图像。属性值为图像的URL。如果图像尺寸小于浏览器窗口，那么图像将在整个浏览器窗口进行复制。 12&lt;body background="clouds.gif"&gt;&lt;body background="http://www.w3school.com.cn/clouds.gif"&gt; 可以是相对路径，也可以是绝对路径 提示：如果你打算使用背景图片，你需要紧记一下几点： 背景图像是否增加了页面的加载时间。小贴士：图像文件不应超过 10k。 背景图像是否与页面中的其他图象搭配良好。 背景图像是否与页面中的文字颜色搭配良好。 图像在页面中平铺后，看上去还可以吗？ 对文字的注意力被背景图像喧宾夺主了吗？ 如果同时设置了背景颜色和背景图片，那么背景颜色就到背景图片下面了！ 上面不局限于body标签，在任何一个标签都可以使用！]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格]]></title>
    <url>%2F2020%2F07%2F02%2FHTML%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[如何画一个表格下面写一个两行三列的表格： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--table标签代表表格--&gt; &lt;!--tr标签代表一行，td标签代表一格--&gt; &lt;!--下面是一个两行三列的表格--&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;a&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;d&lt;/td&gt; &lt;td&gt;e&lt;/td&gt; &lt;td&gt;f&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： 但是我们发现没有表格线，如何添加表格线呢？ 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- border:表格边框宽度为1px width:宽度，有两种方式：1、直接写300px；2、百分比，代表占页面的宽度比 height:高度，只能用px align:对齐方式 --&gt; &lt;table align="center" border="1px" width="30%" height="150px"&gt; &lt;!--该行数据居中对齐--&gt; &lt;tr align="center"&gt; &lt;td&gt;a&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;d&lt;/td&gt; &lt;td&gt;e&lt;/td&gt; &lt;!--该格数据居中对齐--&gt; &lt;td align="center"&gt;f&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： 2、列合并 删除单元格（删除哪几个都行），最后保留一个就行。然后加入colspan属性 比如合并d和e，代码如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align="center" border="1px" width="30%" height="150px"&gt; &lt;tr&gt; &lt;td&gt;a&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;d&lt;/td&gt; &lt;td&gt;f&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： th标签th标签也是单元格标签，比td多的是居中和加粗 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align="center" border="1px" width="30%" height="150px"&gt; &lt;tr&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工薪资&lt;/th&gt; &lt;th&gt;部门名称&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;d&lt;/td&gt; &lt;td&gt;f&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下：]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML实体符号]]></title>
    <url>%2F2020%2F06%2F17%2FHTML%E5%AE%9E%E4%BD%93%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[HTML 中的预留字符必须被替换为字符实体，HTML实体符号包含数学符号、希腊字母、各种箭头、技术符号及各种形状 所有的实体符号以&amp;开始，以;结束 在 HTML 中，某些字符是预留的。 在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。 如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体有两种方式： 1234&lt;!--实体名称--&gt;&amp;entity_name;&lt;!--实体编号--&gt;&amp;#entity_number; 提示：使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。 下面举例几个实体符号： 大于号和小于号 如果不使用实体符号，而是直接使用&gt;或者&lt;，将会导致与HTML预留符号冲突，例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML实体符号&lt;/title&gt; &lt;/head&gt; &lt;body&gt; a&lt;b&gt;c &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 可以看到，这里只显示了ac，因为中间的部分被识别为了标签而被解析，所以没有显示出来 那么如果要让他们显示出来，就需要使用实体符号 如下所示： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML实体符号&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&amp;lt;表示小于号，&amp;gt;表示大于号--&gt; a&amp;lt;b&amp;gt;c &lt;/body&gt;&lt;/html&gt; 不间断空格（non-breaking space） HTML 中的常用字符实体是不间断空格 浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，需要使用实体符号，如下所示： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML实体符号&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&amp;nbsp;代表空格--&gt; &lt;!--下面代码代表加了6个空格--&gt; a&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c &lt;/body&gt;&lt;/html&gt; 其余的各种实体符号，只需要在需要使用的时候网上查阅即可！]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基本标签]]></title>
    <url>%2F2020%2F06%2F17%2FHTML%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[段落标签先看一下不加段落标签的样子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是第一段 这是第二段 这是第三段 &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 然后我们加上段落标签，方法为： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是第一段&lt;/p&gt; &lt;p&gt;这是第二段&lt;/p&gt; &lt;p&gt;这是第三段&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 标题字这是HTML预留的格式，和word中的标题字相同。有h1到h6这六种： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;h4&gt;标题&lt;/h4&gt; &lt;h5&gt;标题&lt;/h5&gt; &lt;h6&gt;标题&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 换行标记&lt; br &gt;标签 这种标签只有一个，叫做独目标记 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello&lt;br&gt;world! &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 水平线&lt; hr &gt;标签 也是一个独目标记 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello&lt;br&gt;world! &lt;hr&gt; &lt;!--颜色为红色，宽度占页面宽度的50%--&gt; &lt;!--color和width都是hr标签的属性--&gt; &lt;!--属性值可以加双引号、单引号甚至没引号，都可以！--&gt; &lt;hr color="red" width="50%"&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 预留格式我们先看一下下面这个例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; for(int i=0;i&lt;10;i++)&#123; System.out.println(i); &#125; &lt;/body&gt;&lt;/html&gt; 这个for循环肯定不能按照我们写的格式在浏览器上展现出来，最后发现上面的三行for循环最后出现在一行上！ 如何让它保持原样出现在浏览器上呢？使用&lt; pre &gt;&lt; /pre &gt;标签 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;pre&gt; for(int i=0;i&lt;10;i++)&#123; System.out.println(i); &#125; &lt;/pre&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 各种字体格式1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--删除字--&gt; &lt;del&gt;删除字&lt;/del&gt; &lt;!--插入字--&gt; &lt;ins&gt;插入字&lt;/ins&gt; &lt;!--粗体字--&gt; &lt;b&gt;粗体字&lt;/b&gt; &lt;!--斜体字--&gt; &lt;i&gt;斜体字&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 右上角/右下角加字12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--右上角--&gt; 10&lt;sup&gt;2&lt;/sup&gt; &lt;!--右下角--&gt; 10&lt;sub&gt;2&lt;/sub&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下： 字体标签1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--红色，大小为50--&gt; &lt;font color="red" size="50"&gt;字体标签&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 浏览器界面如下：]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML概述]]></title>
    <url>%2F2020%2F06%2F17%2FHTML%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是HTML？HTML：Hyper Text Markup Language（超文本标记语言） 由大量的标签组成，每一个标签都有开始标签和结束标签，一个标签里面可能有子标签，如下所示： 123456&lt;开始标签&gt; &lt;开始标签&gt; &lt;开始标签 属性名='属性值' 属性名='属性值'&gt; &lt;/结束标签&gt; &lt;/结束标签&gt; &lt;/结束标签&gt; 超文本：流媒体、图片、声音、视频等 怎么开发HTML？使用普通的文本编辑器就行，创建的文件扩展名是.html或者.htm 当然HTML也有专业的开发工具，例如DreamWeaver、HBuilder等 直接采用浏览器打开HTML就能运行 HTML是谁制定的？是由W3C（世界万维网联盟）制定的 W3C制定了HTML的规范，每个浏览器生产厂家都会遵守该规范 HTML程序员也会按照这个规范去写代码 W3C制定了很多规范：HTML/XML/http协议/https协议等 第一个HTML123456789101112131415161718192021&lt;!-- 这是HTML的注释 加上&lt;!doctype html&gt;就表示HTML5语法，去掉就表示HTML4.0 HTML不区分大小写，语法松散不严格--&gt;&lt;!doctype html&gt;&lt;html&gt; &lt;!--头--&gt; &lt;head&gt; &lt;!--告诉浏览器采用哪种字符编码方式解析此文件 注意：并不是设置当前文件的编码方式 --&gt; &lt;meta charset="UTF-8"&gt; &lt;!--网页的标题，显示在网页左上角--&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;!--体--&gt; &lt;body&gt; 网页的主体内容 &lt;/body&gt;&lt;/html&gt; 这就是HTML代码的大体框架！！！]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统结构]]></title>
    <url>%2F2020%2F06%2F17%2F%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[我们今后做开发，主要有以下两种系统结构： B/S架构 Browser/Server（浏览器/服务器端的交互形式） Browser支持哪些语言：HTML、CSS、JavaScript（写HTML、CSS、JavaScript代码的这些人就是通常所说的Web前端开发工程师，前端页面上的图片需要UI设计师完成） Server端的语言很多：C、C++、Java、Python等 B/S架构的优缺点： 优点：升级方便（因为只需要升级服务器端代码即可），维护成本低 缺点：速度慢（因为所有的东西都需要从服务器端传递到浏览器，这个传输数量是很大的，所以速度慢）、页面不炫酷 企业内部的解决方案都是采用B/S架构的系统 C/S架构 Client/Server（客户端/服务器端的交互形式） C/S架构的优缺点： 优点：速度快，体验好，界面炫酷 缺点：升级麻烦，维护成本较高 常见的C/S架构的系统：QQ、支付宝、游戏等]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架]]></title>
    <url>%2F2020%2F06%2F17%2FMyBatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[框架概述软件开发三层架构: 界面层（视图层）：和用户打交道，主要功能是接收用户的数据，显示请求的处理结果（jsp和html主要用于显示结果，servet主要用于收集用户数据） 业务逻辑层：接受了界面层传递过来的数据，计算逻辑，调用数据库，获取数据（Spring） 数据访问层（持久层）：访问数据库，执行数据的查询、修改、删除等等。（MyBatis） 三层架构的交互关系如下图所示： 即：用户使用界面层 —&gt; 业务逻辑层 —&gt; 数据访问层 —&gt; 数据库（mysql） 三层对应的包： 界面层：controller包（servlet） 业务逻辑层：service包（包含各种Service类） 数据访问层：dao包（包含各种Dao类） 三层对应的处理框架： 界面层：SpringMVC 业务逻辑层：Spring 数据访问层：MyBatis]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC工具类封装]]></title>
    <url>%2F2020%2F06%2F16%2FJDBC%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[我们前面学习JDBC六步，发现如果每次对数据库操作都要敲这些代码，实在太繁琐。能不能将其包装成一个工具类，来简化代码呢？答案是可以！ 下面我们来编写JDBC工具类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DBUtil &#123; /** * 注册驱动的代码应该放在静态代码块中 * 如果将其放在getConnection()方法中，当程序调用了两次该方法 * 就会注册两次驱动，然后这没有必要，只需要注册一次即可 * 所以将其放在静态代码块中 */ static&#123; try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 工具类的构造方法通常都是私有的，但不是必须的 * 因为工具类当中的方法都是静态的，不需要new对象，直接采用类名调用 * 私有化构造方法可以防止别人new工具类对象 */ private DBUtil()&#123;&#125; /** * 获取数据库连接对象 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; String url = "jdbc:mysql://localhost:3305/run?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; //数据库IP地址 String user = "root"; //用户名 String password = "123"; //密码 return DriverManager.getConnection(url,user,password); &#125; /** * 关闭资源 * @param conn 连接对象 * @param ps 数据库操作对象 * @param rs 查询结果集 */ public static void close(Connection conn, Statement ps, ResultSet rs)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(ps!=null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 下面我们利用上述的封装类完成一次模糊查询： 1234567891011121314151617181920212223242526272829public class JDBCTest &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //获取连接 conn = DBUtil.getConnection(); //获取预编译的数据库操作对象 String sql = "select ename from emp where ename like ?"; ps = conn.prepareStatement(sql); //执行sql，获取第二个字母是A的ename ps.setString(1,"_A%"); rs = ps.executeQuery(); //处理查询结果集 while(rs.next())&#123; String ename = rs.getString("ename"); System.out.println(ename); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 DBUtil.close(conn,ps,rs); &#125; &#125;&#125; 可以看到使用工具类后，代码非常简洁！！]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC事务机制]]></title>
    <url>%2F2020%2F06%2F16%2FJDBC%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JDBC事务机制 JDBC中的事务是自动提交的。只要执行任意一条DML语句，则自动提交一次，这就是JDBC默认的事务行为。但是在实际的业务当中，通常都是N条DML语句共同联合才能完成的，必须保证它们这些DML语句在同一个事务中同时成功或者同时失败 JDBC修改自动提交机制下面我们演示一下如何修改JDBC默认的事务自动提交机制： 以银行转账业务为例展示，首先新建一个银行账户表tbl_act： 1234create table tbl_act( actno int, balance double(7,2)); 然后插入相关的数据： 1234567891011mysql&gt; insert into tbl_act values(111,20000),(222,0);Query OK, 2 rows affectedmysql&gt; select * from tbl_act;+-------+---------+| actno | balance |+-------+---------+| 111 | 20000 || 222 | 0 |+-------+---------+2 rows in set 我们先来看一下JDBC中的默认自动提交机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Act &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); String url = "jdbc:mysql://localhost:3305/run?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); //下面两条update语句必须同时成功或同时失败 String sql = "update tbl_act set balance = ? where actno = ?"; ps = conn.prepareStatement(sql); ps.setDouble(1,10000); ps.setInt(2,111); int count = ps.executeUpdate(); //这里肯定会出现空指针异常，然后进入catch语句 //导致下面那条update语句无法被执行 String s = null; s.toString(); ps.setDouble(1,10000); ps.setInt(2,222); count += ps.executeUpdate(); System.out.println(count==2 ? "转账成功" : "转账失败"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(ps!=null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 上面特意在两条update语句中添加了一个空指针异常，从而导致进入catch子句，而下面那条update语句无法被执行。但此时我们再查看表tbl_act中的数据发现第一条update命令已经提交并且修改磁盘中的数据了： 12345678mysql&gt; select * from tbl_act;+-------+---------+| actno | balance |+-------+---------+| 111 | 10000 || 222 | 0 |+-------+---------+2 rows in set 钱少了1万！！！这是十分不安全的！！！ 因此可以验证JDBC中的事务是自动提交的，执行一条DML语句，就提交一条！！！ 修改默认的自动提交机制为手动提交机制 如何修改呢？ 在第二步获取连接的时候，将自动提交机制设置为手动提交 12conn = DriverManager.getConnection(url,user,password);conn.setAutoCommit(false); 在需要提交事务的地方添加提交语句 1conn.commit(); 当语句异常的时候需要事务回滚，所以在catch子句中添加回滚语句 1234567if(conn!=null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125;&#125; 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Act &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); String url = "jdbc:mysql://localhost:3305/run?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); //开启事务 conn.setAutoCommit(false); //下面两条update语句必须同时成功或同时失败 String sql = "update tbl_act set balance = ? where actno = ?"; ps = conn.prepareStatement(sql); ps.setDouble(1,10000); ps.setInt(2,111); int count = ps.executeUpdate(); ps.setDouble(1,10000); ps.setInt(2,222); count += ps.executeUpdate(); System.out.println(count==2 ? "转账成功" : "转账失败"); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; if(conn!=null) &#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;finally &#123; if(ps!=null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 至此，就解决了默认的事务自动提交机制可能存在的问题！！]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟用户登录功能(MySQL+JDBC)]]></title>
    <url>%2F2020%2F06%2F15%2F%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD-MySQL-JDBC%2F</url>
    <content type="text"><![CDATA[需求 模拟用户登录功能的实现 业务描述 程序运行的时候，提供一个输入的入口，可以让用户输入用户名和密码；用户输入用户名和密码之后，提交信息，java程序收集到用户信息，java程序连接数据库验证用户名和密码是否合法，如果合法显示登陆成功 首先我们先建一个表tbl_user： 123456create table tbl_user( id int auto_increment, loginName varchar(255), loginPwd varchar(255), primary key(id)); 然后插入几个数据： 12345678910mysql&gt; insert into tbl_user(loginName,loginPwd) values('zhangsan','123'),('lisi','123');mysql&gt; select * from tbl_user;+----+-----------+----------+| id | loginName | loginPwd |+----+-----------+----------+| 1 | zhangsan | 123 || 2 | lisi | 123 |+----+-----------+----------+2 rows in set 至此，数据已经准备完毕了！ 首先完成用户输入界面功能的代码： 12345678910111213private static Map&lt;String, String&gt; initUI() &#123; Scanner s = new Scanner(System.in); System.out.print("用户名："); String loginName = s.nextLine(); System.out.print("密码："); String loginPwd = s.nextLine(); Map&lt;String,String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put("loginName",loginName); userLoginInfo.put("loginPwd",loginPwd); return userLoginInfo;&#125; 然后完成用户名和密码验证是否合法功能的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //JDBC代码 Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获取连接 String url = "jdbc:mysql://localhost:3305/run?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); //获取数据库操作对象 stmt = conn.createStatement(); //执行sql语句 String loginName = userLoginInfo.get("loginName"); String loginPwd = userLoginInfo.get("loginPwd"); String sql = "select * from tbl_user where loginName = '"+loginName+"' and loginPwd = '"+loginPwd+"'"; rs = stmt.executeQuery(sql); //处理查询结果集 if(rs.next()) return true; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return false;&#125; 最后完成主程序： 1234567public static void main(String[] args) &#123; //初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); //验证用户名和密码 boolean flag = login(userLoginInfo); System.out.println(flag ? "登陆成功" : "登录失败");&#125; 至此，该功能就开发完毕了！！ 但是，在测试的时候会发现有一个问题，我们输入如下的用户名和密码： 12用户名：fasd密码：fasd' or '1' = '1; 很明显，我们的tbl_user表中是没有该记录的，本应该显示登录失败。但我们惊奇地发现居然提示登录成功，这是为什么呢？ 其实我们分析一下上述代码的sql语句： 1String sql = "select * from tbl_user where loginName = '"+loginName+"' and loginPwd = '"+loginPwd+"'"; 我们将上述代码拼接后发现sql语句实际长这样： 1select * from tbl_user where loginName = &apos;fasd&apos; and loginPwd = &apos;fasd&apos; or &apos;1&apos;=&apos;1&apos;; 由于and的优先级高于or，所以where后面的条件始终为true。因此就会显示登陆成功了，这种就叫做SQL注入！！ SQL注入的根本原因是什么？ 用户输入的信息中含有sql语句的关键字，并且这些关键字参与sql语句的编译过程，导致sql语句的原意被扭曲，进而达到sql注入！ 如何解决SQL注入问题呢？听我娓娓道来！ 只要用户提供的信息不参与sql语句的编译过程就可以解决SQL注入问题了！！ 因此不再使用java.sql.Statement了，而要使用java.sql.PreparedStatement！！ java.sql.PreparedStatement继承了java.sql.Statement，java.sql.PreparedStatement是属于预编译的数据库操作对象。它的原理是预先对sql语句的框架进行编译，然后再给sql语句传值 下面我们重写上面的login功能模块： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; //JDBC代码 Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获取连接 String url = "jdbc:mysql://localhost:3305/run?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; // String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); //获取数据库操作对象 //这里的?是占位符 //SQL语句的框子，一个?代表一个占位符，一个?将来接收一个值 //注意：占位符不能使用单引号括起来 String sql = "select * from tbl_user where loginName = ? and loginPwd = ?"; //程序执行到此处，会发送sql语句框子给DBMS，然后DBMS进行sql语句的预先编译 ps = conn.prepareStatement(sql); //执行sql语句 String loginName = userLoginInfo.get("loginName"); String loginPwd = userLoginInfo.get("loginPwd"); //给占位符?传值 //第一个参数代表占位符下标，从1开始，第二个参数是要传的值 ps.setString(1,loginName); ps.setString(2,loginPwd); //这里不要再传sql了，否则会再编译一次 rs = ps.executeQuery(); //处理查询结果集 if(rs.next()) return true; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(ps!=null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return false;&#125; 这样就解决了SQL注入的问题。因此我们以后要使用PreparedStatement这个类，而不要使用Statement这个类来创建数据库操作对象了！ Statement和PreparedStatement对比： Statement有SQL注入问题，PreparedStatement解决了SQL注入 Statement是编译一次执行一次，PreparedStatement是编译一次可执行n次，所以PreparedStatement效率更高一些 这是因为如果在DBMS中前后两次输入的sql语句完全一样，那么只需要第一次编译即可，第二次无需编译。由于Statement每一次都要拼接sql语句，因此每次运行传给DBMS的语句都不同，所以每一次都要编译。而PreparedStatement只传递一个sql语句框子，所以每一次都一样，只需要编译一次即可 PreparedStatement会在编译阶段做类型的安全检查（这里指的是在IDEA里面会有红色下滑线报错，而Statement却无法显示出来。因为setString()方法只能传递String字符串，传递别的当然会报错） PreparedStatement进行增删改： 增（只写一下sql语句怎么写，其余都是类似的） 1mysql&gt; String sql = &quot;insert into dept(deptno,dname,loc) values(?,?,?)&quot;; 改 1mysql&gt; String sql = &quot;update dept set dname = ?, loc = ? where deptno = ?&quot;; 删 1mysql&gt; String sql = &quot;delete from dept where dname = ?&quot;;]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册启动与获取连接]]></title>
    <url>%2F2020%2F06%2F12%2F%E6%B3%A8%E5%86%8C%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[注册驱动 当使用高版本的数据库，如MySQL8.0.12时，外部的驱动必须与其保持版本一致，即必须使用mysql-connector-java-8.0.12这个版本（这一点一定要注意，否则会报错） 对于旧版本，MySQL Connector 5.x 版本的连接方式为 Driver driver = new com.mysql.jdbc.Driver(); MySQL和MySQL-Connector都为8.0以上的版本时，连接驱动就不要再用：com.mysql.jdbc.Driver了，要引用com.mysql.cj.jdbc.Driver，即 Driver driver = new com.mysql.cj.jdbc.Driver(); 12345678910111213141516import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;public class Test &#123; public static void main(String[] args) &#123; try &#123; //注册驱动 //多态，父类型引用执行子类型对象 Driver driver = new com.mysql.jdbc.Driver(); DriverManager.registerDriver(driver); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取连接注意：对于高版本的MySQL（比如MySQL8.0.12）和高版本的Connector（比如mysql-connector-java-8.0.12），其获取url的方式如下所示： 1String url = "jdbc:mysql://localhost:3305/learn?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; url是统一资源定位符，网络中某个资源的绝对路径，比如https://www.baidu.com/就是一个url，其等价于http://182.61.200.7:80/index.html http://是通信协议 182.61.200.7是服务器IP地址 80是服务器上软件的端口 index.html是服务器上某个资源名 jdbc:mysql://是通信协议 localhost也能写成127.0.0.1（都是本机IP），代表MySQL服务器所在主机的IP地址 3305MySQL服务器的端口号（这里之所以不是默认的3306，是因为我电脑上有5.7和8.0两个MySQL版本，所以我修改了8.0版本的my.ini中的端口号） learn是要连接的具体的数据库的名称 后面的一堆是固定参数，加上即可 具体代码如下： 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; try &#123; //1、注册驱动 //多态，父类型引用执行子类型对象 Driver driver = new com.mysql.cj.jdbc.Driver(); DriverManager.registerDriver(driver); //2、获取连接 String url = "jdbc:mysql://localhost:3305/learn?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; //数据库url String user = "root"; //用户名 String password = "123"; //密码 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取数据库操作对象利用上面的获取的conn连接对象来创建数据库操作对象 12import java.sql.Statemet;Statement stmt = conn.createStatement(); 执行sql语句这里以DML语句（insert，delete和update）为例： 12345//JDBC中的sql语句不需要写分号String sql = "insert into dept values(50,'人事部','北京')";//专门执行DML语句（insert，delete、update）//返回值是int型，代表影响数据库中的记录条数int count = stmt.executeUpdate(sql); 完整JDBC六步代码下面附上完整的JDBC编程六步代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.sql.*;public class Test &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; //1、注册驱动 //多态，父类型引用执行子类型对象 Driver driver = new com.mysql.cj.jdbc.Driver(); DriverManager.registerDriver(driver); //2、获取连接 String url = "jdbc:mysql://localhost:3305/learn?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); System.out.println(conn); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql语句 String sql = "insert into dept values(50,'人事部','北京')"; //专门执行DML语句（insert，delete、update） //返回值是int型，代表影响数据库中的记录条数 int count = stmt.executeUpdate(sql); System.out.println(count==1 ? "保存成功" : "保存失败"); //5、处理查询结果集，只有执行SELECT语句才有这一步 //这里执行的是DML，所以没有这一步 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 //为了保证资源一定释放，在finally语句块中的关闭资源 //并且遵循从小到大依次关闭 //分别对其try catch if(stmt!=null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注册驱动的另一种方式上面那种方法不常用，很少用！这种方式很常用。 讲这种方式之前，我们先看一下MySQL驱动中com.java.cj.jdbc.Driver类的源代码： 可以看到，我们上述那种注册驱动的方式就内嵌于com.java.cj.jdbc.Driver类的静态代码块中，那么如何让该静态代码块执行呢？使用Class.forName()方法 1Class.forName("com.mysql.cj.jdbc.Driver"); 从属性配置文件获取连接数据库信息实际开发中不建议把连接数据库的信息写死到程序中，建议将其写在配置文件中 先建立一个properties配置文件，存储数据库连接信息： 12345//jdbc.propertiesdriver=com.mysql.cj.jdbc.Driver;url=jdbc:mysql://localhost:3305/learn?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true;user=rootpassword=123 然后再执行数据库连接 1234567ResourceBundle bundle = ResourceBundle.getBundle("jdbc");String driver = bundle.getString("driver");String url = bundle.getString("url");String user = bundle.getString("user");String password = bundle.getString("password");Class.forName(driver);Connection conn = DriverManager.getConnection(url,user,password); 处理查询结果集只针对select语句才有这一步，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Test &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //1、注册驱动 //多态，父类型引用执行子类型对象// Driver driver = new com.mysql.cj.jdbc.Driver();// DriverManager.registerDriver(driver); Class.forName("com.mysql.cj.jdbc.Driver"); //2、获取连接 String url = "jdbc:mysql://localhost:3305/learn?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"; String user = "root"; String password = "123"; conn = DriverManager.getConnection(url,user,password); System.out.println(conn); //3、获取数据库操作对象 stmt = conn.createStatement(); //4、执行sql语句 String sql = "select deptno,dname,loc from dept"; //专门执行查询语句 //int executeUpdate(insert,delete,update) //ResultSet executeQuery(select) rs = stmt.executeQuery(sql); //5、处理查询结果集，只有执行SELECT语句才有这一步 //next方法类似于集合中的迭代器，指向的行有数据返回true while(rs.next())&#123; //getString()方法的特点是：不管数据库中的数据类型是什么，都以String的形式取出 //这里的1指的是查询结果集每行的的列下标 //jdbc中下标从1开始 String deptno = rs.getString(1); String dname = rs.getString(2); String loc = rs.getString(3); System.out.println(deptno+","+dname+","+loc); &#125; &#125; catch (SQLException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; //6、释放资源 //为了保证资源一定释放，在finally语句块中的关闭资源 //并且遵循从小到大依次关闭 //分别对其try catch if(rs!=null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 有以下几点需要注意： 是由getString()方法不仅可以用查询结果集的列下标做参数，也可以直接以查询结果集的列名称做参数（注意这里是查询结果集中的列的名称，而不是表中的列的名称，因为可能会有列别名的存在），如下 123String deptno = rs.getString("deptno");String dname = rs.getString("dname");String loc = rs.getString("loc"); 当在查询的时候，用了列别名怎么办？既可以用列下表做参数，也可以用查询结果集的列别名做参数！ 123456789String sql = "select deptno as no, dname, loc from dept";rs = stmt.executeQuery(sql);while(rs.next())&#123; //这里如果使用表中的列名rs.getString("deptno")就会报错！要注意 String deptno = rs.getString("no"); String dname = rs.getString("dname"); String loc = rs.getString("loc"); System.out.println(deptno+","+dname+","+loc);&#125;]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java如何查找Class]]></title>
    <url>%2F2020%2F06%2F10%2FJava%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEClass%2F</url>
    <content type="text"><![CDATA[Java 命令如何查找 Class当我们执行java helloworld这样一条指令时，它会依次进行如下步骤： 启动Java虚拟机JVM 生成三个类加载器，分别是启动类加载器（BootstrapLoader）、扩展类加载器（ExtClassLoader）和应用类加载器（AppClassLoader） 随后根据这三个类加载器依次去对应的路径下搜索加载helloworld.class文件，顺序分别是启动类加载器 &gt; 扩展类加载器 &gt; 应用类加载器。如果一旦加载成功，就停止搜索 启动类加载器的搜索路径为：由sun.boot.class.path（系统属性）所指定的 扩展类加载器的搜索路径为：是由java.ext.dirs（系统属性）来决定的 用户类加载器的搜索路径为：由java.class.path指定 这就是双亲委派机制！！！ 上述三个类加载器的搜索路径如下所示： Bootstrap classes 它们是构成 java 平台的类，比如位于JDK/jre/lib/中的 rt.jar 和 其他一些重要的 jar 文件 Extension classes 位于 JDK/jre/lib/ext 目录下的 jar 文件 User classes 由开发者和第三方定义的 class 文件。通过 -classpath 命令行选项或者 CLASSPATH 环境变量指定位置 用户一般只需指定 user classes 的位置，Bootstrap classes 和 Extension classes 会被自动处理。 将user classes path 存储在 java.class.path 系统属性中，该系统属性的值按以下顺序决定： 默认值，当前文件夹下的所有 class 文件。 CLASSPATH 环境变量中指定的值，覆盖上一设置。 命令行选项 -classpath，-cp 指定的值，覆盖上一设置。 如果通过 -jar 指定的 jar 文件中包含有指定了 Class­-Path 的 manifest 文件，所有 user class 文件都必须来自于指定的归档文件中，覆盖上一设置 从上到下依次覆盖，如果指定了CLASSPATH，便会覆盖默认路径；如果在java命令行里指定了-cp参数，便会覆盖系统设置的CLASSPATH，以此类推！！ 如果执行一个class文件java test，该文件内部使用了别的类（比如java.util.Date），那么在执行到该处的时候，会依次使用三个类加载器去加载java.util.Date，这里会首先被启动类加载器在rt.jar中找到，所以后面两个加载器其实此时便使用不到！！但是如果使用了自定义的类，那么前两个加载器都会找不到，此时便会被应用类加载器加载到！！！这种加载类的顺序一定要掌握！！！这种加载机制叫做双亲委派机制！！ javac 命令如何查找 Classesjavac 会在以下两方面使用到 class 文件： 用于支持自身的运行，比如tools.jar。 用于解析源代码中的引用。（被引用的类可以是 class 文件的形式或者源代码文件的形式） 如果想要编译某个java源文件，需要cd到该文件所在的目录，然后执行javac 源文件（注意这里和java命令的区别，执行java命令时是由三个类加载器依次去指定路径加载需要的class文件）。但是如果待编译的java源文件中还使用了别的类，那么就需要去指定的路径查找该类了，指定的路径见下文！！ 在编译下面的Test类时，需要先查找到TestInterface接口类，获取TestInterface接口信息 Test类代码 12345678910package main.java;import main.java.ITest;public class Test implements TestInterface&#123; public void say()&#123; System.out.println("hello world!"); &#125; public static void main()&#123; new Test().say(); &#125;&#125; TestInterface接口代码 1234package main.java;public interface ITest&#123; public void say();&#125; 在查找TestInterface的过程中有如下几种情况： 如果只找到了TestInterface.java，则编译之，并使用编译生成的TestInterface.class文件 如果只找到了TestInterface.class，则直接使用之 如果既找到了TestInterface.java又找到了TestInterface.class，则javac会比较.java文件和.class文件的时间戳，如果.java文件版本更高，则编译.java文件并使用生成的.class文件。 那么问题来了，编译器该怎么去找这些class文件或者java源文件呢？ （！！！重中之重！！！） 介绍这个内容之前，我们先讲一下java的import机制！ java中有两种包的导入机制，分别为： 单类型导入（single-type-import），例如import java.io.File; 按需类型导入（type-import-on-demand），例如import java.io.*; 单类型导入比较好理解，仅仅是导入一个public类或接口 按需类型导入( import java.io.*; )，有人误解为导入一个包下的所有类，其实不然，看名字就知道，他只会按需导入，也就是说它并非导入整个包，而仅仅导入当前类需要使用的类。 既然如此是不是就可以放心的使用按需类型导入呢？非也，非也。因为单类型导入和按需类型导入对类文件的定位算法是不一样的 我们先了解以下java编译器对类文件的定位方法： java编译器会从启动目录(bootstrap)，扩展目录(extension)和用户类路径下去定位需要导入的类，而这些目录进仅仅是给出了类的顶层目录。编译器的类文件定位方法大致可以理解为如下公式：顶层路径名 \ 包名 \ 文件名.class = 绝对路径 下面我们就来具体说一下java编译器在编译时查找类的具体流程： 比如存在这样一个Test.java源文件 12345678910package com;import java.io.*;import java.util.*;import java.auto.Single;public class Test&#123; public static void main(String[] args)&#123; Single s = new Single(); &#125;&#125; 该源文件中使用了Single类，编译器查找该类的具体流程如下： 如果在编译单元（比如这里的Test.java）的顶部没有包声明，Java编译器首选会从无名包（顶部没有package语句）中搜索一个类型。找到就停止搜索，否则跳到下一步继续搜索（因为这里的Test.java顶部有package，所以不需要经历这一步，只有无包编译单元才会经历这一步） 如果存在单类型导入的话，会经历这一步，没有单类型导入则直接跳到下一步。如上面的Test.java，编译器将在三个部分中试图查找java.auto.Single：启动目录(bootstrap)，扩展目录(extension)和用户类路径。且先查找用户类路径，再查找启动目录和扩展目录。同样的，如果找到就停止搜索，否则继续跳到下一步搜索 如果到达这一步，在Test.java的·当前目录下（同包下）查找Single，对于这个例子，由于Test.java在com包下，需要在用户类路径中搜索com.Single。果找到就停止搜索，否则继续跳到下一步搜索。注意：如果有两个模块module1（Test.java在module1中）和module2，且它们存在依赖关系（等同于都添加到了CLASSPATH），那么不仅会查找module1下的com.Single，也会查找module2下的com.Single，这一点一定要注意！！ 如果到达这一步，编译器将在三个部分中试图查找java.lang.Single（因为自动导入了java.lang包，默认按需导入方式）：启动目录(bootstrap)，扩展目录(extension)和用户类路径。且先查找用户类路径，再查找启动目录和扩展目录。同样的，如果找到就停止搜索，否则继续跳到下一步搜索 如果到达这一步，编译器将在三个部分试图查找java.io.Single和java.util.Single。需要注意的地方就是，编译器如果找到java.io.Single类之后并不会停止下一步的寻找，而要把所有的可能性都查找完以确定是否有类导入冲突。如果在查找完成后，编译器发现了两个同名的类，那么就会报错。要删除你不用的那个类，然后再编译。如果没找到该类也会报错。当且仅当只找到一个该类时才会正常编译]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC概述]]></title>
    <url>%2F2020%2F06%2F09%2FJDBC%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[JDBC是什么 Java DataBase Connectivity（Java语言连接数据库） JDBC本质是SUN公司制定的一套接口（interface） 在java.sql.*中（这个软件包下有很多接口） 任何一个接口都有调用者和实现者，面向接口调用和面向接口写实现类，都属于面向接口编程 为什么SUN制定一套JDBC接口？ 因为每一个数据库的底层实现原理都不一样，Oracle、MySQL等DBMS的底层原理都不同。如果没有这套接口，那么在连接不同的DBMS时需要写不同的java代码，很繁琐。 接口的实现类由各大DBMS厂商（Oracle、MySQL等）面向JDBC接口完成，而我们Java程序员（调用者，各大厂商是实现者）只需要面向JDBC接口调用即可，不用我们来写实现类 各大厂商的JDBC接口实现类需要去对应的官网下载，这些实现类称之为驱动（MySQL驱动、Oracle驱动等）。 所有的数据库驱动都是以jar包的形式存在，jar包当中有很多class文件，这些class文件就是对JDBC接口的实现。驱动不是SUN公司提供的，是各大DBMS厂商负责提供 配置驱动先从官网下载对应版本的驱动！！然后将其配置到环境变量classpath当中（这个是针对采用文本编辑器开发的方式，使用IDEA工具的时候，不需要配置以上的环境变量。IDEA有自己的配置方式） 如果使用IntelliJ IDEA，就不需要配置环境变量classpath了，直接将其添加到project structure —&gt; module —&gt; 模块依赖包中！！如下图所示： JDBC编程六步 注册驱动：告诉JVM即将要连接的是哪个品牌的数据库 获取连接：表示JVM的进程和数据库的进程之间的通道打开了，这属于进程之间的通信，使用完之后一定要关闭通道 获取数据库操作对象：获取执行sql语句的对象 执行sql语句：主要执行DQL和DML 处理查询结果集：只有当第四步执行的是select语句的时候，才有这一步 释放资源：使用完资源之后一定要关闭资源，Java和数据库属于进程间的通信，开启之后一定要关闭]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2020%2F06%2F07%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解注解Annotation是一种引用数据类型，编译后生成xxx.class文件 定义注解123[修饰符列表] @interface 注解类型名&#123; &#125; 注解怎么使用 注解使用时的语法格式 1@注解类型名 注解可以出现在类上、属性上、方法上、局部变量上等。注解还可以出现在注解类型上，这种用来标注“注解类型”的注解叫做元注解，常见的元注解有Target和Retention，这两个元注解都是java自带的 Target注解：是一个元注解，用来被标注“被标注的注解”可以出现在哪些位置上，例如 @Target(ElementType.Method)：表示“被标注的注解”只能出现在方法上 如果希望只能标注类和方法，可以这么写 @Target({ElementType.Type, ElementType.Method}) Retention注解：是一个元注解，用来标注“被标注的注解”最终保存在哪里，例如： @Retention(RetentionPolicy.SOURCE)：表示“被标注的注解”只能保留在java源文件里，给编译器看的，编译后的class文件里就没有这个注解了 @Retention(RetentionPolicy.CLASS)：表示“被标注的注解”被保留在class文件里 @Retention(RetentionPolicy.RUNTIME)：表示“被标注的注解”被保留在class文件里，并且可以被反射机制所读取 在哪里可以使用注解呢？个人理解：凡是可以导入import该注解的地方，都可以使用注解（java提供的注解和自定义注解） JDK内置的注解 放在java.lang包中 JDK自带了三个注解： Deprecated：向他人传达一个信息，告知标注的元素已过时，有更好的解决方法。源代码为 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 该注解被保存在字节码文件中，并且能被反射机制读取到 Override：表示这个方法是重写父类的一个方法，如果该方法不是重写父类的方法，就会报错。这个注解只能注解方法（因为它被Target元注解所标注，所以只能注解方法），是给编译器参考的，与运行期无关，凡是java中的方法带有这个注解的，编译器都会检查，如果这个方法不是重写父类的方法，编译器报错 SuppressWarnings 注解中定义属性1234567891011121314151617181920212223242526//AnnotationTest.java//自定义注解public @interface AnnotationTest &#123; /** * 通常在注解当中可以定义属性，以下这个是AnnotationTest的name属性 * 看着像一个方法，但实际上称之为属性name * @return */ String name(); /** * color属性 * @return */ String color(); //age属性制定了默认值 int age() default 20;&#125;//test.javapublic class test &#123; //如果一个注解中有属性，必须给属性赋值 //如果属性指定了默认值，可赋值也可以不赋值采用默认值 @AnnotationTest(name = "wang", color = "red") public void doSome()&#123;&#125;&#125; 如果一个注解的属性的名字是value，且只有一个属性的时候，那么使用该注解可以省略名字。如果有多个属性就不能省略了 123456789101112//AnnotationTest.java//自定义注解public @interface AnnotationTest &#123; String value();&#125;//test.javapublic class test &#123; //如果有多个属性，就不能省略value的名字了 @AnnotationTest("wang") public void doSome()&#123;&#125;&#125; 注解中属性可以是哪些类型？ byte、short、int、long、float、double、boolean、char String、Class、枚举类型 以及以上每一种类型的数组 看下当注解中的属性是数组的例子 12345678910111213141516//AnnotationTest.javapublic @interface AnnotationTest &#123; int age(); String[] name();&#125;//Test.javapublic class test &#123; //数组是大括号 @AnnotationTest(age = 20, name = &#123;"zhang","li"&#125;) public void doSome()&#123;&#125; //如果数组中只有1个元素，大括号可以省略 @AnnotationTest(age = 20, name = "zhang") public void doOther()&#123;&#125;&#125; 反射注解注意：如果这个注解能被反射，那么它一定是被Retention注标注的，且为@Retention(RetentionPolicy.RUNTIME) 下面先介绍一下如何反射类上面的注解： 123456789101112131415161718192021222324252627282930//Annotation.java@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationTest &#123; int age(); int value();&#125;//anno.java@AnnotationTest(age = 10,value = 20)public class anno&#123;&#125;//test.javapublic class test &#123; public static void main(String[] args) throws Exception&#123; //获取这个类 Class c= Class.forName("auto.anno"); //判断anno类上面是否有@Annotation //如果Annotation没有@Retention(RetentionPolicy.RUNTIME)将返回false，因为无法被反射 System.out.println(c.isAnnotationPresent(AnnotationTest.class)); if(c.isAnnotationPresent(AnnotationTest.class))&#123; //获取注解对象 AnnotationTest a = (AnnotationTest) c.getAnnotation(AnnotationTest.class); //获取注解对象的属性值 System.out.println(a.age()); System.out.println(a.value()); &#125; &#125;&#125; 那么怎么反射方法、属性上面的注解呢？ 12345678910111213141516171819//test.javapublic class test &#123; public static void main(String[] args) throws Exception&#123; Class c= Class.forName("auto.anno"); Method method = c.getDeclaredMethod("doSome"); if(method.isAnnotationPresent(AnnotationTest.class))&#123; AnnotationTest a = method.getAnnotation(AnnotationTest.class); System.out.println(a.value()); System.out.println(a.age()); &#125; &#125;&#125;//anno.javapublic class anno&#123; @AnnotationTest(age = 100,value = 200) public void doSome()&#123;&#125;&#125; 注解有什么用注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。 1、提供信息给编译器： 编译器可以利用注解来探测错误和警告信息。比如 @Override提示子类要复写父类中被修饰的方法。否则会报错 2、运行时的处理： 某些注解可以在程序运行的时候接受代码的提取 注解主要针对的是编译器和其它工具软件 当开发者使用了自定义注解修饰了类、方法、Field 等成员之后，这些 注解不会自己生效，必须由开发者提供相应的代码来提取并处理 注解信息。这些处理提取和处理 注解的代码统称为 APT（Annotation Processing Tool)。 有些自带的注解比如Override，编译器会自动识别它是否被重写（其实是编译器里面写了APT，用来判断的，这部分工作是由编译器完成的，不需要我们再做） 现在，我们可以给自己答案了，注解有什么用？给谁用？给编译器或者 APT用的 举个例子： 我要写一个测试框架，测试程序员的代码有无明显的异常。 —— 程序员 A : 我写了一个类，它的名字叫做 NoBug，因为它所有的方法都没有错误。—— 我：自信是好事，不过为了防止意外，让我测试一下如何？—— 程序员 A: 怎么测试？—— 我：把你写的代码的方法都加上 @Jiecha 这个注解就好了。—— 程序员 A: 好的 然后我们写一个测试类来对NoBug中的每一个被@Jiecha标注的方法进行反射调用，来分别看是否有bug]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA中各种文件夹的标记]]></title>
    <url>%2F2020%2F06%2F05%2FIntelliJ-IDEA%E4%B8%AD%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在刚使用idea开发时大家会碰到同样都是文件夹，但是颜色标志都有些不一样，不同的颜色标志代表着文件夹有不同的用途。如下图： 下面介绍一下这些文件夹的区别与用途: source root（source folder） 放在模块下面的一个目录 存放java源代码的文件夹，当然也包括一些package文件夹，还可以包含其他文件。项目构建后，source folder里面的java文件自动编译成class文件放到相应的“/out/production/模块名/“文件夹中，其他文件也会拷贝一份到”/out/production/模块/“相应的目录下，这个“/out/production/模块名/“就是当前classpath根目录 例如：一个project有ja1、ja2和ja3这三个模块，在ja1下面有一个src文件夹，该文件夹的类型是source folder。该文件夹下都是java源代码，如果存在一个包com，包里有一个test.java。那么经过编译后，test.class文件的路径为project\out\production\ja1\test.class。 test source root（test source folder） 与source root平级 这个类型的文件夹也用来放置源码，不过是测试的源码（比如单元测）。test source文件夹可以帮助你将测试代码和产品代码分离开。 该目录下的java源代码经过编译后生成的class文件会放在“/out/test/模块名/“文件夹中，其他文件也会拷贝一份到”/out/test/模块/“相应的目录下，这个“/out/test/模块名/“就是当前classpath根目录 这里需要注意一点：test source root下面的java源文件可以导入（import）并使用source folder下面的类；但是source root下面的java源文件不能导入（import）并使用test source folder下面的类。其实也很好理解，test source folder是用来测试的，当然可以使用源代码的类；但是该测试代码与业务无关，所以不能使用test source folder下面的类也没有什么影响 resource folder 放在模块下面，与source folder、test source folder平级 该类文件夹用于存放你的应用中需要用到的资源文件（如：图片、xml或者properties配置文件等）。 在构建过程中，resource文件夹中的内容（文件和文件夹）均会按照原文件的样子被复制到“/out/production/模块名/“文件夹。和source文件夹一样，你可以定制你的resource文件夹的结构。 PS：默认情况下，工程编译后，resource中的文件和文件夹会被放置在源码编译后的相同的文件夹（即”/out/production/模块名/“）中 test resource folder 用于存放测试源码中关联的资源文件。除此之外，和resource没有区别。 注意：默认情况下，在构建过程中，test resource文件夹中的内容（文件和文件夹）均会按照原文件的样子被复制到“/out/test/模块名/“文件夹。 注意：上述四种文件夹如果被标记为普通文件夹，那么在项目构建过程中，生成的class文件和其它文件将不会被添加到out文件夹中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载那些事儿]]></title>
    <url>%2F2020%2F06%2F04%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[什么是类的加载Java虚拟机把描述类的数据从Class字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制，这一过程是在程序运行期完成的 程序编译期：是指把源代码交给编译器译成计算机可以执行的代码，在Java中就是把Java代码编译为class文件的过程。程序运行期：是指把编译后的文件交给计算机执行，直到程序结束。在Java中就是把class文件加载到内存中，并到程序结束为止。类的加载就是发生在运行期，是运行期的开始 类加载机制一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个阶段统称为连接，如下图： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段 加载这一阶段由类加载器完成，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载 类加载器查找并加载类的字节码二进制文件 加载是类加载过程的第一个阶段，在加载阶段，类加载器需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在堆中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 什么时候会发生这一阶段呢？ 类加载器不需要等到某个类被首次主动使用时才加载它，JVM规范允许类加载器在预料某个类要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 通常有下面几种来源加载类的二进制数据，包括但不限于： 从本地文件系统加载class文件 从jar包中加载class文件，如从F盘动态加载jdbc的mysql驱动。 通过网络加载（典型应用Applet） 把一个java源文件动态编译并加载 从zip包读取，如jar，war，ear。 运算时计算生成（动态代理技术） 数据库中读取（可以加密处理） 其他文件生成（jsp文件生成对应的class文件） 验证确保被加载的类的正确性，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段对于虚拟机的类加载机制来说，是一个*非常重要、但不是必须执行的阶段。如果代码经过了反复验证，可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间 准备为类中定义的静态变量（不包括实例变量，实例变量将会在对象实例化 的时候随着对象一起分配在Java堆中）分配内存空间并设置为类型默认初始值（零值）。JDK8之后，静态变量会随着Class对象一起存放在Java堆中 这里需要注意：如果该静态变量有final关键字修饰（即静态常量），那么在准备阶段变量值就会被初始化为所指定的初始值，而不是默认零值！！！ 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化初始化阶段时类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户可以通过自定义类加载器的方式局部参与以外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中辨析的Java程序代码，将主导权移交给应用程序 初始化阶段就是执行类构造器&lt; clinit &gt;()方法的过程。&lt; clinit &gt;()并不是程序员在Java代码中直接编写的代码，它是Javac编译器的自动生成物。&lt; clinit &gt;()方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的（静态变量的声明操作不会被收集）。编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块只能访问到定义在静态语句块之前的静态变量。定义在它之后的静态变量只能赋值，但不能访问。所以最好把静态变量写在静态代码块前面。 虚拟机保证&lt; clinit &gt;()执行前，父类的&lt; clinit &gt;()已经执行完毕，所以说父类如果定义静态代码块的话，一定比子类先执行，当然了，如果一个类或接口中没有静态变量的赋值操作和静态代码块，那么&lt; clinit &gt;()也不会被JVM生成。最后还要注意一点，静态变量的赋值操作和静态代码块合并的顺序是由语句在源文件中出现的顺序所决定的。 类初始化的时机 当Java程序首次主动通过下面6种方式使用某个类或接口时，系统就会初始化该类或接口。假如这个类还没有被 加载和连接，则程序先加载并连接该类。类的初始化只会发生一次： 实例化对象：（1）new（2）反射newInstance 调用类的静态方法 访问类的静态变量，或为静态变量赋值（特例：如果是 static final类型的则会在准备阶段 就给赋值并加入常量池。所以仅仅访问某个类的常量并不会导致该类初始化） 使用java.lang.reflect包的方法对类进行反射调用、使用Class.forName()方法 初始化某个类的子类，子类的所有父类都被初始化 当虚拟机启动时，用户需要指定要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 以下情况不会执行类初始化： 通过子类去访问父类的静态字段，只会触发父类的初始化，不会触发子类的初始化 定义对象数组，不会触发该类的初始化 通过类名获取Class对象，不会触发类的初始化。如Person.class 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化 关于JDK终自带的类加载器JDK中自带了3个类加载器 启动类加载器 扩展类加载器 应用类加载器 代码在开始执行之前，会将所需要的类全部加载到JVM当中，通过类加载器加载。那么是怎么加载的呢？ 首先通过启动类加载器加载，注意启动类加载器专门加载Java\JDK1.8\jre\lib下的class文件，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、charsets.jar，名字不符合类库即使放在lib目录中也不会被加载） 如果通过启动类加载器加载不到的话，会通过扩展类加载器加载。注意：扩展类加载器专门加载Java\JDK1.8\jre\lib\ext目录下的class文件 如果扩展类加载器没有加载到，那么会通过应用类加载器加载。注意：应用类加载器专门加载：classpath中的字节码文件 java中为了保证类加载的安全，使用了双亲委派机制：优先从启动类加载器（称为父）加载；父无法加载到，再从扩展类加载器（称为母）加载；如果都加载不到，才考虑从应用类加载器加载，直至加载到为止]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[反射机制作用通过java语言中的反射机制可以操作字节码文件，可以读取和修改字节码文件 反射机制的相关类在：java.lang.reflect.* 反射机制相关的重要的类： java.lang.Class：代表整个字节码文件，代表一个类型 java.lang.reflect.Field：代表字节码中的属性（静态变量+实例变量）字节码 java.lang.reflect.Method：代表字节码中的方法字节码 java.lang.reflect.Constructor：代表字节码中的构造方法字节码 获取Class的三种方式在java世界里，一切皆对象。从某种意义上来说，java有两种对象：实例对象和Class对象。每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象，基本类型 (boolean, byte, char, short, int, long, float, and double)有Class对象，数组有Class对象，就连关键字void也有Class对象（void.class）。Class对象对应着java.lang.Class类 Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 要操作一个类的字节码，需要首先获取到这个类的字节码 第一种：Class.forName() java.lang.Class类的静态方法 方法的参数是一个字符串 字符串需要的是一个完整类名，什么样的类可以作为参数呢？（个人理解：凡是能在本文件中导入的类都可以被当做forName方法的参数以加载，别的模块加依赖关系也能导入！！） 完整类名必须带有包名 12345678910public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; //c代表String.class Class c = Class.forName("java.lang.String"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第二种：getClass() java中任何一个对象都有一个getClass()方法 1234567public class ReflectTest &#123; public static void main(String[] args) &#123; String s = "abc"; //x代表String.class Class x = s.getClass(); &#125;&#125; 注意：字节码文件装载到JVM中的时候，只装载一份，装载到JVM方法区中，然后会在JVM堆中生成一个Class对象，一个类只会加载一次，只会生成一个Class对象。所以上面的c和x的内存地址是一样的，都指向同一个Class对象 第三种：.class属性 java语言中任何一种类型，包括基本数据类型，都有.class属性 1234567public class ReflectTest &#123; public static void main(String[] args) &#123; Class c1 = String.class; Class c2 = int.class; Class c3 = Date.class; &#125;&#125; 通过反射实例化对象1234567891011121314151617181920212223class User&#123;&#125;public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; //通过反射机制，获取Class，通过Class实例化对象 Class c = Class.forName("com.bit.reflect.User"); //JDK9之后就没这个方法了 //newInstance会调用该类的无参构造方法 //如果没有无参构造方法，会出现异常 //所以建议自己写出类的无参构造方法 Object o = c.newInstance(); System.out.println(o); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这种方式和直接用该类创建对象：User u = new User()有什么区别呢？反射机制实例化对象比较灵活 1234567891011121314151617181920212223242526//classinfo.Properties配置文件classname=com.bit.reflect.User//ReflectTest.javapublic class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //这种方式代码就写死了 //User u = new User(); //以下代码是灵活的，代码不需要改动，可以修改配置文件，配置文件修改之后，可以创建出不同的实例对象 //通过IO流读取classinfo.Properties配置文件 FileInputStream in = new FileInputStream("classinfo.Properties"); //创建属性类对象Map Properties pro = new Properties(); //加载配置文件 pro.load(in); //关闭流 in.close(); //通过key获取value String classname = pro.getProperty("classname"); //通过反射机制实例化对象 Class c = Class.forName(classname); Object o = c.newInstance(); System.out.println(o); &#125;&#125; 上述利用反射机制实例化对象，具有灵活性，java代码写一遍，在不改变java源代码的基础之上，可以做到不同对象的实例化，只需修改配置文件即可（符合OCP开闭原则：对扩展开放，对修改关闭） forName方法forName()方法会触发类加载机制中的初始化，所以如果只想让一个类中的静态代码块执行，其余代码一律不执行，可以这么写代码： 12345678910111213141516class User&#123; static &#123; System.out.println("User的静态代码块执行了！"); &#125;&#125;public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; //Class.forName()这个方法的执行会导致：类加载 Class.forName("com.bit.reflect.User"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取类路径下的文件绝对路径举个例子 1FileInputStream in = new FileInputStream("test.txt"); 这里使用的是文件的相对路径，在IDEA中默认的当前路径是project的根目录。这个代码假设离开了IDEA，换到了其它位置，可能当前路径就不是project的根目录了，这时这个路径就无效了 那有人就要说，那我直接去硬盘里面获取绝对路径再写上去不可以么？你难道只用windows么？你这个项目放到Linux下就不能用了（Linux下面是没有盘符的概念的）！！所以这种直接写绝对路径的方式不灵活，移植性差 接下来说一种比较通用的路径：其实代码换位置了，仍旧可以使用 使用上述通用方式的前提：这个文件必须在三种类加载器能加载到的地方，即Bootstrap classes、Extension classes和User classes path（用户自定义类生成的class文件所在的路径）。 IntelliJ IDEA中每一个模块都有一个src目录（这是一个source folder），里面是源代码和一些文件；编译之后会自动生成一个out目录，里面有一个production目录，下面会存储着各个模块的编译后的class字节码文件以及src下的其它类型文件（如.txt、.properties等）。如果有一个test模块有src下有一个a.java源文件，那么该文件生成的a.class字节码文件所在的classpath的根目录就是”…/out/production/test/“。如果该模块中存在一个test source folder，该类型文件夹下的java文件编译生成的字节码文件所在的classpath 的根目录就是“…/out/test/模块名/“。resource folder和test resource folder下面的的内容（文件和文件夹）会分别被放在source和test source对应的classpath根目录中 可以这么认为：在IDEA里面，每个模块的src下的java源文件经过编译之后生成的class字节码文件都会放在…/out/production/下面对应的各个模块里面，但是该源代码文件不会放在该目录下；每个模块的src下的其它文件也会被拷贝一份自动放在…/out/production/下面对应的各个模块里面 那么如何获取这些文件的绝对路径呢？ 下面举个例子： 获取当前ClassPath根目录下的某个指定文件的绝对路径（不递归子目录，只查找此根目录） 注意：getResource()里面的参数是相对于当前classpath根目录的相对路径（这一点很关键） 12String path = Thread.currentThread().getContextClassLoader() .getResource("info.properties").getPath(); 这里的info.properties存储在当前模块的src路径下，编译后会被自动放在“out/production/模块名/“目录下面。 注意：如果存在多个模块，这个方式也可以获取其它模块classpath下的文件绝对路径，但是需要添加其他模块与当前模块的依赖关系，其实个人认为这个加依赖关系就是设置系统变量里面的CLASSPATH这个变量，功能是一样的！！ 如果存在这样一个文件：…/src/com/bit/auto/info1.properties，该怎么获取它的绝对路径？方法同上！ 12String path = Thread.currentThread().getContextClassLoader() .getResource("com/bit/auto/info.properties").getPath(); 注意：所有的java源代码经IDEA编译后生成的class文件会放在out/production中对应的模块下面。由于上述的方法是获取classpath目录下的文件的绝对路径，因此可以获取放在src下的java文件编译后的字节码文件和其它文件的绝对路径（因为它们编译后会放在out目录下对应的classpath中），而不能获取java源文件的绝对路径，因为它没有存放在out目录下的classpath中，而是存放在src目录下，所以不能获取 有了上述这种方式，我们就可以采用更先进的方式读取配置文件了： 12345String path = Thread.currentThread().getContextClassLoader() .getResource("info.properties").getPath();FileInputStream in = new FileInputStream(path);Properties pro = new Properties();pro.load(in); 也可以更先进：以流的形式直接返回 12345//直接以流的形式返回，不用接触绝对路径InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream("info.properties");Properties pro = new Properties();pro.load(in); java还提供了一个更牛逼的方式：java.util包下提供了一个资源绑定器，便于获取属性配置文件（properties）文件中的内容。使用这种方式，只能绑定xxx.properties文件，并且这个文件必须在类路径下 12345//不要加后缀名ResourceBundle bundle = ResourceBundle.getBundle("info");//通过key获取valueString value = bundle.getString("classname");System.out.println(value); 这样就可以直接取代IO流+properties这种方式读取配置文件 上面的Thread.currentThread().getContextClassLoader().getResource()获取的是当前文件生成的class文件所在的classpath根目录下的指定文件的绝对路径！！！有点绕？？？这里解释一下：如果有三个模块，ja1、ja2和ja3，这个代码在ja1中的src目录下，那么该行代码获取的就是以out/production/ja1/为根目录下的某个指定文件的绝对路径 那么对于test resource folder呢？在该文件夹下的某个文件中如果有该行代码，那么获取的就是以out/test/ja1/为根目录下的某个指定文件的绝对路径 注意：如果在src下的某个文件中执行该行代码，只能获取src目录下的java文件生成class文件、其它文件和resource folder目录下的文件的绝对路径，因为classpath根目录是out/production/模块名/。而不能获取test source root下文件的字节码和test resource root下文件的绝对路径，因为这些文件没有放在上述的classpath根目录中 同理，test source root下的某个文件有该行代码，只能获取test source root下文件的字节码和test resource root下其它文件的绝对路径；而不能获取src目录下的java文件生成class文件、其它文件和resource folder目录下的文件的绝对路径，因为它们的classpath 的根目录不一样！！！ 反射获取Field通过class文件获取类中的属性信息 12345678910111213141516171819202122232425262728293031323334353637383940class student&#123; //4个Field，分别采用了不同的访问控制权限修饰符 public int no; String name; protected boolean sex; private int age;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; //获取整个类 Class c = Class.forName("auto.student"); //获取类的完整类名 System.out.println(c.getName());//auto.student //获取类的简类名（不包活包名） System.out.println(c.getSimpleName());//student //获取类中public修饰的Field Field[] fields = c.getFields(); System.out.println(fields.length);//输出数组长度为1，因为该方法只能获取public修饰的Field System.out.println("=========================="); //获取类中所有的Field Field[] fs = c.getDeclaredFields(); for(Field f:fs)&#123; //获取属性的名字 System.out.println(f.getName()); //获取属性的类型 Class fieldType = f.getType(); System.out.println(fieldType.getName());//完整类型名 System.out.println(fieldType.getSimpleName());//简洁类型名 //获取属性的修饰符，可能是缺省，可能是一个，可能是多个（public static final） //对于Class对象也可以使用这个方法获取类的修饰符 int i = f.getModifiers();//返回的是修饰符的代号 String modeifiers = Modifier.toString(i);//将代号转换为字符串类型 System.out.println(modeifiers); &#125; &#125;&#125; 反编译Field通过反射机制，反编译一个类的属性Field，就以反射上面的Student类为例： 12345678910111213141516171819202122232425public class test &#123; public static void main(String[] args) throws Exception&#123; //创建这个是为了拼接字符串 StringBuilder s = new StringBuilder(); //获取整个类 Class c = Class.forName("auto.student"); s.append(Modifier.toString(c.getModifiers())+" class "+c.getSimpleName()+"&#123;\n"); Field[] fields = c.getDeclaredFields(); for(Field field:fields)&#123; //添加制表符 s.append("\t"); s.append(Modifier.toString(field.getModifiers())); s.append(" "); s.append(field.getType().getSimpleName()); s.append(" "); s.append(field.getName()); s.append(";\n"); &#125; s.append("&#125;"); System.out.println(s); &#125;&#125; 输出结果如下： 123456class student&#123; public int no; String name; protected boolean sex; private int age;&#125; 反射机制访问对象属性 给对象中的属性赋值（set） 获取对象中的属性的值（get） 12345678910111213141516171819202122class student&#123; //4个Field，分别采用了不同的访问控制权限修饰符 public int no; String name; protected boolean sex; private int age;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("auto.student"); Object o = c.newInstance(); //根据属性名称获取no属性 Field noField = c.getDeclaredField("no"); //给o对象的no属性赋值 noField.set(o,10);//给o对象的no属性赋值10 //读取o对象的属性no的值 Object s = noField.get(o); System.out.println(s); &#125;&#125; 跟传统new创建对象的方式一样，如果不加修改便不能在外部访问或修改private修饰的属性。 但与new创建对象方式不同的是，反射机制可以实现在外部访问或修改private属性，这也是它的缺点，打破了封装，如下所示： 1234567891011121314public class test &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("auto.student"); Object o = c.newInstance(); //对于new对象这种方式，肯定是不能在外部访问对象的私有属性 //但是反射机制在却可以实现，这也是它的缺点，打破了封装 Field ageField = c.getDeclaredField("age"); //打破封装 ageField.setAccessible(true); ageField.set(o,20); Object s1 = ageField.get(o); System.out.println(s1); //20 &#125;&#125; 对于被其它访问控制权限符修饰的属性，也可以这样打破限制。比如protected修饰的属性不能在别的包中通过创建实例化对象被访问，但setAccessible(true)之后就可以访问了！！ 所以，反射机制的缺点是打破了封装，为不法份子留下机会 可变长度参数 语法是：类型… （注意：一定是三个点） 12345678910public class test &#123; public static void main(String[] args) &#123; //下面都不会报错 doSome(); doSome(10); doSome(20); &#125; public static void doSome(int... args)&#123; &#125;&#125; 可变长度参数要求参数个数是：0-N个 可变长度参数只能有一个，且在参数列表中必须在最后一个位置上 可变长度参数可以当做一个数组看来看待 12345678910public class test &#123; public static void main(String[] args) &#123; doSome(10,20,30,40); //10 20 30 40 &#125; public static void doSome(int... args)&#123; for(int arg:args)&#123; System.out.println(arg); &#125; &#125;&#125; 所以也可以传一个数组进去： 12345678910public class test &#123; public static void main(String[] args) &#123; doSome(new int[]&#123;10,20,30,40&#125;); &#125; public static void doSome(int... args)&#123; for(int arg:args)&#123; System.out.println(arg); &#125; &#125;&#125; 反射获取Method12345678910111213141516171819202122232425262728293031323334353637class UserService&#123; //登录方法 public boolean login(String name,String password)&#123; if("admin".equals(name)&amp;&amp;"123".equals(password)) return true; return false; &#125; //退出系统的方法 public void logout()&#123; System.out.println("已安全退出"); &#125;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; //获取类 Class c = Class.forName("auto.UserService"); //获取所有的Method（包括私有的） Method[] methods = c.getDeclaredMethods(); //遍历Method for(Method method:methods)&#123; //获取方法名 System.out.println(method.getName()); //获取方法返回值类型 Class returnType = method.getReturnType(); System.out.println(returnType.getSimpleName()); //获取修饰符列表 System.out.println(Modifier.toString(method.getModifiers())); //获取参数类型的列表 Class[] paraTypes = method.getParameterTypes(); for(Class cla:paraTypes)&#123; System.out.print(cla.getSimpleName()); &#125; &#125; &#125;&#125; 反编译Method这里只反编译Method的方法的签名，方法体内的业务代码反编译不出来 123456789101112131415161718192021222324252627282930313233343536373839404142class UserService&#123; //登录方法 public boolean login(String name,String password)&#123; if("admin".equals(name)&amp;&amp;"123".equals(password)) return true; return false; &#125; //退出系统的方法 public void logout()&#123; System.out.println("已安全退出"); &#125;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; StringBuilder s = new StringBuilder(); Class c = Class.forName("auto.UserService"); s.append(Modifier.toString(c.getModifiers())+ " class "+c.getSimpleName()+"&#123;\n"); Method[] methods = c.getDeclaredMethods(); for(Method method : methods)&#123; s.append("\t"); s.append(Modifier.toString(method.getModifiers())); s.append(" "); s.append(method.getReturnType().getSimpleName()); s.append(" "); s.append(method.getName()); s.append("("); Class[] paraTypes = method.getParameterTypes(); for(Class paraType : paraTypes)&#123; s.append(paraType.getSimpleName()); s.append(","); &#125; if(paraTypes.length&gt;0) s.deleteCharAt(s.length()-1); s.append(")&#123;&#125;\n"); &#125; s.append("&#125;"); System.out.println(s); &#125;&#125; 输出结果如下： 1234class UserService&#123; public void logout()&#123;&#125; public boolean login(String,String)&#123;&#125;&#125; 反射机制调用方法通过反射机制如何调用一个对象的方法？ 1234567891011121314151617181920212223242526class UserService&#123; //登录方法 public boolean login(String name,String password)&#123; if("admin".equals(name)&amp;&amp;"123".equals(password)) return true; return false; &#125; //退出系统的方法 public void logout()&#123; System.out.println("已安全退出"); &#125;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("auto.UserService"); Object o = c.newInstance(); Method loginMethod = c.getDeclaredMethod("login",String.class,String.class); //invoke(Object o, Object... args) //第一个参数是调用该方法的对象 //第二个参数是方法的实参，是一个可变长度参数 Object flag = loginMethod.invoke(o,"admin","123"); System.out.println(flag); &#125;&#125; 反射机制，让代码很具有通用性，可变化的内容（比如类名，方法名，参数等）都是写到配置文件中。将来修改配置文件之后，创建的对象不一样了，调用的方法也不同了，但是java代码不需要做任何的改动，这就是反射机制的魅力 反射获取Constructor反射一个类的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Vip&#123; int no; String name; //这里写了三个构造方法 public Vip() &#123; &#125; public Vip(int no) &#123; this.no = no; &#125; public Vip(int no, String name) &#123; this.no = no; this.name = name; &#125;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; StringBuilder s = new StringBuilder(); Class c = Class.forName("auto.Vip"); s.append(Modifier.toString(c.getModifiers())+ " class "+c.getSimpleName()+"&#123;\n"); Constructor[] constructors = c.getConstructors(); for(Constructor constructor : constructors)&#123; s.append("\t"); s.append(Modifier.toString(constructor.getModifiers())); s.append(" "); s.append(c.getSimpleName()); s.append("("); Class[] paraTypes = constructor.getParameterTypes(); for(Class paraType : paraTypes)&#123; s.append(paraType.getSimpleName()); s.append(","); &#125; if(paraTypes.length&gt;0) s.deleteCharAt(s.length()-1); s.append(")&#123;&#125;\n"); &#125; s.append("&#125;"); System.out.println(s); &#125;&#125; 输出结果如下： 12345class Vip&#123; public Vip()&#123;&#125; public Vip(int)&#123;&#125; public Vip(int,String)&#123;&#125;&#125; 反射机制调用构造方法123456789101112131415161718192021222324252627282930313233343536class Vip&#123; int no; String name; public Vip() &#123; &#125; public Vip(int no) &#123; this.no = no; &#125; public Vip(int no, String name) &#123; this.no = no; this.name = name; &#125; @Override public String toString() &#123; return "Vip&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125;&#125;public class test &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("auto.Vip"); //调用无参构造方法 Object o1 = c.newInstance(); System.out.println(o1); //调用有参构造方法 Constructor constructor = c.getDeclaredConstructor(int.class,String.class); Object o2 = constructor.newInstance(10,"wang"); System.out.println(o2); &#125;&#125; 输出结果为： 12Vip&#123;no=0, name='null'&#125;Vip&#123;no=10, name='wang'&#125; 获取父类和父接口12345678910111213141516public class test &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("java.lang.String"); //获取String的父类 Class superClass = c.getSuperclass(); System.out.println(superClass.getName()); //获取String的父接口 //一个类可以实现多个接口 Class[] interfaces = c.getInterfaces(); for(Class in : interfaces)&#123; System.out.println(in.getName()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2020%2F05%2F31%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程概述什么是进程？什么是线程？ 进程是一个引用程序（1个进程是1个软件） 线程是一个进程中的执行场景/执行单元，一个进程可以启动多个线程 对于java程序来说，当在DOS命令窗口中输入：java helloworld之后，会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法，同时再启动一个垃圾回收器线程负责看护，回收垃圾。最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收器线程，一个是执行main方法的主线程 进程和线程的关系 进程可以看做是现实生活中的公司，线程可以看做是公司中的某个员工。注意：进程A和进程B的内存独立不共享 在java语言中 线程A和线程B的堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈，每个栈之间互不干扰，这就是多线程并发 java中之所以有多线程机制，目的就是为了提高程序的处理效率 这里需要理解一个并发和并行的区别： 并发：是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行 。 并行：是说在单位时间内多个任务同时在执行 下面有一个小结论： 单核CPU中进程和线程只能是并发，不能并行 多核CPU中进程和线程既可以并发，也可以并行 例如，一个4核的CPU，同时可以有四个进程并行，也可以同一个进程中的4个线程并行。在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称多线程并发编程而不是多线程并行编程 这里有个小知识：现在有单核多线程技术，比如RYZEN R5 3600的CPU，是6核12线程。6核12线程，即物理核心是6个，但是从计算机的角度来看，被虚拟为了12个核心。从物理上讲，同一时刻可以有6个执行单元。从操作系统底层来讲，是12个。程序的最小执行单位是线程（这里的线程不是6核12线程的那个线程，两者不一样，只是叫法一样）。等同于有12个CPU，12个CPU最多有12个线程在执行，12个线程最多能够属于12个进程 线程的实现java语言中，实现线程有两种方式 第一种：编写一个类，直接继承java.lang.Thread，重写run方法 1234567891011121314151617181920212223242526272829303132public class thread &#123; public static void main(String[] args) &#123; //这里是main方法，这里的代码属于主线程 //新建分支线程对象 MyThread mythread = new MyThread(); //如果直接调用run方法，不会启动线程，不能并发，就是单线程 //mythread.run(); //启动分支线程 //start方法的作用是启动一个新的分支线程，在JVM中开辟一个新的栈空间 //这行代码任务完成之后，瞬间就结束了，线程就启动成功了 //启动成功的方法会自动调用run方法，并且run方法在分支栈的底部 //run方法和main方法作用相同，它们是平级的 mythread.start(); //这里的代码还是运行在主线程 for(int i=0;i&lt;1000;i++)&#123; System.out.println("主线程--&gt; " + i); &#125; &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; //编写程序，这段程序运行在分支线程中 for(int i=0;i&lt;1000;i++)&#123; System.out.println("分支线程--&gt; "+ i); &#125; &#125;&#125; 第二种：编写一个类，实现java.lang.Runnable接口，实现run方法 123456789101112131415161718192021222324252627public class ThreadTest &#123; public static void main(String[] args) &#123; //创建一个可运行的对象 myRunnable r = new myRunnable(); //将可运行的对象封装成一个线程对象 Thread t = new Thread(r); //启动线程 t.start(); //这里的代码还是运行在主线程 for(int i=0;i&lt;1000;i++)&#123; System.out.println("主线程--&gt; " + i); &#125; &#125;&#125;//这并不是一个线程类，而是一个可运行的类，它还不是一个线程class myRunnable implements Runnable &#123; @Override public void run() &#123; //编写程序，这段程序运行在分支线程中 for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("分支线程--&gt; " + i); &#125; &#125;&#125; 建议使用第二种方式：因为一个类实现了接口，还可以继承其它的类，更灵活，符合面向接口编程思想 第二种创建线程的方式还可以改写成匿名内部类的形式： 12345678910111213141516171819public class ThreadTest &#123; public static void main(String[] args) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++)&#123; System.out.println("分支线程--&gt; " + i); &#125; &#125; &#125;); //启动线程 t.start(); //这里的代码还是运行在主线程 for(int i=0;i&lt;1000;i++)&#123; System.out.println("主线程--&gt; " + i); &#125; &#125;&#125; 线程生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 新建：就是刚使用new方法，new出来一个新的的线程对象； 就绪：就是调用的线程的start()方法后，该状态的线程位于可运行线程池中，变得可运行，等待抢夺CPU的使用权。 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要进入就绪状态再次等待CPU分配资源进入运行状态（下图中的阻塞状态、等待队列和锁池状态是阻塞的三种情况） 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源; 如下图所示： 阻塞的情况分三种： （一）等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) （二）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 （三）其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 获取线程对象的名字String name = 线程对象.getName(); 1234567891011121314151617181920public class thread &#123; public static void main(String[] args) &#123; MyThread mythread = new MyThread(); mythread.start(); //获取线程名字 String name1 = mythread.getName(); System.out.println(name1);//Thread-0,这是默认名字 String name2 = mythread.getName(); System.out.println(nam2);//Thread-1 &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++)&#123; System.out.println("分支线程--&gt; "+ i); &#125; &#125;&#125; 当线程没有设置名字的时候，默认的名字为：Thread-0，Thread-1，Thread-2等 修改线程对象的名字线程对象.setName(“线程名字”); 12345678public class thread &#123; public static void main(String[] args) &#123; MyThread mythread = new MyThread(); mythread.setName("T1") String name1 = mythread.getName(); System.out.println(name1);//T1 &#125;&#125; 获取当前线程对象Thread t = Thread.currentThread(); 12345678910111213141516171819202122232425public class thread &#123; public static void main(String[] args) &#123; //这个代码出现在main方法中，所以当前线程就是主线程 Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName());//main //新建分支线程对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); t1.start(); t2.start(); &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++)&#123; //当t1线程执行run方法，那么这个当前线程就是t1 //当t2线程执行run方法，那么这个当前线程就是t2 Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName()+"--&gt;"+ i); &#125; &#125;&#125; 线程的sleep方法static void sleep(long millis) Thread类中的静态方法，使用方法：Thread.sleep(1000)； 参数是毫秒 作用：让当前线程进入休眠，进入阻塞状态，放弃占有的CPU资源，让给其它线程使用。出现在哪里，哪个线程就进入休眠状态 Thread.sleep()方法可以做到这种效果：间隔特定的时间，去执行一段特定的代码，每隔一段时间执行一次 1234567891011121314public class thread &#123; public static void main(String[] args) &#123; //每隔1s输出一次 for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); //sleep方法是编译时异常，需要处理 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注意：如果Thread.sleep()方法写在run方法中，只能try-catch，不能抛出异常。因为run方法在父类中没有刨除任何异常，子类不能比父类抛出更多的异常 终止线程的睡眠 123456789101112131415161718192021222324252627282930public class thread &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.setName("t"); t.start(); //希望5s之后，t线程醒来（5s之后主线程手里的活儿干完了） try &#123; Thread.sleep(1000*5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //中断t线程的睡眠（这种中断睡眠的方式其实就是让t线程的睡眠抛出异常） t.interrupt(); &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"--&gt;begin"); try &#123; //睡眠1年 Thread.sleep(1000*60*60*24*365); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"--&gt;end"); &#125;&#125; 上述代码的输出结果为： 12345t--&gt;beginjava.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at com.bit.auto.MyThread.run(thread.java:26)t--&gt;end 如果不想打印异常信息，只需要把catch语句中的异常信息打印注释掉即可 强行终止线程的执行123456789101112131415161718192021222324252627282930313233public class thread &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.setName("t"); t.start(); //希望5s之后，t线程醒来（5s之后主线程手里的活儿干完了） try &#123; Thread.sleep(1000*10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //5s之后，强行终止t线程 //已过时，不建议使用 //这种方式容易丢失数据，因为是直接将线程杀死了 t.stop(); &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上述终止线程的方式存在很大的问题，那么如何合理的终止一个线程呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041public class thread &#123; public static void main(String[] args) &#123; MyThread t = new MyThread(); t.setName("t"); t.start(); //希望5s之后，t线程醒来（5s之后主线程手里的活儿干完了） try &#123; Thread.sleep(1000*10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //终止线程 //你想什么时候终止t的执行，那么把标记改成false，就结束了 t.run = false; &#125;&#125;class MyThread extends Thread&#123; //打一个布尔标记 boolean run = true; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(run)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; //return就结束了，在结束之前还有什么没保存的 //在这里可以保存 //终止线程 return; &#125; &#125; &#125;&#125; 线程调度常见的线程调度模型 抢占式调度模型：哪个线程的优先级高，抢到CPU时间片的概率就大。java采用的就是抢占式调度模型 分时调度模型：让所有的线程轮流获得CPU使用权，并且平均分配每个线程占用的CPU时间片。有些语言采用的就是这种模型 java提供了哪些方法和线程调度有关？ 实例方法 void setPriority(int newPriority)：设置线程优先级 int getPriority()：获取线程优先级（最低优先级是1，默认优先级是5，最高优先级是10） Thread类中有常量代表了上述三个优先级： 123public static final int MIN_PRIORITY = 1;public static final int NORM_PRIORITY = 5;public static final int MAX_PRIORITY = 10; 静态方法 static void yield()：暂停当前正在执行的线程对象，并执行其他线程。yield方法不是阻塞方法，让当前线程从运行状态回到就绪状态。注意：在回到就绪状态之后，有可能还会再次抢到 实例方法 void join()：合并线程 12345678910111213class m1 extends Thread&#123; public void doSome()&#123; m2 t = new m2(); //把t线程合并至当前线程，其实就是此时双线程变成了单线程 //当前线程进入阻塞，t线程执行 //直到t线程执行结束，当前线程才可以继续执行 t.join(); &#125;&#125;class m2 extends Thread&#123; &#125; 线程安全(重点)什么时候数据在多线程并发的环境下会存在安全问题？ 三个条件： 条件1：多线程并发 条件2：有共享数据 条件3：共享数据有修改行为 满足以上三个条件之后，就会存在线程安全问题 如何解决线程安全问题？ 当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决？ 线程排队执行（不能并发），这种机制被称为线程同步机制 线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率 说到线程同步，涉及到两个专业术语： 异步编程模型：线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫：异步编程模型。其实就是多线程并发，效率较高 同步编程模型：线程t1和线程t2，在线程t1执行的时候，必须等到t2线程执行结束，或者在t2线程执行的时候，必须等待t1线程执行结束。两个线程之间发生了等待关系，效率较低 下面举一个多线程并发导致线程不安全的例子：一个银行账户里面有1万元，取钱是分为三步的（获取账户余额 —&gt; 取钱 —&gt; 计算剩余钱并修改账户余额）。假设A和B是两个人（两个线程），A先取5000，结果在准备修改余额的时候网络延迟了，导致余额暂时没有被修改，还是1万；此时B也来取5000，然后修改余额。最后会导致共取出了1万元，但是账户余额还是5000 下面我们编程来模仿一下这个例子： 123456789101112131415161718192021222324252627282930313233343536373839//银行账户类 Account.javapublic class Account &#123; //账号 private String actno; //余额 private double balance; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public Account(String actno, double balance) &#123; this.actno = actno; this.balance = balance; &#125; //取款的方法 public void withDraw(double money)&#123; //取款之前的余额 double before = this.getBalance(); //取款之后的余额 double after = before - money; //更新余额 //假设t1执行到这里了，但还没来得及执行这行代码，t2线程进来withDraw这个方法了，此时一定出问题！！！ this.setBalance(after); &#125;&#125; 然后编写测试类，模仿多线程并发情况下的线程不安全的情况 123456789101112131415161718192021222324252627282930313233//线程类，AccountThread.javapublic class AccountThread extends Thread &#123; //两个线程必须共享一个账户对象 private Account act; //通过构造方法传递过来账户对象 public AccountThread(Account act)&#123; this.act = act; &#125; @Override public void run() &#123; //run方法的执行表示取款操作 //假设取款5000 double money = 5000; //取款 act.withDraw(5000); System.out.println(Thread.currentThread().getName()+"对账户"+act.getActno()+"取款成功, 余额"+act.getBalance()); &#125;&#125;//测试类 Test.javapublic class Test &#123; public static void main(String[] args) &#123; //创建账户对象 Account act = new Account("act001",10000); //创建两个线程 Thread t1 = new AccountThread(act); Thread t2 = new AccountThread(act); t1.setName("t1"); t2.setName("t2"); t1.start(); t2.start(); &#125;&#125; 如果出现线程不安全问题，即t1和t2每人取了5000元，最后的余额是5000。输出结果会如下所示： 12t2对账户act001取款成功, 余额5000.0t1对账户act001取款成功, 余额5000.0 但注意：也有可能会不出现问题，因为如果t1线程成功的修改了余额，此时t2线程才开始执行，那么就不会出现问题！！！ 针对上面那个例子，怎么解决存在的线程不安全问题呢？ 需要对账户类（Account.java）的withDraw方法进行修改，利用synchronized关键字，如下所示： 1234567891011121314151617181920212223//取款的方法 public void withDraw(double money)&#123; //以下这几行代码必须是线程排队的，不能并发 //一个线程把这里的代码全部执行结束之后，另一个线程才能进来执行 /* * 线程同步机制的语法： * synchronized()&#123; * //线程同步代码块 * &#125; * synchronized后面小括号中的数据是非常关键的 * 这个数据必须是多线程共享的数据，才能达到多线程排队 * synchronized后面括号里面必须是Object对象 * 例如：假设5个线程：t1、t2、t3、t4、t5，只希望t1、t2和t3排队，t4和t5不排队 * 那么一定在()中写一个t1、t2和t3共享的对象 * 而这个对象对于t4和t5不是共享的 * */ //不一定是this，只要是多线程共享的对象就行 synchronized (this)&#123; double before = this.getBalance(); double after = before - money; this.setBalance(after); &#125; &#125; 对synchronized关键字的理解： 在java中，任何一个对象都有一把锁。100个对象就有100把锁，一个对象一把锁。 synchronized同步代码块的执行原理为：假设t1和t2线程并发，开始执行的时候肯定一个先一个后；假设t1先执行了，遇到了synchronized，这个时候自动找后面共享对象的对象锁，找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直占有这把锁，直到同步代码块结束，这把锁才会释放。假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束。直到t1把同步代码块结束了，t1会归还这把锁。此时t2便可以占有这把所，并执行同步代码块中的内容，这样便达到了线程排队执行。这里需要注意的是：这个共享对象一定要选好了，一定要是需要排队执行的这些线程所共享的对象 对于上面那个例子，我们思考如下问题： 12345678910111213public class Account&#123; Object obj = new Object(); public void withDraw(double money)&#123; //这里不写this，换成obj //这样写依旧是线程安全的，因为obj只有1个，是被t1线程和t2线程所共享的 //当t1获得了obj的锁之后，t2是无法获得obj的锁的，必须等待 synchronized (obj)&#123; double before = this.getBalance(); double after = before - money; this.setBalance(after); &#125; &#125;&#125; 下面挖个坑： 12345678910111213public class Account&#123; public void withDraw(double money)&#123; Object obj = new Object(); //这样写就不是线程安全了 //因为t1进来会创建一个obj对象，t2进来也会创建一个obj对象 //因为两个obj对象不一样，所以锁不冲突，会异步执行 synchronized (obj)&#123; double before = this.getBalance(); double after = before - money; this.setBalance(after); &#125; &#125;&#125; 要注意和上面的区别！！！重点就是synchronized中的对象一定要是线程共享的，才能实现同步执行！！！ 也可以在实例方法上使用synchronized关键字！！例如 1234567public class Account&#123; public synchronized void withDraw(double money)&#123; double before = this.getBalance(); double after = before - money; this.setBalance(after); &#125;&#125; 但是要注意：synchronized出现在实例方法上，锁的一定是this，没得挑，只能是this，不能是其它对象的，不灵活 另外，synchronized出现在实例方法上，表示整个方法体都要同步，可能会无故扩大同步的范围，导致程序的执行效率降低，所以这种方式不常用 那么这种方式有什么优点？代码写得少，简洁了 如果共享的对象就是this，并且同步的代码块是整个方法体，建议使用这种方式 总结：synchronized的三种写法： 同步代码块：灵活 在实例方法上使用synchronized：表示共享对象一定是this，并且同步代码块是整个方法体 在静态方法上使用synchronized关键字，表示找类锁（注意和对象锁的区别，100个对象就有100个对象锁），类锁永远只有1把，就算创建了100个对象，类锁也只有1把，类锁是为了保证静态变量的安全 哪些变量有线程安全问题java中有三大变量： 成员变量 实例变量：在堆中 静态变量：在方法区中 局部变量：在栈中 以上三大变量中，局部变量永远都不会存在线程安全问题，因为局部变量不共享（一个线程一个栈），局部变量在栈中，所以局部变量永远都不会共享 实例变量在堆中，堆只有一个；静态变量在方法区中，方法区只有一个。堆和方法区都是多线程共享的，所以可能存在线程安全问题 常量也不会有线程安全问题，因为常量不可修改 总结：局部变量和常量永远都不会存在线程安全问题，静态变量和实例变量可能存在线程安全问题 死锁当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁 不出现异常，也不出现错误，程序一直僵持在那里 死锁代码是怎样的？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DeadLock &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new MyThread1(o1,o2); Thread t2 = new MyThread2(o1,o2); &#125;&#125;class MyThread1 extends Thread&#123; private Object o1; private Object o2; public MyThread1(Object o1,Object o2)&#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; //先锁o1，再锁o2 synchronized (o1)&#123; synchronized (o2)&#123; &#125; &#125; &#125;&#125;class MyThread2 extends Thread&#123; private Object o1; private Object o2; public MyThread2(Object o1,Object o2)&#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; //先锁o2，再硕o1 synchronized (o2)&#123; synchronized (o1)&#123; &#125; &#125; &#125;&#125; 上述代码也有可能不形成死锁：某一个线程执行完了，另一个线程才开始，这样就不会形成死锁。 所以，synchronized最好不要嵌套使用，一不小心就形成死锁 开发中怎么解决线程安全问题不要一上来就使用synchronized，这会让程序的执行效率降低，用户体验不好，系统的用户吞吐量降低，用户体验差，在不得已的情况下再选择线程同步机制 第一种方案：尽量使用局部变量代替实例变量和静态变量 第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。对象不共享，就没有数据安全问题 第三种方案：如果上述两种都不行，那就只能使用synchronized关键字 守护线程java语言中，线程分为两大类： 用户线程：我们前面学的线程，包括main线程都是用户线程 守护线程（后台线程） 守护线程中具有代表性的比如：垃圾回收线程 守护线程的特点：一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束 守护线程用在什么地方：比如每天零点的时候，系统数据自动备份，这个需要用到计时器，将定时器设置为守护线程，每到零点的时候就备份一次。所有的用户线程结束了，守护线程自动退出，没有必要备份了 实现守护线程： 123456789101112131415161718192021222324public class DamenThread &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.setName("备份数据线程"); //启动线程之前，将线程设置为守护线程 t.setDaemon(true); t.start(); //main是主线程 for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); &#125; &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(true)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+(i++)); &#125; &#125;&#125; 定时器作用：间隔特定的时间，执行特定的程序 定时器在java中其实可以采用多种方式实现： 可以使用sleep方法，设置睡眠时间，这种是最原始的定时器，比较low 在java类库中写好了一个定时器：java.util.Timer，可以直接使用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的 在实际的开发中，目前使用较多的是Spring框架中的SpringTask框架，这个框架中只要进行简单的配置，就可以完成定时器任务 下面用Timer实现一个定时器，指定定时任务 12345678910111213141516171819202122232425public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; //创建定时器对象 Timer timer = new Timer(); //将定时器对象设置为守护线程的形式 //Timer timer = new Timer(true); //指定定时器任务 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date dateTime = sdf.parse("2020-06-02 13:30:00"); //timer.schedule(定时器任务 TimeTask类型，第一次执行时间，Date类型，间隔多久执行一次，毫秒数); timer.schedule(new LogTimerTask(),dateTime,1000*10); &#125;&#125;//编写一个定时任务类//也可以用匿名内部类的方式class LogTimerTask extends TimerTask &#123; @Override public void run() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String logTime = sdf.format(new Date()); System.out.println(logTime+":完成了一次数据备份"); &#125;&#125; 实现线程的第三种方式JDK8的新特性！！！实现Callable接口 这种方式实现的线程可以获取线程的返回值 之前的两种方式无法获得线程返回值，因为run方法返回值类型是void 1234567891011121314151617181920212223242526272829public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //创建一个未来任务类对象 //参数非常重要，需要给一个Callable接口实现类 //也可以不采用匿名内部类的方式 FutureTask task = new FutureTask(new Callable() &#123; //call方法就相当于run方法，只不过有返回值 @Override public Object call() throws Exception &#123; System.out.println("begin"); Thread.sleep(1000*10); System.out.println("end"); int a = 100; int b = 200; return (a+b); //自动装箱，变成Integer &#125; &#125;); //创建线程对象 Thread t = new Thread(task); //启动线程 t.start(); //在主线程中，怎么获得t线程的执行结果？ //这里会导致main线程阻塞，因为需要等待t线程执行完全结束才能获取返回值 //执行到这里main线程会等待t线程结束 Object obj = task.get(); &#125;&#125; 这种方式的优点是可以获取线程返回值，缺点是在获取线程执行结果的时候，当前线程阻塞，效率较低 Object类中的wait和notify方法wait和notify方法不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方法是Object类自带的。wait方法和notify方法不是通过线程对象调用的 wait()方法作用？ 123Object o = new Object();o.wait();//表示让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止 例如：t线程在o对象上活动，t线程是当前线程对象，当调用o.wait()方法后，t线程进入无限期等待，当前线程进入等待状态，直到最终调用o.notify()方法。o.notify()方法的调用可以让正在o对象上等待的线程被唤醒 notify()方法作用？ 12345Object o = new Object();//唤醒正在o对象上等待的某一个线程o.notify();//唤醒o对象上处于等待的所有线程o.notifyAll(); o.wait()与o.notify()必须要与synchronized一起使用，也就是wait与notify必须通过获取的锁对象进行调用，从语法角度来说就是o.wait()和o.notify()必须在synchronized(o){…}语句块内。 为什么要在一起使用 Object.wait()，Object.notify()，Object.notifyAll()都是Object的方法，换句话说，就是每个类里面都有这些方法 Object.wait()：释放当前对象锁，并让当前线程进入等待队列 Object.notify()：唤醒当前对象等待队列里的任一线程进入锁池队列（并不保证唤醒哪一个） Object.notifyAll()：唤醒当前对象等待队列里的所有线程 为什么这三个方法要与synchronized一起使用呢？解释这个问题之前，我们先要了解几个知识点： 每一个对象都有一个与之对应的监视器 每一个监视器里面都有一个该对象的锁以及一个等待队列和一个锁池队列 wait()方法的语义有两个，一是释放在对象上活动的当前线程占有的锁，另一个是让该线程进入等待队列，可以看到，这些操作都是与监视器相关的，当然要指定一个监视器才能完成这个操作 notify()方法也是一样的，用来唤醒一个线程，你要去唤醒，首先你得知道他在哪儿，所以必须先找到该对象，也就是获取该对象的锁，当获取到该对象的锁之后，才能去该对象的对应的等待队列去唤醒一个线程。值得注意的是，只有当执行唤醒工作的线程离开同步块，即释放锁之后，被唤醒线程才能去竞争锁。如果获得锁成功后，那么该线程就会沿着wait方法之后的路径继续执行。注意是沿着wait方法之后，而不是重新执行 因wait()而导致阻塞的线程是放在等待队列中的，因竞争失败导致的阻塞是放在锁池队列中的，notify()/notifyAll()实质上是把等待队列中的线程放到锁池队列中去 生产者和消费者模式使用wait方法和notify方法实现生产者和消费者模式 什么是生产者和消费者模式？ 生产线程负责生产，消费线程负责消费 生产线程和消费线程要达到均衡，需要使用wait和notify方法 wait方法和notify方法建立在线程同步的基础之上，因为多线程要同时操作一个仓库，有线程安全问题 模拟这样一个需求： 仓库采用List集合 List集合中假设只能存储一个元素 1个元素就表示仓库满了 如果List集合元素个数是0，就表示仓库空了 保证List集合中永远都是最多存储1个元素，即生产一个消费一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ThreadTest2 &#123; public static void main(String[] args) &#123; //创建仓库对象 List list = new ArrayList(); //创建生产者线程 Thread t1 = new Thread(new Producer(list)); //创建消费者线程 Thread t2 = new Thread(new Customer(list)); t1.setName("生产者线程"); t2.setName("消费者线程"); t1.start(); t2.start(); &#125;&#125;//生产线程class Producer implements Runnable&#123; //仓库 private List list; public Producer(List list)&#123; this.list = list; &#125; @Override public void run() &#123; //一直生产 while(true)&#123; synchronized (list)&#123; if(list.size()&gt;0)&#123;//已经有一个元素了 try &#123; //当前线程进入等待状态 //并且释放Producer之间占有的List集合的锁 list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Object o = new Object(); list.add(o); System.out.println(Thread.currentThread().getName()+"--&gt;"+o); list.notify(); &#125; &#125; &#125;&#125;//消费线程class Customer implements Runnable&#123; //仓库 private List list; public Customer(List list)&#123; this.list = list; &#125; @Override public void run() &#123; //一直消费 while (true)&#123; synchronized (list)&#123; if(list.size()==0)&#123;//没有元素 try &#123; list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Object o = list.remove(0); System.out.println(Thread.currentThread().getName()+"--&gt;"+o); list.notify(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解Java采用Unicode编码]]></title>
    <url>%2F2020%2F05%2F26%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Java%E9%87%87%E7%94%A8Unicode%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Java中字符仅以一种形式存在，那就是Unicode。由于Java采用unicode编码，char 在java中占2个字节。2个字节（16位）来表示一个字符。这里的Java中是指在JVM中、在内存中、在代码里声明的每一个char、String类型（String底层是char数组）的变量中。 JVM的这种约定使得一个字符分为两部分：JVM内部和OS的文件系统。在JVM内部，统一使用Unicode表示，当这个字符被从JVM内部移到外部（即保存为文件系统中的一个文件中的内容时），就进行了编码转换，使用了具体的编码方案。因此可以说所有的编码转换只发生在边界的地方：JVM和OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。 所有的I/O基本上可以分为两大阵营：面向字符的输入/输出流和面向字节的输入/输出流。如果面向字节，那么这类工作要保证系统中的文件二进制内容和读入JVM内部的二进制内容一致，不能变换任何0和1的顺序。这种输入/输出方式很适合诸如视频文件或者音频文件，因为不需要变换任何文件内容。而面向字符的I/O是指希望系统中的文件的字符和读入内存的“字符”要一致。例如：我们的系统上有一个UTF-8的文本文件，其中有一个“永”字，我们不关心这个字的UTF-8编码是什么，只希望在使用面向字符的I/O把它读入内存并保存在一个char型变量中时，I/O系统不要直接把“永”字的UTF-8编码放到这个字符（char）型变量中，我们不关心这个char型变量具体的二进制内容到底是多少，只希望这个字符读进来之后仍然是“永”字。从这个意义上可以看出，面向字符的I/O类，也就是Reader和Writer类，实际上隐式做了编码转换，在输出时，将内存中的Unicode字符使用平台默认编码方式（系统一般是GBK，IDE中可以设置）进行了编码，而在输入时，将文件系统中已经编码过的字符使用默认编码方案进行了还原。这里要注意，FileReader和FileWriter只会使用这个默认的编码来做转换，而不能为一个FileReader和FileWriter指定转换时使用的编码。这也意味着，如果使用中文版Windows系统，其中存放了一个UTF8编码的文件，当采用Reader类来读入的时候，它还会用GBK来转换，转换后的内容当然不对。这其实是一种傻瓜式的功能提供方式，对大多数初级用户（以及不需要跨平台的高级用户，windows一般采用GBK，linux一般采用UTF8）来说反而是一件好事。如果用到GBK编码以外的文件，就必须采用编码转换：一个字符与字节之间的转换。因此，Java的I/O系统中能够指定转换编码的地方，也就是在字符与字节转换的地方，那就是InputStremReader与OutputStreamWriter。这两个类是字节流和字符流的适配器类，它们承担编码转换的任务。既然java是用unicode来编码字符，”我”这个中文字符的unicode就是2个字节。 InputStream和Reader都可以用来读数据(从文件中读取数据或从Socket中读取数据)，最主要的区别如下: InputStream用来读取二进制数(字节流)，而 Reader用来读取文本数据，即 Unicode字符。那么二进制数与文本数据有什么区别呢?从本质上来讲，所有读取的内容都是字节，要想把字节转换为文本，需要指定一个编码方法。而 Reader就可以把字节流进行编码从而转换为文本。当然，这个转换过程就涉及编码方式的问题，它默认采用平台（系统或IDE）默认的编码方式对字节流进行编码，也可以显式地指定一个编码方式，例如“UTF-8″。 如何查看系统的默认编码格式： 1System.out.print(System.getProperty("file.encoding")); 这里要注意：如果在IDE里面编译运行的话，输出的默认编码是IDE里面设置的（比如IntelliJ IDEA里面可以设置project encoding，这就是默认的编码）；如果在DOS命令窗口里面编译运行的话，就是windows系统默认的编码，此时就是GBK！！！ 下面我们应该讨论一下OutputStream和Writer在输出文件时采用什么编码？ OutputStream 字节数组的编码方式，决定了OutStream写出文件的格式。比如说从某个文件里利用InputStream流读取到byte数组中，如果该文件是UTF8编码，那么利用FileOutStream写出的文件的格式也就是UTF8；或者通过String.getBytes(指定字符集)获取字节数组，那么输出的文件的格式就是该指定的字符集 Writer Writer 的编码是根据你的运行平台来获取编码。如果你在dos窗口中运行java程序，则根据你的windows 编码决定（默认是GBK）；如果，你是在IDE开发工具中运行（可以自己设置），则跟着你的开发工具的编码走 总而言之，一定要注意编码的问题，否则很容易出现乱码！！！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流]]></title>
    <url>%2F2020%2F05%2F25%2FIO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是IO?I：Input O：Output 通过IO可以完成硬盘文件的读和写 IO流分类有多种分类方式： 按照流的方向进行分类，以内存为参照物： 往内存中去，叫做输入，或者叫做读，叫做输入流 从内存中出来，叫做输出，或者叫做写，叫做输出流 按照读取数据方式不同分类： 按照字节的方式读取数据，一次读取一个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取，叫做字节流 按照字符的方式读取数据，一次读取一个字符，为了方便读取普通文本文件(txt文件、java文件等，能用记事本编辑的都是普通文本文件，与文件后缀无关)，不能读取图片、声音、视频等文件，只能读取文本文件，连word文件都读取不了，叫做字符流 Java中所有的流都是在java.io.*包下 IO流的四大家族： java.io.InputStream：字节输入流 java.io.OutputStream：字节输出流 java.io.Reader：字符输入流 java.io.Writer：字符输出流 上述为四大家族的首领，它们都是抽象类。所有的流都实现了java.io.Closeable接口，都是可关闭的，都有close()方法。流毕竟是一个管道，是内存和硬盘之间的通道，用完一定要关闭（养成这个好习惯），不然会占用很多资源 所有的输出流都实现了java.io.Flushable接口，都是可刷新的，都有flush()方法。养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，刷新的作用就是清空管道，将管道中剩余未输出的数据强行输出！如果没有flush可能会丢失数据 注意：在java中只要类名以Stream结尾的都是字节流，以Reader/Writer结尾的都是字符流 java.io包下需要掌握的流有16个： 文件专属： java.io.FileInputStream java.io.FileoutputStream java.io.FileReader java.io.FileWriter 转换流：将字节流转换为字符流 java.io.InputStreamReader java.io.OutputStramWriter 缓冲流专属： java.io.BufferedReader java.io.BufferedWriter java.io.BufferedInputStream java.io.BufferedOutputStream 数据流专属： java.io.DataInputStream java.io.DataOutputStream 对象专属流： java.io.ObjectInputStream java.io.ObjectOutputStream 标准输出流： java.io.PrintWriter java.io.PrintStream FileInputStream 文件字节输入流，万能的，任何类型的文件都可以采用这个流来读 字节的方式，完成读的操作，从硬盘到内存 下面的代码是FileInputStream标准架子，要学会搭 123456789101112131415161718192021222324252627282930313233public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileInputStream file = null; try &#123; //写成这个也是可以的，都是绝对路径 //file = new FileInputStream("G:/test.txt"); //这里也可以用相对路径，默认目录是此工程project的根目录！！！（每个工程下有很多模块） //比如("test.txt")表示在根目录下寻找该文件 //如果不采用默认目录，一定是从该文件当前所在的位置作为起点开始找 //例如("src/com/info.txt")表示在根目录下的src下的com中寻找info.txt文件 file = new FileInputStream("G:\\test.txt"); //有异常，处理方式为catch (FileNotFoundException e) //read方法的返回值是读取到的"字节"本身,即每调用一次read方法，从FileInputStream中读取一个字节 //如果已达到文件末尾，返回-1 //利用while可以循环读，终止条件是返回值为-1 int readData = file.read();//有异常，处理方式为catch (IOException e) System.out.println(readData); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //在finally语句块中确保流一定关闭 if(file!=null)&#123; //关闭流的前提：流不是null try &#123; file.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 循环读取数据写法： 1234int readData = 0;while((readData=file.read())!=-1)&#123; System.out.println(readData);&#125; 上述代码存在缺点：一次读取一个字节，这样内存和硬盘交互太频繁，基本上时间都耗费在交互上面了。能不能一次读取多个字节？可以！ int read(byte[] b)：一次最多读取b.length个字节，往byte[]数组当中读，减少交互次数，提高读取效率 1234567891011byte[] bytes = new byte[4];//文件里面的内容为：abcdef//返回值为读取到的字节的数量，不是字节本身int readCount = file.read(bytes);System.out.println(readCount);//返回4，第一次读取到了4个字节int readCount = file.read(bytes);System.out.println(readCount);//返回2，第一次读取到了2个字节。同时bytes数组前两个元素会被这次读取的元素覆盖int readCount = file.read(bytes);System.out.println(readCount);//返回-1，1个字节都没有读到 FileInputStream最终版：下面的内容要掌握 12345678910111213141516171819202122232425public static void main(String[] args) &#123; FileInputStream file = null; try &#123; file = new FileInputStream("G:\\test.txt"); byte[] bytes = new byte[4]; int readCount = 0; while((readCount = file.read(bytes)) != -1)&#123; //把byte数组转换成字符串，读到多少个，转换多少个 System.out.print(new String(bytes,0,readCount)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(file!=null)&#123; try &#123; file.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 其它常用方法 int available()：返回流当中剩余的没有读到的字节数量。这个方法的用处：读文件在生成byte数组时可以提前指定好，就不用循环了（byte[] bytes = new byte[file.available()]）。但这种方式不适合大文件 123file = new FileInputStream("G:\\test.txt"); //文件中内容为：abcdefint readData = file.read();System.out.println("剩余未读字节数："+file.available());//剩余未读字节数：5 long skip(long n)：跳过n个字节不读 12345file = new FileInputStream("G:\\test.txt");file.skip(3); //跳过3个字节不读byte[] bytes = new byte[file.available()];int readCount = file.read(bytes);System.out.println(new String(bytes)); //def FileOutputStream12345678910111213141516171819202122232425262728293031323334353637public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileOutputStream file = null; try &#123; //file文件不存在的时候，会自动新建 //这种方式谨慎使用，因为会先将原文件清空再写入 file = new FileOutputStream("G:\\test1.txt"); //以追加的方式写入该怎么办？如下所示 //file = new FileOutputStream("G:\\test1.txt",true); byte[] bytes = &#123;97,98,99,100&#125;; //将byte数组全部写出 file.write(bytes);//abcd //将byte数组一部分写出,第二个参数为起始位置，第三个参数为写出的长度 file.write(bytes,0,2);//ab //写入一个整型数据，会把十进制转化成二进制，然后转化为字符写进记事本 file.write(100); //如果想写入一个字符串，要调用getBytes方法 String s = "hello,world!"; byte[] b = s.getBytes(); file.write(b); //写完之后，最后一定要刷新 file.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; if(file!=null) &#123; try &#123; file.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件复制以内存为中介，利用FileInputStream和FileOutputStream一边读一边写实现复制。利用字节流拷贝文件的时候，文件类型随意，什么样的文件都可以拷贝 1234567891011121314151617181920212223242526272829303132333435363738public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileInputStream fin = null; FileOutputStream fout = null; try &#123; fin = new FileInputStream("G:\\test.txt"); fout = new FileOutputStream("G:\\test3.txt",true); //一边读一边写 byte[] bytes = new byte[1024 * 1024];//一次最多拷贝1M int readCount = 0; while((readCount=fin.read(bytes))!= -1)&#123; fout.write(bytes,0,readCount); &#125; fout.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //这里要分开try-catch，如果一起try-catch的话，上面的fin流如果关闭时出异常会导致fout流关闭不了 if(fin!=null) &#123; try &#123; fin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fout!=null) &#123; try &#123; fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; FileReader文件字符输入流，只能读取普通文本文件。读取文本内容时，比较快捷方便 123456789101112131415161718192021222324252627public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileReader file = null; try &#123; file = new FileReader("G:\\test.txt"); //这里是char数组，注意和FileInputStream的区别 //一次读取一个字符 char[] chars = new char[4]; int readCount = 0; while((readCount=file.read(chars))!=-1)&#123; System.out.print(new String(chars,0,readCount)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(file!=null) &#123; try &#123; file.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; FileWriter文件字符输出流，只能输出普通文本，负责写 1234567891011121314151617181920212223242526272829public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileWriter fout = null; try &#123; fout = new FileWriter("G:\\test4.txt"); //char数组全部输出 char[] chars = &#123;'我','爱','你'&#125;; fout.write(chars); //char数组部分数组 fout.write(chars,1,2); //可以直接写字符串，也可以写入一部分，规则与char数组一致 String s = "我是中国人"; fout.write(s); //也可以换行 fout.write("\n"); fout.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(fout!=null) &#123; try &#123; fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 普通文本文件复制用字节流也可以实现，不过我们这里用上面的字符流来实现。结构都是一致的 1234567891011121314151617181920212223242526272829303132333435public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileReader fin = null; FileWriter fout = null; try &#123; fin = new FileReader("G:\\test.txt"); fout = new FileWriter("G:\\test4.txt"); char[] chars = new char[1024*1024]; int readCount = 0; while((readCount=fin.read(chars))!=-1)&#123; fout.write(chars,0,readCount); &#125; fout.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fin!=null) &#123; try &#123; fin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fout!=null) &#123; try &#123; fout.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BufferedReader带有缓冲区的字符输出流，使用这个流的时候不需要自定义char数组，自带缓冲。我们看一下该流： 1234567891011121314151617181920212223242526272829303132333435public class FileInputStramTest &#123; public static void main(String[] args)&#123; FileReader fin = null; BufferedReader br = null; try &#123; fin = new FileReader("G:/test.txt"); //当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流 //外部负责包装的这个流，叫做：包装流，也叫作：处理流 //像当前这个程序来讲：FileReader就是一个节点流，BufferedReader就是一个包装流 //BufferedReader构造方法只能传参Reader字符流 br = new BufferedReader(fin); //readLine()方法读取一行，String类型，且不读取最后的换行符 //如果没有内容被读取了，该方法将返回null String s = null; while((s = br.readLine())!=null)&#123; System.out.println(s); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流 //对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭 if(br!=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; InputStreamReader转换流 java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。该类读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集，默认跟编译工具或系统的编码方式一样（看是在IDE中运行还是在DOS窗口编译运行），IDE一般使用UTF-8，系统默认的编码为GBK。 注意其和FileReader的区别： InputStreamReader是底层先读取字节，然后通过指定或默认的字符集将其转换为字符流 FileReader直接从文件中读取字符，采用的是文件的编码方式，而不能手动指定 继承自父类的共性成员方法 该类继承于 Reader 类，继承了父类的共性成员方法： 123int read() 读取单个字符并返回。int read(char[] cbuf)一次读取多个字符,将字符读入数组。void close() 关闭该流并释放与之关联的所有资源。 构造方法 1InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader。InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的InputStreamReader。 参数： InputStream in：字节输入流，用来读取文件中保存的字节 String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8 注意：构造方法中指定的编码方式要和文件的编码方式相同,否则会发生乱码 12345678910111213141516171819202122232425262728public class FileInputStramTest &#123; public static void main(String[] args) &#123; FileInputStream fin = null; InputStreamReader in = null; try &#123; fin = new FileInputStream("G:/test1.txt"); in = new InputStreamReader(fin); char[] chars = new char[4]; int readCount = 0; while((readCount=in.read(chars))!=-1)&#123; System.out.print(new String(chars,0,readCount)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //只需要关闭最外层的包装流即可，里面的节点流会自动关闭 if(in!=null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BufferedWriter带有缓冲的字符输出流 123456789101112131415161718public class encode &#123; public static void main(String[] args) throws Exception &#123; //BufferedWriter构造函数中要传入的是一个Writer //第一种 BufferedWriter br1 = new BufferedWriter(new FileWriter("G:/copy.txt")); //第二种 BufferedWriter br2 = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("G:/copy.txt",true))); br1.write("hello"); br1.write("world"); br1.write("\n"); br1.flush(); br2.write("hello"); br2.write("kitty"); br2.flush(); br1.close(); br2.close(); &#125;&#125; 数据专属流 DataOutputStream 这个流可以将数据连同数据类型一并写入文件。注意：这个文件不是普通文本文件（用记事本打不开） 1234567891011121314public class encode &#123; public static void main(String[] args) throws Exception &#123; DataOutputStream dos = new DataOutputStream(new FileOutputStream("G:/data")); byte b = 10; short s = 200; int i = 300; //八中数据类型都有专门的写入方法 dos.writeByte(b); dos.writeShort(s); dos.writeInt(i); dos.flush(); dos.close(); &#125;&#125; 上述代码生成的data文件用记事本打开会出现乱码，因为它不是普通文本文件。这个时候该怎么办呢？就有用到它的好兄弟：DataInputStream DataInputStream DataOutputStream写的文件，只能用DataInputStream去读，并且读的时候需要提前知道写入的顺序。读的顺序要和写的顺序一致，才可以正常取出数据 1234567891011121314151617public class encode &#123; public static void main(String[] args) throws Exception &#123; DataInputStream dos = new DataInputStream(new FileInputStream("G:/data")); byte b = dos.readByte(); short s = dos.readShort(); int i = dos.readInt(); System.out.println(b); System.out.println(s); System.out.println(i); dos.close(); &#125;&#125;/*10200300*/ 标准输出流这里只需要掌握PrintStream就可以了，默认输出到控制台，也可以修改输出方向，叫做重定向 123456789101112131415161718192021public class encode &#123; public static void main(String[] args) throws Exception &#123; //如果想在重定向后再改回默认输出至控制台。需要在最开始保存最原始的输出流 PrintStream out = System.out; //标准输出流不需要手动close关闭 PrintStream ps1 = System.out; ps1.println("hello"); ps1.println("world"); //也可以修改输出方向，后面的System.out.println都将输出至log文件 PrintStream ps2 = new PrintStream(new FileOutputStream("G:/log")); System.setOut(ps2); System.out.println("hello"); System.out.println("kitty"); //重定向后恢复至默认输出控制台 System.setOut(out); System.out.println("case"); &#125;&#125; 有的小伙伴可能要问，这个有啥用？在写日志工具类输出日志的时候会很方便 12345678910111213141516171819202122232425262728293031//Logger.java** * 日志工具类 */public class Logger &#123; public static void log(String msg)&#123; try &#123; //指向一个日志文件 PrintStream ps = new PrintStream(new FileOutputStream("G:/log.txt",true)); //改变输出方向 System.setOut(ps); //日期当前时间 Date nowTime = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS"); String s = sdf.format(nowTime); System.out.println(s+ ":" + msg); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//LogTest.javapublic class LogTest &#123; public static void main(String[] args) &#123; //测试日志工具类是否好用 //此时日志信息就会写入到log.txt文件里 //写入的日志内容为：2020-05-28 11:56:06 948:发生异常 Logger.log("发生异常"); &#125;&#125; File类 File类和四大家族没有关系，它的父类是Object，所以File类不能完成文件的读和写 File对象代表什么？ 代表文件和目录路径名的抽象表示形式 C:\Drivers是一个File对象 C:\Drivers\log.txt也是一个File对象 一个File对象可能对应的是目录，也可能是文件 File类常用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class encode &#123; public static void main(String[] args) throws Exception &#123; //创建一个File对象 File f1 = new File("D:/file"); //判断是否存在，存在返回true，否则发挥false System.out.println(f1.exists()); //如果D:\file不存在，则以文件的形式创建出来 if(!f1.exists()) f1.createNewFile(); //如果D:\file不存在，则以目录的形式创建出来 if(!f1.exists()) f1.mkdir(); //可以创建多重目录 File f2 = new File("G:/A/B/C"); if(!f2.exists()) f2.mkdirs(); File f3 = new File("G:/pytorch/log.txt"); //获取文件的父路径 //第一种方式 String s = f3.getParent(); System.out.println(s); //G:\pytorch //第二种方式 File parentFile = f3.getParentFile(); //获取绝对路径 System.out.println(parentFile.getAbsolutePath());//G:\pytorch //获取当前文件名或目录名 File f4 = new File("G:/pytorch/A/b/c"); System.out.println(f4.getName()); //log.txt //判断是否是一个目录 System.out.println(f4.isDirectory());//false //判断是否是一个文件 System.out.println(f4.isFile());//true //获取文件最后一次修改时间,返回的是long，毫秒值，从1970到修改时间的毫秒数 long m = f4.lastModified(); Date time = new Date(m); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS"); String str = sdf.format(time); System.out.println(str); //获取文件大小,返回字节数 System.out.println(f4.length()); //获取当前目录下所有子文件或子目录 File f5 = new File("G:/pytorch"); File[] files = f5.listFiles(); for(File file:files)&#123; System.out.println(file.getAbsolutePath()); &#125; &#125;&#125; 下面讲一个目录拷贝的例子：把一个目录中的全部内容拷贝到另一个目录中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class encode &#123; public static void main(String[] args) throws Exception &#123; //拷贝源 File srcFile = new File("G:/pytorch"); //拷贝目标 File destFile = new File("F:/"); copyDir(srcFile,destFile); &#125; //拷贝方法 private static void copyDir(File srcFile, File destFile) &#123; if(srcFile.isFile())&#123; //srcFile如果是一个文件，递归结束 FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream(srcFile.getAbsolutePath()); String path = (destFile.getAbsolutePath().endsWith("\\") ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + "\\") + srcFile.getAbsolutePath().substring(3); out = new FileOutputStream(path); byte[] bytes = new byte[1024*1024]; int readCount = 0; while((readCount=in.read(bytes))!=-1)&#123; out.write(bytes,0,readCount); &#125; out.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(in!=null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(out!=null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return; &#125; File[] files = srcFile.listFiles(); //file可能是文件，也可能是目录 for(File file:files)&#123; //建立目标目录 if(file.isDirectory())&#123; String srcDir = file.getAbsolutePath(); String destDir = (destFile.getAbsolutePath().endsWith("\\") ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + "\\") + srcDir.substring(3); File newFile = new File(destDir); if(!newFile.exists()) newFile.mkdirs(); &#125; copyDir(file,destFile); &#125; &#125;&#125; 对象流序列化（Serialize）：内存中的java对象存储到文件中，将java对象的状态保存下来的过程，用ObjectOutputStream实现 反序列化（DeSerialize）：将硬盘上的数据重新恢复到内存中，恢复成java对象，用ObjectInputStream实现 序列化的实现 1234567891011121314151617181920212223242526272829303132//Student.javapublic class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125;//SerializeTest.javapublic class SerializeTest &#123; public static void main(String[] args) throws Exception&#123; //创建java对象 Student s = new Student("zhangsan",20); //序列化,ObjectOutputStream是一个包装流，参数要求是一个OutputStream对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students")); //序列化对象 oos.writeObject(s); oos.flush(); oos.close(); &#125;&#125; 注意：参与序列化和反序列化的对象必须实现Serializable接口，否则会出现异常：java.io.NotSerializableException Serializable接口是一个标志接口（内部什么都没有！！）那么它有什么用呢？起到标志的作用，这个接口是给java虚拟机参考的，java虚拟机看到这个接口后，会为该类自动生成一个序列化版本号。 反序列化实现 123456789public class DeSerializeTest &#123; public static void main(String[] args) throws Exception&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("students")); //Student对象 Object o = ois.readObject(); System.out.println(o); ois.close(); &#125;&#125; 一次序列化多个对象 可以将对象放到集合当中，序列化集合 12345678910111213141516171819public class SerializeTest &#123; public static void main(String[] args) throws Exception&#123; //创建java对象 Student s1 = new Student("zhangsan",20); Student s2 = new Student("lisi",23); Student s3 = new Student("wangwu",11); List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(s1); list.add(s2); list.add(s3); //序列化 //参与序列化的ArrayLis以及集合中的元素都需要实现Serializable接口 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students")); //序列化对象 oos.writeObject(list); oos.flush(); oos.close(); &#125;&#125; 反序列化集合 1234567891011121314151617181920public class DeSerializeTest &#123; public static void main(String[] args) throws Exception&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("students")); //返回的对象是一个List集合 Object o = ois.readObject(); //System.out.println(o instanceof List);//true //强转 List&lt;Student&gt; lists = (List&lt;Student&gt;)o; for(Student list:lists)&#123; System.out.println(list); &#125; ois.close(); &#125;&#125;/*Student&#123;name='zhangsan', age=20&#125;Student&#123;name='lisi', age=23&#125;Student&#123;name='wangwu', age=11&#125;*/ transient关键字如果有些属性不想被序列化怎么办？用Transient修饰 123456789101112131415161718public class Student implements Serializable &#123; //transient表示游离的，不参与序列化 private transient String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 上述Student类的name被transient修饰，则不会被序列化。我们序列化之后，再反序列化，可以看到输出结果如下： 1234//对象的name属性全部为nullStudent&#123;name='null', age=20&#125;Student&#123;name='null', age=23&#125;Student&#123;name='null', age=11&#125; 序列化版本号序列化版本号有什么用？ 曾经写了一个类，并且将该类的对象序列化到文件中。过年之后，这个类的源代码被修改了，此时需要重新编译，编译之后就生成了全新的字节码文件，并且字节码文件再次运行的时候，java虚拟机生成的序列化版本号也会发生相应的改变。 此时，如果直接反序列化当年的文件，会出现如下的异常： 1234java.io.InvalidClassException: com.bit.auto.Student; local class incompatible: stream classdesc serialVersionUID = 280454362619280233(现在的序列化版本号) local class serialVersionUID = -9192231206928936373(当年的序列化版本号) 必须重新进行序列化，才会消除上述异常 这种自动生成序列化版本号有什么缺陷？ 一旦代码确定之后，不能进行后续的修改。因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候JVM会认为这是一个全新的类 最终结论：凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。这样，以后这个类即使代码修改了，但是版本号不变，JVM会认为是同一个类 123456789101112131415161718192021public class Student implements Serializable &#123; //手动指定的序列化版本号 public static final long serialVersionUID = 1L; //transient表示游离的，不参与序列化 private transient String name; private int age; int no; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 可以用IntelliJ IDEA生成序列化版本号： File -&gt; Settings -&gt; Inspections -&gt; Serializable class without serialVersionUID打上对勾，然后当该类实现了Serializable接口时，将光标放在类名上，然后Alt+Enter，可以生成序列化版本号 IO和Properties联合使用Properties是一个Map集合，key和value都是String类型，想将文件copy.txt中的数据加载到Properties中. copy.txt文件中的内容如下所示： 12username=adminpassword=123 如何加载？ 1234567891011121314151617public class rt &#123; public static void main(String[] args) throws Exception&#123; //新建一个输入流对象 FileInputStream in = new FileInputStream("G:/copy.txt"); //新建一个Properties集合 Properties pro = new Properties(); //调用Properties对象的load方法将文件中的数据加载到Map集合中 //文件中的数据顺着管道加载到Map集合中 //等号左边做key，等号右边做value pro.load(in); //等号key获取value String v = pro.getProperty("username"); System.out.println(v); //admin in.close(); &#125;&#125; 这是非常好的一个设计理念！ 以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启，就可以拿到动态的信息 类似于以上机制的这种文件，被称为配置文件。并且当配置文件中的内容格式是：key=value的时候（等号两边最好不要用空格），我们把这种配置文件叫做属性配置文件。 java中规定：属性配置文件建议以.properties结尾，但这不是必须的。其中Properties对象是专门存放属性配置文件内容的一个类。属性配置文件中万一key重复怎么办：value覆盖 属性配置文件中#开头是注释]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2020%2F05%2F14%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[什么是集合数组其实就是一个集合。集合实际上就是一个容器，可以来容纳其它类型的数据。 集合是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库中有10条记录。那么假设把这10个记录查询出来，在java程序当中会将这10条记录封装成10个java对象，然后将10个对象放到某一个集合当中，将集合传到前端，然后遍历集合，将数据一个一个展现出来 集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址（引用）。集合在java中本身是一个容器，是一个对象，集合中任何时候存储的都是引用（数组可以存储基本数据类型） 在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合当中存储元素，等于将数据放到了不同的数据结构当中。 集合在JDK中哪个包下？ java.util.* 数组和集合的比较数组不是面向对象的，存在明显的缺陷，集合弥补了数组的缺点，比数组更灵活更实用，而且不同的集合框架类可适用不同场合。如下： 数组能存放基本数据类型和对象，而集合类存放的都是对象，集合类不能存放基本数据类型。数组和集合存放的对象皆为对象的引用地址。 数组容易固定无法动态改变，集合类容量动态改变。 数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数 集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率 集合的继承关系在java中集合分为两类： 单个方式存储元素 这一类集合的超级父接口：java.util.Collection 继承关系如下： 以键值对的方式存储元素 这一类集合的超级父接口：java.util.Map 继承关系如下： 总结：（所有的实现类）： ArrayList：底层是数组。 LinkedList：底层是双向链表。 Vector：底层是数组，线程安全的，效率较低，使用较少。 HashSet：底层是HashMap，放到HashSet集合中的元素等同于放到HashMap集合key部分了。 TreeSet：底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合key部分了。 HashMap:底层是哈希表。 Hashtable：底层也是哈希表，只不过线程安全的，效率较低，使用较少。 Properties：继承于HashTable，是线程安全的，并且key和value只能存储字符串String。 TreeMap：底层是二叉树。TreeMap集合的key可以自动按照大小顺序排序。 List集合存储元素的特点：有序可重复 有序：存进去的顺序和取出的顺序相同，每一个元素都有下标。（先放1，就先取出1） 可重复：存进去1，可以再存储一个1. Set（Map）集合存储元素的特点：无序不可重复 无序：存进去的顺序和取出的顺序不一定相同。另外Set集合中元素没有下标。 不可重复：存进去1，不能再存储1了。 Map集合的key，就是一个Set集合。 往Set集合中放数据，实际上放到了Map集合的key部分。 SortedSet（SortedMap）集合存储元素特点：首先是无序不可重复的，但是SortedSet集合中的元素是可排序的。 无序：存进去的顺序和取出的顺序不一定相同。另外Set集合中元素没有下标。 不可重复：存进去1，不能再存储1了。 可排序：可以按照大小顺序排列（注意和List中有序的区别，前面的有序指的是存入顺序和取出顺序一致）。 Collection接口常用方法Collection中可以存放什么类型的元素？ 没有使用“泛型”之前，Collection中可以存放Object的所有子类型 使用“泛型”之后，Collection中只能存储某个具体的类型 常用方法： boolean add(Object e)：向集合中添加元素 1234567public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); //自动装箱，集合中只能放对象的内存地址 c.add(200); &#125;&#125; int size()：获取集合中元素的个数 12345678public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); //自动装箱，集合中只能放对象的内存地址 c.add(200); System.out.println(c.size()); //2 &#125;&#125; void clear()：清空集合 123456789public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); //自动装箱，集合中只能放对象的内存地址 c.add(200); c.clear(); System.out.println(c.size());//0 &#125;&#125; boolean contains(Object o)：判断当前集合中是否包含对象o。包含返回true，不包含返回false 12345678910111213public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); //自动装箱，集合中只能放对象的内存地址 c.add(200); boolean flag = c.contains(100); System.out.println(flag);//true boolean flag = c.contains(300); System.out.println(flag);//false &#125;&#125; contains方法在底层怎么判断是否包含某个元素？ 对集合内的元素依次遍历，依次针对数组中的元素调用对象o的equals()方法。如果有相等的就返回true，否则返回false boolean remove(Object o)：删除某个元素。注意：删除的时候会调用o的equals方法判断是否相等，以判断删除哪一个 123456789public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); //自动装箱，集合中只能放对象的内存地址 c.add(200); c.remove(100); System.out.println(c.size());//1 &#125;&#125; boolean isEmpty()：判断集合是否为空 Object[] toArray()：集合转换成数组（使用不多） 1234567891011public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); c.add(200); c.add(new Object()); Object[] objs = c.toArray(); System.out.println(Arrays.toString(objs)); //[100, 200, java.lang.Object@b4c966a] &#125; Collection集合迭代所有Collection的集合通用，Map中不能用 可以认为初始迭代器指向第一个元素前一个位置，即-1。调用next方法可以使其一位一位的后移 Iterator接口有三个方法： boolean hasNext()：如果仍有元素可以迭代，返回true；否则返回false Object next()：迭代器前进一位，并且返回当前指向的元素。注意：默认返回值类型是Object void remove()：从迭代器指向的collection中移除迭代器返回的最后一个元素，即删除的一定是迭代器指向的当前元素 123456789101112131415161718public class Array extends MyStack&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add(100); c.add(200); c.add("abc"); //对集合Collection进行迭代/遍历 //第一步：获取集合对象的迭代器对象 //iterator()方法实际上是返回了一个对象，该对象是实现了Iterator接口中所有方法的类的对象，即返回了一个Iterator接口实现类的对象。 Iterator it = c.iterator(); //第二步：通过以上获取的迭代器对象开始遍历集合 while(it.hasNext())&#123; System.out.print(it.next() + " "); &#125; //100 200 abc &#125;&#125; 迭代器的使用步骤(重点): 使用集合中的方法 iterator()获取送代器的实现类对象,使用Iterator接口接收(多态) 使用Iterator接口中的方法hasNext来判断还有没有下一个元素 使用Iterator接口中的方法next来取出集合中的下一个元素 注意：集合结构只要发生改变，迭代器必须重新获取！！否则调用next()方法时会出现异常：java.util.ConcurrentModificationException 重点：在迭代集合元素的过程中，不能调用集合对象的remove方法删除元素，否则会出现上述异常，因为集合结构变了，但是没有重新获取迭代器。因为迭代器对象相当于是对当前集合的的状态拍了一个快照，迭代器迭代的时候会对这个快照进行迭代，同时对比集合中的元素状态，如果不一致就报错。如果调用集合对象的remove，会删除集合中的元素，但是迭代器快照没有更新，会导致迭代器快照和集合状态不一致。但是调用迭代器对象的remove方法就没事，是因为这个方法会同时删除快照中的元素和集合中的元素，使其保持一致 所以：在迭代元素的过程中，一定要使用迭代器iterator 的remove方法删除元素 List接口特有方法List接口是Collection的子接口，肯定有自己特有的方法。以下只列出List特有的常用的方法 void add(int index, Object element)：指定位置插入元素（使用不高，因为效率低）。add（Object element）是向末尾添加元素 123456public class Array extends MyStack&#123; public static void main(String[] args)&#123; List l = new ArrayList(); l.add(1,100); &#125; Object get(int index)：根据下标获取元素（只有List才有下标，因为有序可重复，set没有） 12345678910111213141516public class Array extends MyStack&#123; public static void main(String[] args)&#123; List l = new ArrayList(); l.add(1); l.add(2); // 根据下标获取元素 Object obj = l.get(0); System.out.println(obj); //因为有下标，所以List集合有自己比较特殊的遍历方式 //通过下标遍(List集合特有，set没有) for(int i=0;i&lt;l.size();i++)&#123; System.out.println(l.get(i)); &#125; &#125; int indexOf(Object o)：获取指定对象第一次出现处的索引。同理lastIndexOf(Object o)返回指定对象最后一次出现的索引 1234567public class Array extends MyStack&#123; public static void main(String[] args)&#123; List l = new ArrayList(); l.add(1); l.add(2); System.out.println(l.indexOf(2));//1 &#125; Object remove(int index)：删除指定位置的元素 Object set(int index, Object element)：修改指定位置的元素 ArrayList 底层是Object类型数组，初始化容量是10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量是10）。做这样的改动，就是延迟初始化ArrayList的实际容量，应该是考虑到空间的问题，如果一开始就初始化为10，这个大小为10的数组中就全部是存的null，如果数量多了，这个也是很大的空间。应该是这样的原因吧（懒加载机制）。 可以指定初始化容量：List l = new ArrayList(20); ArrayList是非线程安全的 ArrayList会自动扩容，每次会增长为原数组容量的1.5倍（详情见源码） ArrayList如何优化？尽可能少的扩容，建议预估计元素个数，给定一个初始化的容量 ArrayList用的是最多的，因为底层是数组的数据结构，内存空间地址连续，所以检索效率较高。 ArrayList构造方法（3种）： 默认初始容量 指定初始容量 参数是一个集合（注意：Collection集合之间的互相转换通过这种构造方法的形式就可以实现，但是Collection集合和Map集合不能通过这种互相转换，Map可以通过keySet、entrySet等方法转换为Set集合） 12345Collection c = new HashSet();c.add(1);c.add(2);//通过这个方法将hashset集合转换成List集合。注意参数只能是Collection集合，不能是MapList l = new ArrayList(c) 怎么将一个线程不安全的ArrayList集合转换成线程安全的？ 使用集合工具类：java.util.Collections 1234567List list = new ArrayList(); // 非线程安全//变成线程安全的Collections.synchronizedList(list);//现在list就是线程安全的了list.add("1");list.add("2");list.add("3"); LinkedList 底层数据结构是双向链表 多看源码（源码中采用尾插法插入数据） 源码中有一个first成员结点和一个last成员结点，first始终指向双向链表的头结点，last始终指向双向链表的尾节点。最初，first和last引用都是null 随机增删效率较高，检索效率较低 在空间存储上，内存地址不连续 Vector 底层是数组 初始化容量是10（现在ArrayList初始化容量是0，只有插入第一个元素时，才会变成10） 怎么扩容？ 扩容后的容量是原容量的二倍 Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率低，使用较少 泛型 JDK5.0之后的新特性 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的（运行阶段泛型没用） 使用泛型的好处 集合中存储的元素类型统一了 从集合中去除的元素类型是泛型指定的类型，不需要进行大量的向下转型 泛型的缺点 导致集合存储的元素缺乏多样性 大多数业务中，集合中元素的类型还是统一的，所以这种泛型特性被大家所认可 不使用泛型的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class test01&#123; public static void main(String[] args)&#123; List list = new ArrayList(); Cat c = new Cat(); Bird b = new Bird(); list.add(c); list.add(b); Iterator it = list.iterator(); while(it.hasNext())&#123; Object obj = it.next(); if(obj instanceof Animal)&#123; Animal a = (Animal)obj; a.move(); &#125; &#125; &#125;&#125;/*输出结果： 动物在移动！ 动物在移动！*/class Animal&#123; public void move()&#123; System.out.println("动物在移动！"); &#125;&#125;class Cat extends Animal &#123; //Cat类特有方法 public void catchMouse()&#123; System.out.println("猫在抓老鼠！"); &#125;&#125;class Bird extends Animal &#123; //Bird类特有方法 public void fly()&#123; System.out.println("鸟儿在飞翔！"); &#125;&#125; 下面使用泛型：（注意泛型的用法） 123456789101112131415161718192021222324252627282930313233343536373839public class test01&#123; public static void main(String[] args)&#123; //使用泛型List&lt;Animal&gt;后，表示List集合只允许存储Animal类型的数据 //用泛型来制定集合中存储的数据类型 List&lt;Animal&gt; list = new ArrayList&lt;Animal&gt;(); Cat c = new Cat(); Bird b = new Bird(); //list.add("abc"); 报错 list.add(c); list.add(b); //这个表示迭代器迭代的是Animal类型 //next()方法返回的类型不再是Object，而是Animal Iterator&lt;Animal&gt; it = list.iterator(); while(it.hasNext())&#123; Animal obj = it.next(); obj.move(); //如果想使用Cat、Bird类的特有方法，还是需要向下转型 &#125; &#125;&#125;class Animal&#123; public void move()&#123; System.out.println("动物在移动！"); &#125;&#125;class Cat extends Animal &#123; public void catchMouse()&#123; System.out.println("猫在抓老鼠！"); &#125;&#125;class Bird extends Animal &#123; public void fly()&#123; System.out.println("鸟儿在飞翔！"); &#125;&#125; JDK8之后引入了自动类型推断，也成为了钻石表达式： 123//后面的ArrayList尖括号里面可以不写，类型会自动推断//前提是JDK8之后List&lt;Animal&gt; list = new ArrayList&lt;&gt;(); 自定义类泛型 123456789101112public class Generic&lt;E&gt; &#123; //这里如果用E，那么该类中的所有泛型都要用E，保持一致（也可以用任意标识符，一般用E或T） public void doSome(E e)&#123; System.out.println(e); &#125; public static void main(String[] args)&#123; Generic&lt;String&gt; g = new Generic&lt;&gt;(); g.doSome("abc"); // abc //类型不匹配 g.doSome(100); &#125;&#125; 自定义泛型的时候，尖括号里面是标识符，随便写 如果定义类时用了泛型，但是在创建对象时没有使用泛型，那么泛型默认变成Object类型。比如上面的doSome()方法，需要传入的参数是Object类型。不用泛型的意思为 1Generic g = new Generic(); 集合遍历总结主要有三种方式： 迭代器 for循序：只针对有下标的集合（List接口下的子类，如ArrayList） 1234567891011public class test01&#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; for each循环：没有下标的集合也能用 1234567891011public class test01&#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); for(String s:list)&#123; System.out.println(s); &#125; &#125;&#125; HashSet 无序不可重复，放到HashSet集合中的元素实际上是放到HashMap集合中的key部分了 1234567891011121314151617181920public class test01&#123; public static void main(String[] args)&#123; Set&lt;String&gt; s = new HashSet&lt;&gt;(); s.add("a3"); s.add("a4"); s.add("a1"); s.add("a2"); s.add("a1"); s.add("a3"); for(String q:s)&#123; System.out.println(q); &#125; &#125;&#125;/*a1a2 a3a4*/ 由于底层数据结构和HashMap一样，所以初始化容量也是16，扩容是原容量的2倍 TreeSet 无序不可重复，无序指存入顺序和取出顺序不一致 但是存储的元素可以自动按照大小顺序排序，称为可排序集合 底层是一个TreeMap，TreeMap底层是一个二叉树 Map接口常用方法 Map和Collection没有继承关系 Map集合以key和value的方式存储数据：键值对。key和value都是引用数据类型，key和value都是存储对象的内存地址。key起到主导地位，value是key的附属品 常用方法： V put(K key, V value)：向Map集合中添加键值对 12345678910public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); System.out.println(map.size()); //4 &#125;&#125; void clear()：清空map集合 boolean containsKey(Object key)：判断Map中是否包含某个key。底层调用equals方法比对，所以自定义的类需要重写equals 12345678910111213public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); boolean flag = map.containsKey(1); System.out.println(flag);//true boolean flag = map.containsKey(6); System.out.println(flag);//false &#125;&#125; boolean containsValue(Object value)：判断Map中是否包含某个value，底层调用equals方法比对 1234567891011public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); boolean flag = map.containsValue("a"); System.out.println(flag);//true &#125;&#125; V get(Object key)：通过key获取value 1234567891011public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); String s = map.get(1); System.out.println(s); //a &#125;&#125; boolean isEmpty()：判断Map集合是否为空 1234567891011public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); boolean flag = map.isEmpty(); System.out.println(flag);//false &#125;&#125; Set&lt; K &gt; keySet()：获取Map集合所有的key （所有的键是一个set集合） 12345678910111213141516171819public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); Set&lt;Integer&gt; key = map.keySet(); for(Integer n:key)&#123; System.out.println(n); &#125; &#125;&#125;/*1234*/ V remove(Object key)：通过key删除键值对 123456789101112public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); System.out.println(map.size()); //4 map.remove(1); System.out.println(map.size()); //3 &#125;&#125; int size()：获取Map集合中键值对的个数 Collections&lt; V &gt; values()：获取Map集合中所有的value，返回一个collection 12345678910111213141516171819public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); Collection&lt;String&gt; values = map.values(); for(String s:values)&#123; System.out.println(s); &#125; &#125;&#125;/*abcd*/ Set&lt; Map.Entry &lt; K,V &gt; &gt; entrySet()：将Map集合转换成Set集合。Set集合中元素的类型是Map.Entry&lt; K,V &gt;，是Map中的静态内部类。Map.Entry&lt; K,V &gt;有key属性和value属性，还有getKey()和getValue()方法以获取Map.Entry&lt; K,V &gt;对象的key和value。实际上转换成的Set集合中存储的是一个一个的Map.Entry&lt; K,V &gt;对象。举个例子 Map集合对象： ​ key value ​ 1 zhang ​ 2 li ​ 3 wang 转换成的Set集合对象为： 1=zhang 2=li 3=wang Map集合遍历： 第一种方式：获取所有的key，通过key，来遍历value。遍历key既可以用迭代器，也可以用for each 123456789101112131415161718192021public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); Set&lt;Integer&gt; key = map.keySet(); Iterator&lt;Integer&gt; it = key.iterator(); //用迭代器 while(it.hasNext())&#123; Integer k = it.next(); String value = map.get(k); System.out.println(value); &#125; //用for each for(Integer k : key)&#123; System.out.println(map.get(k)); &#125; &#125;&#125; 第二种方式：使用Set&lt; Map.Entry&lt; K,V &gt; &gt; entrySet()方法，把Map集合直接转换成Set集合，Set集合中的元素类型是Map.Entry。这种遍历方式效率高，适用于大数据量 1234567891011121314151617181920212223public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; node = it.next(); Integer key = node.getKey(); String value = node.getValue(); System.out.println(key + " : " + value); &#125; &#125;&#125;/*1 : a2 : b3 : c4 : d*/ 第三种方式：JDK8之后还有一种更简洁的遍历方式，这种方法便捷，而且效率也高 123456789101112131415161718public class test01&#123; public static void main(String[] args)&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"a"); map.put(2,"b"); map.put(3,"c"); map.put(4,"d"); map.forEach((key,value)-&gt;&#123; System.out.println(key + "--&gt;"+value); &#125;); &#125;&#125;/*1--&gt;a2--&gt;b3--&gt;c4--&gt;d*/ HashMap 底层是哈希表数据结构 哈希表是一个数组和单向链表的结合体，充分发挥了各自的优点，所以哈希表的随机增删和查询的效率都较高，但是没有纯数组查询效率高，也没有链表的随机增删性能高，它是一种中和。大致如图所示 左边是一维数组，每个数组元素是一个单向链表 HashMap集合底层的源代码： 12345678910111213public class HashMap&#123; //HashMap底层实际上是一个数组（一维数组） Node&lt;K,V&gt;[] table; //静态内部类HashMap.Node static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//哈希值(哈希值是key的hashCode()方法的执行结果，hash值通过哈希函数/算法可以转换成数组的下标) final K key;//存储到Map集合的key V value;//存储到Map集合中的value Node&lt;K,V&gt; next;//下一个节点的内存地址 &#125; //哈希表：一维数组，这个数组中的每一个元素是一个单向链表&#125; HashMap集合的默认初始化容量是16，默认加载因子是0.75。这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。重点：HashMap集合初始化容量必须是2的幂次方，这是因为达到散列均匀，为了提高HashMap集合的存储效率所必须的 HashMap数组扩容：新容量是原容量的二倍 HashMap的key可以为null，但是只允许有一个，如果再来存储一个key为null的节点，那么value值会被覆盖 重点掌握：map.put(K k,V v)和map.get(K k)实现原理 map.put(K k,V v)实现原理： 第一步：先将k，v封装到Node对象当中 第二步：底层会调用k的hashCode()方法得出hash值，然后通过哈希算法/函数，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把该Node添加到这个位置上。如果下标对应的位置上有链表，此时会拿着k和链表上的每一个结点中的k进行equals，如果所有的equals方法都返回false，那么将这个新结点将被添加到链表的末尾；如果其中有一个equals返回了true，那么这个结点的value将会被覆盖 map.get(K k)实现原理： 先调用k的hashCode()方法得出k的哈希值，通过哈希算法转换成数组下标，通过数组下标快速定位到某个位置上，如果这个位置上什么也没有，返回null；如果这个位置上有单向链表，那么会拿着参数k和单向链表上的每个节点中的k进行equals，如果所有的equals方法都返回false，那么get方法返回null；只要其中有一个节点的k和参数k的equals的结果是true，那么此时这个结点的value就是我们要的value，get方法最终返回这个要找的value 重点：当key是自定义类时，HashMap集合的key，会先后调用两个方法，一个是hashCode()，一个是equals()，那么这两个方法都需要同时重写 HashMap的key为什么无序不可重复？ 无序：因为不一定挂到哪个单链表上 不可重复：equals方法保证HashMap的key不可重复。因为key重复了，value会覆盖 注意：同一个链表上的所有节点的hash值相同，因为它们的数组下标相同。但同一个链表上的k都不相同 如果重写hashCode方法时返回一个固定值，那么就变成了一个单向链表，无法发挥其性能！！这种情况称为：散列分布不均匀 如果所有的hashCode方法返回值都设定为不一样的值，那么就变成了一个一维数组，也是散列分布不均匀，丧失链表特性 散列分布均匀需要在重写hashCode方法有一定的技巧 重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素如果是自定义类型时，需要同时重写hashCode和equals方法（终极结论！！！） hashCode()方法和equals()方法不用研究了，直接用IDEA工具生成，但是这两个方法需要同时生成！！！快捷键：Alt+Insert JDK8对HashMap的改进：如果哈希表单向链表中元素超过8个，单向链表会变成红黑树数据结构。当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表，这样是为了提高检索效率 注意：同一个单向链表上的结点的hash值可能不一样，因为可能存在哈希冲突。哈希冲突：不同的hash值通过哈希算法转换的数组下标相同。但是如果hash值一样的话，那么一定是放到同一个单向链表上 HashTable 是线程安全的，所有的方法都带有synchronized 底层也是哈希表 和HashMap有区别，HashTable的key和value都不能为空，否则在put的时候会报空指针异常 默认初始化容量是11，默认加载因子是0.75 扩容：新容量 = (旧容量*2) + 1 用的较少，因为线程安全有别的更好的方式 Properties 是一个Map集合，继承于HashTable，key和value都是String类型，被称为属性类对象 是线程安全的 需要掌握两个方法： 存：setProperty(String key, String value)，底层调用的是put方法 123public synchronized Object setProperty(String key, String value) &#123; return put(key, value); &#125; 取：getProperty(String key) 举个例子： 123Properties pro = new Properties();pro.setProperty("1","li");System.out.println(pro.getProperty("1")); //li 因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 get方法。但强烈反对使用这两个方法，因为它们允许调用方插入其键或值不是 String 的项。相反，应该使用 setProperty 方法和getProperty方法。 TreeMap 底层是一个二叉树 放到TreeMap集合中的元素，是按照key排序的，升序，称为可排序集合 TreeSet/TreeMap采用的是中序遍历 自定义类不能放入到TreeMap中，因为没有实现Compareable接口，TreeMap是要进行key比较的，自定义类无法进行比较。如果实现了Comparable接口之后，就可以放进去了。举个例子：由于TreeSet就是TreeMap的key部分，是需要排序的，所以我们这里以TreeSet进行演示 123456789101112131415161718192021222324ublic class Test&#123; public static void main(String[] args) &#123; Per p1 = new Per(20); Per p2 = new Per(32); Per p3 = new Per(16); Per p4 = new Per(41); TreeSet&lt;Per&gt; set = new TreeSet&lt;&gt;(); //这里会报错，因为没有实现Comparable接口 //而在TreeMap源码里面排序时要将其转换成Comparable接口类型的 //Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; set.add(p1); set.add(p2); set.add(p3); set.add(p4); &#125;&#125;class Per&#123; int age; public Per(int age) &#123; this.age = age; &#125;&#125; 自定义类实现Comparable接口 12345678910111213141516171819202122class Per implements Comparable&lt;Per&gt;&#123; int age; public Per(int age) &#123; this.age = age; &#125; //需要在这个方法中编写比较的逻辑 //返回值可能是大于0、小于0或等于0 //比较规则最终是由程序员指定的：例如按照年龄升序，或者降序 @Override public int compareTo(Per o) &#123; return this.age - o.age; //大于0则表示t插入的时候his指向的对象大于o指向的对象 &#125;&#125;//如何指定升序还是降序？//int result = obj1.compareTo(obj2);//如果result &gt; 0，则是升序；如果result &lt; 0，则是降序//总结：// 升序写法为：return this.age - o.age;// 降序写法为：return o.age - this.age; 当自定义类按上述方式实现Comparable接口后，再放入到TreeSet或TreeMap集合中就不会报错了。那为什么其它基本类型可以直接使用呢？因为它们都实现了Comparable接口 比较规则怎么写：完全自定义，根据项目需求 12345678910111213141516171819class Per implements Comparable&lt;Per&gt;&#123; int age; String name; public Per(int age, String name) &#123; this.age = age; this.name = name; &#125; //比较规则：先按照年龄从小到大排序，年龄相同时按照名字从小到大排序 @Override public int compareTo(Per o) &#123; if(this.age == o.age)&#123; return this.name.compareTo(o.name); &#125;else&#123; return this.age - o.age; &#125; &#125;&#125; comparaTo方法的返回值很重要： 返回0表示相同，value会覆盖 返回&gt;0，会继续在右子树上找 返回&lt;0，会继续在左子树上找 要想排序，不止实现Comparable接口这种方式。还可以利用实现比较器Comparator来进行比较： 12345678910111213141516171819202122232425262728293031323334353637public class Test&#123; public static void main(String[] args) &#123; R p1 = new R(20); R p2 = new R(16); R p3 = new R(16); R p4 = new R(41); //这里需要new一个比较器作为构造方法参数传入到TreeSet中 TreeSet&lt;R&gt; set = new TreeSet&lt;&gt;(new R_Comparator()); set.add(p1); set.add(p2); set.add(p3); set.add(p4); for(R r : set)&#123; System.out.println(r); &#125; &#125;&#125;//单独实现一个比较器//比较器实现java.util.Comparator接口//Comparable是java.lang包下的，Comparator是java.util包下的class R_Comparator implements Comparator&lt;R&gt;&#123; @Override public int compare(R o1, R o2) &#123; return o1.age - o2.age; &#125;&#125;class R&#123; int age; public R(int age) &#123; this.age = age; &#125;&#125; 注意：也可以不用实现比较器，利用匿名内部类 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args) &#123; R p1 = new R(20); R p2 = new R(16); R p3 = new R(16); R p4 = new R(41); TreeSet&lt;R&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;R&gt;()&#123; @Override public int compare(R o1, R o2) &#123; return o1.age-o2.age; &#125; &#125;); set.add(p1); set.add(p2); set.add(p3); set.add(p4); for(R r : set)&#123; System.out.println(r); &#125; &#125;&#125; 总结： 放到TreeSet或者TreeMap集合key部分的元素要想做到排序，包括两种方式： 第一种：放到集合中的元素实现java.lang.Comparable接口 第二种：在构造TreeSet或TreeMap集合的时候给它传一个比较器对象 如何选择上述哪种方式？ 当比较规则不会发生改变的时候，建议实现Comparable接口 如果有多个比较规则，并且需要频繁切换，建议使用Comparator接口 集合工具类java.util.Collections 常用方法如下所示： 线程安全 排序 12345678910111213141516171819202122232425262728293031public class CollectionsTest &#123; public static void main(String[] args) &#123; //ArrayList不是线程安全的 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //变成线程安全的 Collections.synchronizedList(list); //排序 //注意：对List集合元素排序，如果集合中的元素是自定义类型，需要实现Comparable接口 //也可以使用Comparator接口：sort(List集合,Comparator对象) //sort方法只能对List集合排序 list.add("abc"); list.add("abx"); list.add("abe"); Collections.sort(list); for(String s : list) System.out.println(s); //Set集合怎么排序？ //将Set集合转换为List集合即可 Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("king"); set.add("aba"); set.add("abd"); List&lt;String&gt; myList = new ArrayList&lt;&gt;(set); Collections.sort(myList); for(String s: myList) System.out.println(s); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2020%2F05%2F10%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[什么是异常？123456789public class Array &#123; public static void main(String[] args)&#123; int a = 10; int b = 0; // Exception in thread "main" java.lang.ArithmeticException: / by zero int c = a/b; System.out.println(a + "/" + b + "=" + c); &#125;&#125; 以上程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常 java语言提供了异常的处理方法，把异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对程序进行修改，让程序更加的健壮 异常的存在形式异常在Java中以类的形式存在，每一个异常类都可以创建对象 12345678910public class Array &#123; public static void main(String[] args)&#123; int a = 10; int b = 0; //实际上JVM在运行到这里的时候，会new异常对象(隐式的，我们看不见)，并且JVM会将该异常抛出 //new ArithmeticException("/ by zero") int c = a/b; System.out.println(a + "/" + b + "=" + c); &#125;&#125; 我们也可以自己创建个异常对象看看： 1234567public class Array &#123; public static void main(String[] args)&#123; NullPointerException npe = new NullPointerException("空指针异常"); // java.lang.NullPointerException: 空指针异常 System.out.println(npe); &#125;&#125; 异常的继承结构继承结构以UML图的形式展示： 上图的异常类并不完全，只是展示了某一部分 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出） Throwable 有两个重要的子类：错误和异常，二者都是 Java 异常处理的重要子类，各自都包含大量子类。不算是错误还是异常，都是可抛出的 Exception分类两大类：RuntimeException及其子类、Exception的直接子类 所有的RuntimeException及子类都属于运行时异常；其余所有的Exception直接子类都属于编译时异常 所有的异常都发生在运行阶段，因为异常的发生就是new异常对象。千万不要认为编译时异常发生在编译阶段，它得名“编译时异常”是因为必须对该异常进行处理，如果不处理会编译报错 编译时异常：又被称为受检异常，一般发生的概率比较高，表示必须在编写程序的时候预先对这种异常进行处理，如果不处理编译器会报错。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 举个例子：看到外面下雨了，出门之前会预料到如果不打伞，可能会生病（生病是一种异常），而且这个异常发生的概率很高，所以出门之前要带一把伞。“带一把伞”是对“生病异常”发生之前的一种处理方式。对于一些发生概率较高的异常，需要在运行之前对其进行预处理 运行时异常：又被称为未受检异常，一般发生的概率较低，在编写程序阶段可以选择处理，也可以选择不处理，这些异常一般是由程序逻辑错误引起的。运行时异常的特点是Java编译器不会检查它。出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层 举个例子：小明走在大街上，可能会被陨石砸到，被陨石砸到是一种异常。但是这种异常发生概率较低，在出门之前没必要提前对这种发生概率较低的异常进行预处理 假设没有编译时异常和运行时异常的区分，会怎么样？ 所有的异常都需要在编写程序阶段进行预处理，首先这样会很安全，但是太累了，代码里到处都是处理异常的代码 两种异常处理方式 在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁，抛给调用者。注意：异常发生后，如果一直上抛，抛给了main方法；main方法继续上抛，抛给了调用者JVM，那么就会终止java程序的执行 12345678910111213public class Array &#123; public static void main(String[] args)&#123; // 因为Exception是编译时异常，需要对其进行处理 // 如果不处理，编译器会报错 //doSome(); 编译报错，Unhandled exception: java.lang.Exception // NullPointerException是运行时异常 // 所以编译的时候不会报错 doAgain(); &#125; public static void doSome() throws Exception&#123;&#125; public static void doAgain() throws NullPointerException&#123;&#125;&#125; 使用try…catch语句进行异常捕捉 对于上面那个doSome的编译时异常，还是有两种处理方式： 第一种：继续上抛 123456public class Array &#123; public static void main(String[] args) throws Exception&#123; doSome(); &#125; public static void doSome() throws Exception&#123;&#125;&#125; 第二种：try…catch 12345678910public class Array &#123; public static void main(String[] args)&#123; try &#123; doSome(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void doSome() throws Exception&#123;&#125;&#125; 举个例子：我是公司的小职员，因为失误导致公司损失1000元，损失1000元可以看成是一个异常发生了，我有两种处理方式： 把这件事告诉我的领导（异常上抛） 自己掏腰包把这个钱补上（异常的捕捉） 深入throws抛出异常12345678910111213141516171819202122232425262728293031323334353637383940import java.io.FileInputStream;public class Array &#123; public static void main(String[] args)&#123; //同理，这里也需要对m1上抛的异常进行处理，有两种处理方式 //如果继续上抛的话，会将异常抛给JVM，那么JVM就会结束程序 //一般main方法中的不建议继续上抛，用try...catch处理异常 try&#123; //try尝试 m1(); &#125;catch(FileNotFoundException e)&#123; //catch是捕捉异常之后走的分支 //这段代码可以使用引用e，e指向那个new出来的异常对象 System.out.println("路径不正确"); &#125; &#125; private static void m1() throws FileNotFoundException&#123; //同理，这里也需要对m2上抛的异常进行处理，有两种处理方式 m2(); &#125; private static void m2() throws FileNotFoundException&#123; //这里如果不对m3抛出的异常进行处理，下面的代码会报错 //为了解决，要么捕捉，要么继续上抛异常 //但是要注意，抛别的异常不行，必须是FileNotFoundException或其父类及以上直至Exception //例如:如果throws ClassCastException依旧会报错。但是抛IOException或者Exception时，就不会再报错了 //throws可以抛出多个异常，用逗号隔开即可。但是基本都是抛出一个异常 m3(); &#125; private static void m3() throws FileNotFoundException&#123; //下述代码调用了一个类的构造方法，编译会报错 //这个构造方法的声明位置上有：throws FileNotFoundException //FileNotFoundException的父类是IOIOException,IOException的父类是Exception //所以FileNotFoundException是编译时异常 //错误原因:编译时异常要求程序员编写程序时必须对它进行处理，不处理编译器就报错 new FileInputStream("G:\\pringce.github.io\\source\\_posts\\异常\\1.png"); //所以可以通过throws抛出异常，就不会报错了 &#125;&#125; 记住： 一个方法如果选择throws 的处理异常方式，当某一行代码发生异常时，那么整个方法结束。该行代码下面的所有代码将不会执行 一个方法如果选择try…catch的处理异常方式，当try中某一行代码发生异常时，该行代码之前的代码可以正常执行，之后的代码不会执行。随后转入catch，catch中所有的代码都会执行。try…catch结束后，该方法的后续代码可以正常执行 深入try-catch12345678910public class Array &#123; public static void main(String[] args)&#123; try&#123; new FileInputStream("G:\\pringce.github.io\\source\\_posts\\异常\\1.png"); &#125;catch(FileNotFoundException e)&#123; //这里只能捕捉FileNotFoundException及其父类以上，直至Exception。如果这里是NullPointerException，依旧会报错 System.out.println("文件不存在"); &#125; &#125;&#125; 再来个例子： 1234567891011121314151617181920212223public class Array &#123; public static void main(String[] args)&#123; try&#123; FileInputStream file = new FileInputStream("G:\\pringce.github.io\\source\\_posts\\异常\\1.png"); //read方法在声明处throws IOEception，所以下面可以由两种方式捕捉 file.read(); &#125; //第一种：捕捉Exception所有异常，但是缺点是不够精确 //catch(Exception e)&#123; // System.out.println("文件不存在"); //&#125; //第二种：精确捕捉异常，这种方式比较推荐 //catch可以写多个 //catch写多个时，从上到下必须遵循从小到大的原则 catch(FileNotFoundException e)&#123; System.out.println("文件不存在"); &#125; catch(IOException ioe)&#123; System.out.println("读取异常"); &#125; &#125; 如何选择上抛还是捕捉？ 如果需要调用者处理异常，用throws 异常对象的常用方法异常对象有两个非常重要的方法： 获取异常简单的描述信息 String msg = exception.getMessage(); 1234567public class Array &#123; public static void main(String[] args)&#123; NullPointerException e = new NullPointerException("空指针异常"); String msg = e.getMessage(); System.out.println(msg); //"空指针异常" &#125;&#125; 打印异常追踪的堆栈信息 exception.printStackTrace(); 123456789public class Array &#123; public static void main(String[] args)&#123; NullPointerException e = new NullPointerException("空指针异常"); // java.lang.NullPointerException: 空指针异常 // at test.Array.main(Array.java:20) // java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印 e.printStackTrace(); &#125;&#125; try-catch中的finally子句 finally子句的代码是最后执行的，并且一定汇之星，即使try语句中的代码发生了异常 finally得和try一起出现，不能单独编写 1234567891011121314151617181920212223public class Array &#123; public static void main(String[] args)&#123; try&#123; FileInputStream f = new FileInputStream("G:\\pringce.github.io\\source\\_posts\\异常\\1.png"); //会出现空指针异常 MyStack s = null; s.toString(); //流必须要关闭，否则会占用内存 //但由于上面出现了空指针异常，所以这里不会执行，会存在隐患 f.close(); &#125; catch(FileNotFoundException e)&#123; String msg = e.getMessage(); System.out.println(msg); &#125; catch(IOException ioe)&#123; ioe.printStackTrace(); &#125; &#125;&#125; 为解决上述流无法关闭的问题，可以用finally子句： 123456789101112131415161718192021222324252627public class Array &#123; public static void main(String[] args)&#123; //注意在try外面声明，如果在try里面声明，那么finally里面是不能用的 FileInputStream f = null; try&#123; f = new FileInputStream("G:\\pringce.github.io\\source\\_posts\\异常\\1.png"); MyStack s = null; s.toString(); &#125;catch(FileNotFoundException e)&#123; String msg = e.getMessage(); System.out.println(msg); &#125;finally &#123; try &#123; f.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;if(f != null) &#123; try &#123; f.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; try和finally，没有catch也可以执行 try不能单独使用 12345678910111213141516public class Array &#123; public static void main(String[] args)&#123; try&#123; System.out.println("try"); return; //这里会报错，因为存在return，所以程序运行不到这里 //System.out.println("xixi"); &#125;finally &#123; System.out.println("finally"); &#125; &#125;&#125;//运行结果:// try// finally 上述代码的执行顺序：先输出try，再输出finally，最后return finally无论怎样都会执行！！！ 但是！！！退出JVM，finally语句不执行 123456789101112public class Array &#123; public static void main(String[] args)&#123; try&#123; System.out.println("try"); System.exit(0); &#125;finally &#123; System.out.println("finally"); &#125; &#125;&#125;//运行结果:// try 自定义异常Java内置的异常肯定是不够用的，在实际的开发中，有很多业务出现异常之后，JDK中都是没有的。那么程序员可以自定义异常类 如何自定义异常？ 第一步：编写一个类继承Exception（编译时异常）或RunTimeException（运行时异常） 提供两个构造方法，一个无参数的，一个带有String参数的 如下所示： 123456789101112public class MyException1 extends Exception&#123;//编译时异常 public MyException1()&#123; super(); &#125;; public MyException1(String s)&#123; super(s); &#125;&#125;public class MyException2 extends RunTimeException&#123;//运行时异常 &#125; 自定义异常在开发中的作用 参考用数组模拟栈的例子： 123456789101112131415161718192021222324public class MyStack&#123; private int[] elements; private int top = -1; public MyStack() &#123; this.elements = new int[10]; &#125; public void push(int obj)&#123; if(top == elements.length-1)&#123; System.out.println("栈满了"); return; &#125; elements[++top] = obj; &#125; public void pop()&#123; if(top &lt; 0)&#123; System.out.println("栈为空"); return; &#125; top--; &#125;&#125; 上面的push和pop里面的“栈满了”和“栈为空”是异常，我们可以对上面的写法进行改进： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Array extends MyStack&#123; public static void main(String[] args)&#123; MyStack stack = new MyStack(); try &#123; for(int i=0;i&lt;=10;i++) stack.push(i); &#125; catch (MyStackOperationException e) &#123; //MyStackOperationException: 栈已满 e.printStackTrace(); &#125; &#125;&#125;class MyStack&#123; private int[] elements; private int top = -1; public MyStack() &#123; this.elements = new int[10]; &#125; public void push(int obj) throws MyStackOperationException&#123; if(top == elements.length-1) //手动抛异常 throw new MyStackOperationException("栈已满"); elements[++top] = obj; &#125; public void pop() throws MyStackOperationException&#123; if(top &lt; 0)&#123; //手动抛异常 throw new MyStackOperationException("栈已空"); &#125; top--; &#125;&#125;class MyStackOperationException extends Exception&#123; public MyStackOperationException()&#123; super(); &#125;; public MyStackOperationException(String s)&#123; super(s); &#125;&#125; 这种自定义异常在开发中的应用非常重要！！！ 总结异常中的关键字： 异常捕捉 try catch finally throws：在方法声明位置上使用，表示上报异常信息给调用者 throw：手动抛出异常]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装类]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java为8种数据类型又对应准备了8种包装类型，8种包装类型属于引用数据类型 为什么需要包装类？ 调用某个方法的时候需要传一个数字进去，但是该方法的参数类型为Object，所以此时无法直接传递；可以传一个数字对应的包装类进去，8种基本数据类型对应的包装类Sun公司已经写好了，我们直接使用即可 8种包装类如下： byte：java.lang.Byte（父类是Number，Number的父类是Object） short：java.lang.Short（父类是Number，Number的父类是Object） int：java.lang.Integer（父类是Number，Number的父类是Object） long：java.lang.Long（父类是Number，Number的父类是Object） float：java.lang.Float（父类是Number，Number的父类是Object） double：java.lang.Double（父类是Number，Number的父类是Object） boolean：java.lang.Boolean（父类是Object） char：java.lang.Character（父类是Object） Number是一个抽象类，无法实例化对象。Number类中有这样的方法： byte byteValue()：以byte形式返回指定的数值 short shortValue()：以short形式返回指定的数值 abstract int intValue()：以int形式返回指定的数值 abstract long longValue()：以long形式返回指定的数值 abstract float floatValue()：以float形式返回指定的数值 abstract double doubleValue()：以double形式返回指定的数值 上述方法其实所有的6中数字包装类都有，这些方法是负责拆箱的 1234567891011121314public class Array &#123; public static void main(String[] args) &#123; // 基本数据类型 --&gt; 引用数据类型（装箱） Integer i = new Integer(100); // 引用数据类型 --&gt; 基本数据类型（拆箱） float ret1 = i.floatValue(); System.out.println(ret1); // 引用数据类型 --&gt; 基本数据类型（拆箱） float ret2 = i.intValue(); System.out.println(ret2); &#125;&#125; 下面通过介绍Integer类来对所有包装类进行学习 Integer构造方法 1234// 将数字100转换成Integer包装类型Integer x = new Integer(100);// 将String类型的数字，转换成Integer包装类型。如果不是数字的String，编译时没问题，运行时会出现异常:java.lang.NumberFormatExceptionInteger y = new Integer("100"); 获取最大最小值 通过访问包装类的常量，来获取最大值和最小值 123System.out.println(Integer.MAX_VALUE);System.out.println(Integer.MIN_VALUE);System.out.println(Byte.MAX_VALUE); 自动装箱和自动拆箱 在JDK1.5之后，支持自动装箱和自动拆箱。 优点：方便编程 12345678910111213141516171819202122public class Array &#123; public static void main(String[] args) &#123; // 自动装箱:基本数据类型自动转换成包装类 Integer x = 100; // 自动拆箱:包装类自动转换成基本数据类型 int y = x; Integer z = 1000; // z是一个引用，还是保存了一个对象的内存地址 // 为什么没有报错？ // +号两边要求是基本数据类型的数字，因为这里会进行自动拆箱 System.out.println(z+1); Integer a = 10000; Integer b = 10000; // ==比较的是对象的内存地址，不会自动拆箱 // 只有加减乘除才会自动拆箱 //==两边有一个是基本数据类型会自动拆箱，如果都是包装类则不会自动拆箱 System.out.println(a==b); // false &#125;&#125; 在Java中为了提高执行效率，将[-128,127]之间的所有的包装对象在类加载的时候就创建好，放到了一个方法区的整数型常量池当中，目的是只要用到这个区间的数据不需要再new了，直接从整数型常量池当中取出来。 123456789101112public class Array &#123; public static void main(String[] args) &#123; Integer a = 128; Integer b = 128; System.out.println(a==b); //false // x和y保存的对象的内存地址是一样的 Integer x = 127; Integer y = 127; System.out.println(x==y);//true &#125;&#125; Integer常用方法 static int parseInt(String s)：静态方法，String转换成int。参数必须是数字的String对象，别的非数字String对象编译时没问题，运行时会出现java.lang.NumberFormatException异常。其余包装类类似，例如Double.parseDouble 1int retValue = Integer.parseInt("123"); //123 static String toBinaryString(int i)：静态方法，十进制换换成二进制字符串。还有toOctalString（转换成八进制）、toHexString（转换成十六进制） 1String b = Integer.toBinaryString(-3); // 11 static Integer valueOf(int i)：int转换成Integer。还有类似的Integer valueOf(String s) 12Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf("100"); static String toString(int i)：静态方法，把基本类型转换为字符串 1String b = Integer.toStirng(1); 重写了Object的toString 123public String toString() &#123; return toString(value); &#125; String、int和Integer类型互相转换 int转String 数字+”” String s = String.valueOf(int i); String转int int i = Integer.parseInt(String s); int转Integer 装箱，自动或手动 Integer转int 拆箱，自动或手动 String转Integer Integer i = Integer.valueOf(String s); Integer转String String s = String.valueOf(Integer x);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类]]></title>
    <url>%2F2020%2F05%2F07%2FString%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[关于Java JDK中内置的一个类：java.lang.String String表示字符串类型，属于引用数据类型 重点：在Java中使用双引号括起来的都是String对象 Java规定，双引号括起来的字符串是不可变的。也就是说”abc”自出生到死亡不可变，不能变成”abcd” 在JDK当中双引号括起来的字符串，例如”abc”都是直接存储在方法区的常量池中。为什么这么设计呢？ 因为字符串在实际开发中使用太频繁，为了执行效率将其放在方法区的常量池中 垃圾回收器不会释放常量池中的对象 通常有两种方式创建String对象： 第一种 1String s1 = "abc"; 采用这种方式时，”abc”这个String对象存储在方法区的字符串常量池中，在栈中创建了一个s1引用，该引用保存这个String对象的内存地址，指向常量池中的该对象（注意：堆内存中不会创建任何对象）。如果此时又有String q = “abc”；那么常量池中不会新建”abc”字符串对象，q依旧指向上面的”abc”对象，q和s1指向的是同一个字符串对象。这个时候可以用”==”比较两个字符串对象是否相等 第二种 1String s2 = new String("abc") 采用这种方式时，”abc”这个String对象依然存储在方法区的字符串常量池中，同时在堆中创建了一个对象，该对象中保存着这个常量池中的String对象的内存地址。同时在栈中创建了一个s2引用，该引用保存这个堆内存中对象的内存地址（注意：堆内存中会创建对象）。这个时候就不能用”==”判断两个字符串对象是否相等，要用equals方法 。 如果此时又有String e = new String(“abc”)；那么常量池中不会增加字符串对象，但是堆中会多一个对象，该对象中存储着”abc”这个String对象的内存地址。e指向堆内存中新创建的对象，e和s2指向的是不同的对象 String常用的构造方法 123456789101112131415161718192021222324252627// 创建String对象最常用的方法String s1 = "abc";// 常用的构造方法// 第一种，参数是byte数组byte[] bytes = &#123;97,98,99&#125;; //97是a，98是b，99是cString s2 = new String(bytes);System.out.println(s2); // abc// 第二种byte[] bytes = &#123;97,98,99&#125;; //97是a，98是b，99是cString s3 = new String(bytes,1,2); // 1是数组起始下标，2是长度System.out.println(s3); // bc// 第三种char[] chars = &#123;'a','b','c'&#125;;String s4 = new String(chars);System.out.println(s4); // abc// 第四种char[] chars = &#123;'a','b','c'&#125;;String s5 = new String(chars,1,2); // 1是数组起始下标，2是长度System.out.println(s5); // bc// 第五种String s6 = new String("hello,world");System.out.println(s6); // hello,world String中的常用方法 charAt方法 123// char charAt(int index)，返回指定索引的字符char c = "hello".charAt(1);System.out.println(c); // e compareTo方法：比较字符串字典序大小关系，从左到右依次进行比较，如果相等就往后；如果不等就输出1或-1；如果全部都相等就输出0 123456789101112// int compareTo(String anotherString)int result1 = "abc".compareTo("abc");System.out.println(result1); // 0，前后相等int result2 = "abcd".compareTo("abce");System.out.println(result2); // -1，前小后大int result3 = "abce".compareTo("abcd");System.out.println(result3); // 1，前大后小int result4 = "xyz".compareTo("yxz");System.out.println(result4); // -1，前小后大 contains方法：判断前面的字符串是否包含后面的字符串 12// boolean contains(String s)System.out.println("helloworld").contains("world"); // true endsWith方法：判断当前字符串是否以某个字符串结尾 12// boolean endsWith(charSequence s)System.out.println("helloworld").endsWith("world"); // true endsWith方法：判断当前字符串是否以某个字符串开始 equalsIgnoreCase(String anotherString)：忽略两个字符串大小写，判断是否相等 12// boolean equalsIgnoreCase(String anotherString)System.out.println("ABc".equalsIgnoreCase("abC"); // true getBytes方法：将字符串对象转换成byte数组 1byte[] bytes = "abc".getBytes(); indexOf方法：判断某个子字符串在当前字符串第一次出现处的索引，返回值为int 1System.out.println("OracleJavaC++Java".indexOf("Java"); // 6 lastIndexOf方法：判断某个子字符串在当前字符串中最后一次出现的索引 1System.out.println("OracleJavaC++Java".indexOf("Java"); // 13 isEmpty方法：判断某个字符串是否为空，返回值boolean 12String s = "";System.out.println(s.isEmpty()); // true length方法：返回字符串长度，返回值int。注意数组中是length属性获得数组长度 1System.out.println("abc".length()); //3 replace方法：替换。还有个replaceAll，和这个差不多，只不过target支持正则表达式，两个方法都是全部替换，即替换全部符合的目标字符串 12// String replace(String target,String replacement)String s = "http://".replace("http","https"); split方法：拆分字符串 12// String[] split(String regex)String[] s = "1990-01-01".split("-"); // &#123;"1990","01","01"&#125; substring方法：截取字符串 123456// String substring(int beginIndex)，参数是起始下标String s = OracleJava.substring(6); // Java// String substring(int beginIndex，int endIndex)，参数是起始下标和结束下标,左闭右开[beginIndex,endIndex)// 包括beginIndex，不包括endIndexString s = OracleJava.substring(6,8); // Ja toCharArray方法：将一个字符串转换成char数组 12// char[] toCharArray()char[] chars = "hello".toCharArray();//&#123;'h','e','l','l','o'&#125; toLowerCase方法：转换成小写 1String s = "ABC".toLoweCase(); // abc toUpperCase方法：转换成大写 trim方法：去除字符串前后空格，不能去除中间的空格 1String s = " hello world ".trim(); // hello world valueOf方法：String类中唯一的静态方法，将非字符串转换成字符串。如果方法中传入的是引用数据类型的对象，那么会调用该对象的toString方法转换成字符串 123String s = String.valueOf(true);System.out.println(s); // "true"// 本质上System.out.println这个方法在输出任何数据的时候都是先转换成字符串再输出，即会先调用valueOf方法 StringBuffer在实际开发中，如果需要进行字符串频繁拼接，会有什么问题？ 因为Java字符串是不可变的，每一次拼接都会产生新字符串，这样会占用大量的方法区内存，造成内存空间的浪费。 此时就要用的StringBuffer或StringBulider 123456789101112public class Test&#123; public static void main(String[] args)&#123; StringBuffer stringBuffer = new StringBuffer(); // 拼接字符串调用append方法，可以追加任何类型的数据 // append方法底层在进行追加的时候，如果byte数组满了，会自动扩容 stringBuffer.append("hello"); stringBuffer.append(true); stringBuffer.append(3.14); stringBuffer.append(100); System.out.println(stringBuffer.toString());// "hellotrue3.14100" &#125;&#125; StringBuffer底层实际上是一个byte数组（字符串缓冲区对象），往StringBuffer中放字符串，实际上是放到byte数组当中了，StringBuffer的默认初始化容量是16个字符。String底层也是一个byte数组，但是由final修饰，所以String字符串是不可变的 如何优化StringBuffer？ 在创建StringBuffer的时候尽可能给定一个初始化容量，减少底层数组的扩容次数。如何给定？ 1StringBuffer stringBuffer = new StringBuffer(100); // 容量为100个字符 StringBuilder使用StringBuilder也能完成字符串拼接 123456789101112public class Test&#123; public static void main(String[] args)&#123; StringBuilder stringBuilder = new StringBuilder(); // 拼接字符串调用append方法，可以追加任何类型的数据 // append方法底层在进行追加的时候，如果byte数组满了，会自动扩容 stringBuilder.append("hello"); stringBuilder.append(true); stringBuilder.append(3.14); stringBuilder.append(100); System.out.println(stringBuilder.toString());// "hellotrue3.14100" &#125;&#125; StringBuffer和StringBuilder的区别？ StringBuffer中的方法都有synchronized关键字修饰，表示StringBuffer方法在多线程环境下运行是安全的；StringBuilder中的方法都没有synchronized关键字修饰，表示非线程安全]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2020%2F05%2F05%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组概述 Java语言中的数组是一种引用数据类型，不属于基本数据类型，数组的父类是Object 数组实际上是一个容器，可以同时容纳多个元素 数组当中可以存储基本类型的数据，也可以存储引用数据类型的数据 数组因为是引用数据类型，所以数组对象是存储在堆内存当中 如果数组中存储的是基本类型数据，那么直接存储即可；如果存储的是引用数据类型数据，那么数组对象中存储的是该引用数据类型对象在堆内存中的地址，不能直接存储java对象 数组一旦创建，长度不可变 数组的分类：一维数组、二维数组、三维数组、多维数组…（一维数组最常用，二维数组偶尔使用） 数组中每个元素都是有下标的，从0开始 所有的数组对象都有length属性（java自带，不是方法），用来获取数组中元素个数 java数组中的数组要求数组中元素的类型统一 所有数组都是拿数组中“第一个小方框”的内存地址作为数组的内存地址 数组的优点： 查询某个下标上的元素时效率极高（为什么效率高？一是因为每个元素的内存地址在空间存储上是连续的；二是因为每个元素类型相同，占用空间大小相同；） 数组中存储100个元素或者存储100万个元素，在元素查询方面，效率是相同的。因为数组中元素查找的时候不会一个一个找，是通过数学表达式计算出来的（根据首元素内存地址、下标和每个元素所占用的内存大小，算出一个内存地址，直接定位） 数组的缺点： 为了保证数组中每个元素内存地址连续，所以删除或插入某个元素的时候效率较低（注意：数组中最后一个元素的增删效率是没有影响的） 一维数组定义一维数组 1int[] array; 初始化一维数组 包括两种方式：静态初始化一维数组和动态初始化一维数组 1234567// 静态初始化一维数组int[] array = &#123;100,200,300&#125;;// 动态初始化一维数组int[] array = new int[5]; // 这里的5表示数组的的元素个数，每个元素默认为0String[] names = new String[5]; //每个元素默认为nullObject[] objects = new Object[3]; // 每个元素默认为null 动态初始化由于都是默认值，需要手动的给他们赋值： 1234String[] names = new String[5];names[0] = "liu";names[1] = "zhang";names[2] = "wang"; 什么时候采用动态初始化，什么时候采用静态初始化？ 当创建数组的时候，确定数组中存储哪些具体的元素时，采用静态初始化；当不确定的时候，可以采用动态初始化预先分配内存空间 一维数组遍历 1234int[] array = &#123;1,2,3,4,5&#125;;for(int i=0;i&lt;array.length;i++)&#123; System.out.println(array[i]);&#125; 如果访问array[array.length]，会出现数组下标越界异常：java.lang.ArrayIndexOutOfBoundsException 数组中存放引用数据类型 123456789101112131415161718192021222324252627public class Test&#123; public static void main(String[] args)&#123; Animal[] a = new Animal[2]; a[0] = new Animal(); // 下面报错，Animal数组中只能存放Animal类型，不能存放product类型 // a[1] = new product(); // cat是Animal的子类，可以存放cat类型的数据 // 这里就是多态的问题了，数组是Animal类型，指向了一个子类对象 a[1] = new cat(); &#125;&#125;class Animal&#123; public void move()&#123; System.out.println("Animal move"); &#125;&#125;class product&#123;&#125;class cat extends Animal&#123; public void move()&#123; System.out.println("cat move"); &#125;&#125; 方法的参数是数组123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; // 方法的参数是数组 // 方法1 int[] x = &#123;1,2,3,4&#125;; printArray(x); // 方法2 printArray(new int[]&#123;1,2,3&#125;); // 方法3，传递一个动态数组 printArray(new int[5]); &#125; public static void printArray(int[] array)&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.println(array[i]); &#125; &#125;&#125; 注意：传递的是数组的内存地址。所以如果在方法中对数组进行了修改，会直接影响到堆内存中数组的元素值。 数组扩容在java开发中数组长度一旦确定不可变，那么数组满了怎么办？ java中对数组的扩容是： 先新建一个大容量的数组 然后将小容量数组中的元素一个一个的拷贝过去 数组扩容效率低，因为涉及到拷贝的问题。所以请注意尽可能少的进行数组拷贝 数组拷贝有系统自带的拷贝方法： 1System.arraycopy(Object src,int srcPos,Object dest,int destPos,int length); src：源数组 srcPos：从源的哪个位置开始拷贝 dest：目标数组 destPos：目标数组的起始下标 length：拷贝的长度 123int[] src = &#123;1,2,3&#125;;int[] dest = new int[20];System.arraycopy(src,0,dest,0,src.length); 二维数组二维数组其实就是一个特殊的一维数组，特殊在这个一维数组中的每个元素是一个一维数组 二维数组静态初始化 12345int[][] array = &#123; &#123;100,200,300&#125;, &#123;30,20,10,40,50,60&#125;, &#123;6,7,9,1&#125;&#125;; 每个一维数组的长度可以不同 二维数组动态初始化 1int[][] array = new int[4][5]; 二维数组的length属性 12345678int[][] array = &#123; &#123;100,200,300&#125;, &#123;30,20,10,40,50,60&#125;, &#123;6,7,9,1&#125;&#125;;System.out.println(array.length); // 4System.out.println(array[0].length); // 3System.out.println(array[1].length); // 6 二维数组元素访问 123456int[][] array = &#123; &#123;100,200,300&#125;, &#123;30,20,10,40,50,60&#125;, &#123;6,7,9,1&#125;&#125;;System.out.println(array[0][0]); // 第一个一维数组中的第一个元素 二维数组遍历 1234567int[][] a = new int[4][5];for(int i=0;i&lt;a.length;i++)&#123; for(int j=0;j&lt;a[i].length;j++)&#123; System.out.print(a[i][j] + " "); &#125; System.out.println();&#125; Arrays工具类Java为程序员写好了一个数组工具类：java.util.Arrays 主要使用两个：排序和二分查找 排序 12345import java.util.Arrays;int[] ns = &#123;28,12,89,73,65&#125;;Arrays.sort(ns);System.out.println(Arrays.toString(ns)); // Arrays重写了toString方法，输出数组 二分查找 1234567import java.util.Arraysint[] ns = &#123;28,12,89,73,65&#125;;Arrays.sort(ns);// 二分查找必须保证数组有序// 如果返回-1表示查找不到，否则返回元素在数组中的下标int index = Array.binarySearch(ns,32); Arrays类重写了toString方法，可直接输出数组： 12int[] ns = &#123;1,2,3&#125;;System.out.println(Arrays.toString(ns));]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2020%2F05%2F05%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[什么是内部类？类的内部又定义了一个新的类，被称为内部类 内部类的分类 静态内部类，类似于静态变量 实例内部类，类似于实例变量 局部内部类，类似于局部变量 12345678910class Test&#123; // 静态内部类 static class Inner1&#123;&#125; // 实例内部类 class Inner2&#123;&#125; public doSome()&#123; // 局部内部类 class Inner3&#123;&#125; &#125;&#125; 匿名内部类属于局部内部类的一种。因为这个类没有名字而叫做匿名内部类 下面先给个例子： 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args)&#123; MyMath = m = new MyMath(); m.mySum(new ComputeImpl(),100,200); &#125;&#125;interface Compute&#123; int sum(int a,int b);&#125;class ComputeImpl implements Compute&#123; public int sum(int a,int b)&#123; return a+b; &#125;&#125;class MyMath&#123; public void mySum(Compute c,int a,int b)&#123; int retValue = c.sum(a,b); System.out.println(retValue); &#125;&#125; 下面用匿名内部类对上述代码进行改进。接口或者抽象父类的实现类可以不用写出来了，直接用匿名内部类写： 12345678910111213141516171819202122public class Test&#123; public static void main(String[] args)&#123; MyMath = m = new MyMath(); // 这就是匿名内部类 m.mySum(new Compute()&#123; public int sum(int a,int b)&#123; return a+b; &#125; &#125;,100,200); &#125;&#125;interface Compute&#123; int sum(int a,int b);&#125;class MyMath&#123; public void mySum(Compute c,int a,int b)&#123; int retValue = c.sum(a,b); System.out.println(retValue); &#125;&#125; 不建议使用匿名内部类，因为类没有名字只能用一次，并且可读性很差]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类]]></title>
    <url>%2F2020%2F05%2F03%2FObject%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[什么是API？ 应用程序编程接口（Application Program Interface） 整个JDK的类库就是一个JavaSE的API 每个API都会配置一套API帮助文档 toString方法源码如下： 123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 源代码上toString方法的默认实现是：类名@对象的内存地址转换为十六进制的形式 toString方法的作用：toString方法的设计目的是：通过调用这个方法可以将一个java对象转换成字符串表示形式 建议所有的子类都重写toString方法，因为默认的实现不简洁不易阅读（toString方法以后在写的时候一般都要重写） 1234567891011121314151617181920212223package test;public class test &#123; public static void main(String[] args) &#123; myTime m = new myTime(1970,1,1); String s = m.toString(); System.out.println(s); // test.myTime@b4c966a // 输出引用的时候，会自动调用toString方法 System.out.println(m); // test.myTime@b4c966a &#125;&#125;class myTime&#123; int year; int month; int day; public myTime()&#123;&#125; public myTime(int year,int month,int day)&#123; this.year = year; this.month = month; this.day = day; &#125;&#125; equals方法源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; equals方法的目的是判断两个对象是否相等 判断两个基本数据类型的数据是否相等直接使用“==”即可；判断两个java对象对象是否相等不能直接用双等号，如果使用双等号判断的是两个对象的内存地址是否相等，而不是两个对象是否相等 在Object类中默认的equals方法采用双等号判断两个对象是否相等，所以该默认equals方法不够用，需要在子类中重写equals方法（String也是引用数据类型的，但该类中重写了equals方法，所以比较的是字符串内容是否相等） 注意：重写equals方法要彻底（每个自定义类都要重写equals方法） 如何重写equals方法（自己定，你认为什么时候对象相等就怎么写） 123456789101112131415161718192021class myTime&#123; int year; int month; int day; public myTime()&#123;&#125; public myTime(int year,int month,int day)&#123; this.year = year; this.month = month; this.day = day; &#125; @Override public boolean equals(Object obj) &#123; if(obj==null || !(obj instanceof myTime)) return false; // 如果两个对象的内存地址相等，那么一定表示两个对象相等 if(this == obj) return true; myTime t = (myTime)obj; return this.year == t.year &amp;&amp; this.month == t.month &amp;&amp; this.day == t.day &#125;&#125; 在IntelliJ IDEA中可以自动生成重写的toString和equals方法（用Alt+Insert快捷键插入） String类重写了toString方法和equals方法String类中的源码： 123456789101112131415161718192021222324252627@Override// 用于返回String的字符串值public String toString() &#123; return this;&#125;public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 比较两个字符串不能用双等号，必须调用equals方法。String类已经重写了equals方法和toString方法。重写后的equals方法用来比较两个字符串内容是否相同；重写后的toString方法用来输出字符串值 finalize方法源码如下： 1protected void finalize() throws Throwable &#123; &#125; finalize方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的 这个方法不需要程序员手动调用，JVM垃圾回收器负责调用这个方法。equals和toString方法需要程序员手动调用 finalize方法的执行时机：当一个Java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用 finalize方法实际上是SUN公司为Java程序员准备的一个时机（垃圾销毁时机）。如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize方法中（有点类似于静态代码块） 有点像C++中的析构函数 可以重写该方法，在对象被回收的时候，执行方法体 当然了，对象也有可能不被回收（因为垃圾回收器的启动是有条件的，如果垃圾太少可能不启动），所以finalize方法可能不被调用。有一段代码可以建议垃圾回收器启动（但可能不听话，有可能启动，也可能不启动） 123myTime r = new myTime();r = null;System,gc(); // 建议垃圾回收器启动 hashCode方法源码如下： 1public native int hashCode(); 带有native关键字，底层调用C++程序 hashCode方法返回的是哈希吗，实际上就是一个java对象的内存地址，经过哈希算法，得到的一个值。所以hashCode方法的执行结果可以等同看成一个java对象的内存地址 123456public class test&#123; public static void main(String[] args) &#123; myTime t = new myTime(); System.out.println(t.hashCode()); // 793589513 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口]]></title>
    <url>%2F2020%2F04%2F30%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[抽象类什么是抽象类？ 类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类。类本身是不存在的，所以抽象类无法创建对象（无法实例化） 抽象类是无法实例化的，所以抽象类是用来被子类继承的。子类继承抽象类，子类可以实例化对象 final和abstract不能联合使用 抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的（子类构造方法中的第一行是super（）） 抽象类属于什么数据类型？ 抽象类也属于引用数据类型 抽象类怎么定义？ 语法：[修饰符列表] abstract class 类名{ ​ 类体； ​ } 抽象类的子类可以是抽象类也可以是非抽象类 抽象类关联到一个概念：抽象方法。什么是抽象方法？ 抽象方法表示没有实现的方法，没有方法体的方法。例如： 1public abstract void doSome(); // 没有大括号 抽象方法的特点： 没有方法体，以分号结尾 前面修饰符列表中有abstract关键字 抽象类中不一定有抽象方法！但有抽象方法的类一定是抽象类！ 重要结论（五星级重要）：一个非抽象类继承抽象类，必须将抽象类中的抽象方法实现了（因为抽象方法必须出现在抽象类中，所以非抽象类中继承的抽象方法必须去实现），如下 12345678public abstract test1&#123; public abstract void doSome();&#125;public test2 extends test1&#123; // 去掉abstract，加上方法体 public void doSome()&#123;&#125;&#125; 如果抽象类继承了抽象类，那么继承过来的抽象方法可以不实现 java语言中凡是没有方法体的方法都是抽象方法？ 不对！Object类中就有很多方法都没有方法体，但它们都不是抽象方法。例如： public native int hashCode()； 这个方法底层调用了C++写的动态链接库程序，前面修饰符列表中有一个native，表示调用JVM本地程序 接口接口的基础语法 接口也是一种引用数据类型，编译之后也是一种.class字节码文件 接口是完全抽象的，抽象类是半抽象。或者也可以说接口是特殊的抽象类 接口也不能实例化 接口定义： [修饰符列表] interface 接口名{} 接口支持继承，并且支持多继承（接口间的继承也是用extends），一个接口可以继承多个接口 接口中只包含两部分内容，没有其他内容 常量 抽象方法（注意：从Java1.8开始，也可以在接口中定义静态方法，包含方法体。不过好像没人这么干，因为这就破坏了接口的抽象性） 接口中所有元素都是public修饰的 接口中的抽象方法定义时，修饰符列表中的public abstract可以省略，但是不能有方法体 接口中的常量的public static final可以省略 类和类之间叫做继承，类和接口之间叫做实现（仍然可以将实现看作是继承）。继承使用extends，实现使用implements。 非抽象类实现接口时，必须将接口中的方法全部实现（注意：由于接口中的方法都是public，所以在类中实现时要显示地写出public，不写默认是缺省，会报错。因为重写时访问权限不可以更严格）。抽象类实现接口时，可以无需将接口中的方法实现 接口也可以实现多态（比如一个类实现了一个接口，接口就是父类型，该类就是子类型，父类型引用指向子类型对象） 重点：一个类可以同时实现多个接口，这种机制弥补了Java中类的单继承缺陷。实现多个接口类似于多继承，每个接口中的方法都要实现 接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转。但是一定要注意，运行时可能会出现ClassCastException异常，可以用instance of（这和类有区别，类之间的强制类型转换必须要有继承关系） 类也可以强制类型转换为接口。当类实现了该接口时不会报错；但如果类没有实现该接口，在转换时编译不会报错，但是运行时会出现ClassCastException异常 1234567891011121314interface K&#123;&#125;interface M&#123;&#125;class E implements M&#123;&#125;public class test&#123; public static void main(String[] args)&#123; M m = new E(); // 编译正确，运行出现ClassCastException异常 K k = (K)m; &#125;&#125; 继承和实现都存在的话，应该怎么写？ extends关键字在前，implemets关键字在后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 动物类：父类class Animal&#123; &#125;// 可飞翔的接口interface Flyable&#123; void fly();&#125;// 动物类子类：猫类// Flyable是一个接口，通过接口插到猫身上，让猫变得可飞翔// 接口通常提取的是行为动作class Cat extends Animal implements Flyable&#123; public void fly()&#123; System.out.println("Cat's fly"); &#125;&#125;// 蛇类，不想让它飞，可以不实现Flyable接口// 没有实现这个接口，表示不能飞class Snake extends Animal&#123; &#125;class Pig extends Animal implements Flyable&#123; public void fly()&#123; System.out.println("Pig's fly"); &#125;&#125;class Fish extends Animal implements Flyable&#123; public void fly()&#123; System.out.println("Fish's fly"); &#125;&#125;public class test&#123; public static void main(String[] args)&#123; Flyable f1 = new Cat(); // 多态 f1.fly();// Cat's fly Flyable f2 = new Pig(); // 多态 f2.fly();// Pig's fly Flyable f3 = new Fish(); // 多态 f3.fly();// Fish's fly &#125;&#125; 接口在开发中的作用接口在开发中的作用类似于多态在开发中的作用 多态：面向抽象编程，不面向具体编程，降低程序的耦合度，提高程序的扩展力 接口是完全抽象的，而我们正好要求面向抽象编程，以后可以将这句话修改为面向接口编程。有了接口就有了可插拔，可插拔表示扩展力强，不是焊接死的。 主板和内存条之间有插槽，这个插槽就是接口，内存条快了，可以重新换一个，这就叫高扩展性 接口是离不开多态的，因为他无法创建对象，只能用类进行实现再创建对象，即父类型引用指向子类型对象 抽象类和接口的区别抽象类是半抽象的，接口是完全抽象的 抽象类有构造方法，接口没有构造方法 接口和接口之间支持多继承，类和类之间只能单继承 一个类也可以实现多个接口，一个抽象类只能继承一个类 接口使用的比抽象类多]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计三范式]]></title>
    <url>%2F2020%2F04%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计范式设计表的依据，按照设计三范式设计的表不会出现数据冗余 设计三范式第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分（比如邮箱电话放在联系方式字段里，不符合原子性不可再分，因为可分为邮箱和电话两个字段），如下 学生编号 学生姓名 联系方式 101 张三 zs@gmail.com,1359999999 102 李四 ls@gmail.com,1369999999 101 王五 ww@163.net,1348888888 上述表存在如下问题： 最后一条记录和第一条记录重复（不唯一，没有主键） 联系方式子弹可以再分，不符合原子性不可再分规则 如何解决上述第一范式问题？如下表 学生编号(PK) 学生姓名 email 联系电话 101 张三 zs@gmail.com 1359999999 102 李四 ls@gmail.com 1369999999 103 王五 ww@163.net 134888888 上表中学生编号为主键，且各字段符合原子性 第二范式：建立在第一范式基础上，所有非主键字段完全依赖主键，不能产生部分依赖（主要针对联合主键而言）。如果单一主键，那么肯定是满足第二范式的 学生编号（PK） 教师编号（PK） 学生姓名 教师姓名 101 001 张三 王老师 102 002 李四 赵老师 103 001 王五 王老师 101 002 张三 赵老师 以上虽然确定了主键（联合主键），但此表出现大量的冗余，主要涉及到冗余字段为“学生姓名”和“教师姓名”，出现冗余的原因在于：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖于教师编号，而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式的部分依赖。 下面我们思考一下什么时候要建立联合主键？存在多对多的情况，即一个主键无法完成表中数据唯一性。比如一个订单表，一个订单可能会对应多种商品（那么可能就要存在多行代表同一个订单，一行代表订单中的一种），同样一种商品也可能对应多个订单，这里就不能用单一主键了，必须用联合主键（订单编号+商品编号）。如下表所示： 订单编号(pk) 商品编号(pk) 商品名称 数量 价格 客户 联系方式 001 1 挖掘机 1 1200 张三 123 001 2 冲击钻 8 20 张三 123 002 3 铲车 2 300 李四 456 那么如何解决上述多对多问题（解决了多对多，也就解决了第二范式）呢？ 有个口诀：多对多，三张表，关系表两外键！如下所示： 第一张表：订单信息表 订单编号（pk） 客户 联系方式 001 张三 123 002 李四 456 第二张表：商品信息表 商品编号（pk） 商品名称 商品价格 1 挖掘机 1200 2 冲击钻 20 3 铲车 300 第三张表：订单信息表和商品信息表的关系表 ID（pk） 订单编号（fk） 商品编号（fk） 数量 1 001 1 1 2 001 2 8 3 002 3 2 这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。 第三范式：建立在第二范式基础上，所有非主键字段直接依赖主键字段，不能产生传递依赖 学生编号（pk） 学生姓名 班级编号 班级名称 101 张三 01 一班 102 李四 02 二班 103 王五 03 三班 104 赵六 03 三班 从上表可以看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键，班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖。 什么时候会出现传递依赖问题呢？存在一对多问题，比如上面的表，一个学生对应一个班级，一个班级对应多个学生，这就是典型的一对多问题。 那么如何解决上述一对多问题（解决了一对多，也就解决了第三范式）呢？ 有个口诀：一对多，两张表，多的表加外键（即一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键，班级为一，学生为多，一个班级对应多个学生，在学生信息表加外键）！如下所示： 第一张表：学生信息表 学生信息表（pk） 学生姓名 班级编号（fk） 101 张三 01 102 李四 02 103 王五 03 104 赵六 03 第二张表：班级信息表 班级编号（pk） 班级名称 01 一班 02 二班 03 三班 注意：数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 下面说下一对一的设计方案，有两种： 主键共享 外键唯一 一个系统设计完成后，用户注册会生成注册信息，包括用户名、密码，还有一些详细信息（比如联系方式、性别、年龄等）。这是一种典型的一对一问题，那么怎么设计相应的表呢？下面针对上面两种方案分别介绍 第一种：主键共享 第一张表：t_user_login id(pk) 用户名 密码 1 张三 123 2 李四 456 第二张表：t_user_detail id（pk+fk） 联系方式 性别 年龄 1 1326616 男 18 2 1346511 女 21 这里在表t_user_detal中，id既是主键，也是引用t_user_login中id字段的外键，这就是所谓的主键共享 第二种：外键唯一 第一张表：t_user_login id(pk) 用户名 密码 1 张三 123 2 李四 456 第二张表：t_user_detail id（pk） 联系方式 性别 年龄 userid（fk+unique） 1 1326616 男 18 1 2 1346511 女 21 2 这里在表t_user_detal中，id是主键，userid引用t_user_login中id字段的唯一外键，这就是所谓的外键唯一]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图]]></title>
    <url>%2F2020%2F04%2F18%2F%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[什么是视图站在不同的角度去看待数据（同一张表的数据，通过不同的角度去看待）。视图也被称为虚拟表 创建视图12create view 视图名 as 查询语句;create view myview as select empno,ename from emp; 只有select语句才能以视图对象的方式创建出来，即as后面只能跟select语句。但是可以对视图进行CURD操作（增删改查），对视图CURD时就跟对待一张表一样，增删改查的语句与一张表完全一样。不过并不是可以在所有的视图上执行增、删、改的，在生成视图的时候使用了下边这些语句的都不能进行更新： 聚集函数（比如SUM(), MIN(), MAX(), COUNT()等等） DISTINCT GROUP BY HAVING UNION 或者 UNION ALL 某些子查询 某些连接查询 等等等等 删除视图1drop view myview; 对视图进行增删改查，会影响到原表数据（通过视图影响原表数据，不是直接操作的原表） 视图其实就相当于是某个查询语句的别名！创建视图的时候并不会把那个查询语句的结果集维护在硬盘或者内存里！在对视图进行查询时，MySQL服务器将会帮助我们把对视图的查询语句转换为对底层表的查询语句然后再执行 视图还可以参与一些更复杂的查询，比如子查询、连接查询什么的。有一点比较有趣的是，在书写查询语句时，视图还可以和真实表一起使用。所以在使用层面，我们完全可以把视图当作一个表去使用，但是它的实现原理却是在执行语句时转换为对底层表的操作。使用视图的好处也是显而易见的，视图可以简化语句的书写，避免了每次都要写一遍又臭又长的语句，而且对视图的操作更加直观，使用者也不用去考虑它的底层实现细节。 视图的作用视图可以隐藏表的实现细节，保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图进行CURD操作]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2020%2F04%2F15%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[为何要有索引 一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。所以索引的作用就是对查询语句的效率进行优化 索引(key)是存储引擎用于快速找到记录的一种数据结构。它和一本书中目录的工作方式类似——当要查找一行记录时，先在索引中快速找到行所在的位置信息，然后再直接获取到那行记录。在MySQL中，索引是在存储引擎层而不是服务器层实现的，所以不同的存储引擎对索引的实现和支持都不相同。 什么是索引索引在MySQL中也叫做“键”或者”key”（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果 索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。 索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查 强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据 索引的数据结构先问个问题：我们需要这种数据结构能做些什么？其实很简单：就是每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。目前大部分数据库系统及文件系统都采用B-树或B+树作为索引结构（B+树是通过二叉查找树，再由平衡二叉树，B-树演化而来）。 下面我们就分别介绍一下B-树和B+树 B-树B-树就是我们常说的B树。 B-树是一种多路搜索树（并不一定是二叉的） 一棵m阶B-树是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 根节点至少有两个子女，根节点的子女个数为[2,m] 每个非根节点（内节点和叶节点）包含的关键字个数k满足：ceil(m/2)-1 &lt;= k &lt;= m-1;（ceil代表向上取整） 除根节点以外的所有节点（不包含叶子节点）的孩子个数为关键字个数加1 所有叶子节点都位于同一层 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； B-树高度h（n个关键字，阶数为m）的取值范围： log_m(n+1)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2020%2F04%2F13%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是事务英文名是Transactions 一个事务是一个完整的业务逻辑单元，不可再分 比如：银行账户转账，从A账户向B账户转账10000，需要执行两条update语句 12update t_act set balance = balance-10000 where actno = &apos;act001&apos;;update t_act set balance = balance+10000 where actno = &apos;act002&apos;; 以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败 要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的事务机制 与事务相关的语句只有：DML语句（insert、delete、update）。为什么？因为它们这三个语句都是和数据库表当中的数据相关的，事务的存在是为了保证数据的完整性，安全性 假设所有的事务都能使用一条DML语句搞定，还需要事务机制么？答案：不需要事务了！然而在现实世界中是很少存在的，说这个只是为了说明事务的作用是保证数据的完整性和安全性 事务原理假设一个需求：需要先执行一条insert，再执行一条update，最后执行一条delete。它的过程是这样的： 开启事务机制（开始）：start transaction;或begin;放在最开始，代表开启一个事务 执行insert语句：这个执行成功之后，是把这个执行记录到数据库的操作历史缓存中，并不会向文件中保存一条数据，不会真正的修改硬盘上的数据 执行update语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据 执行update语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据 执行delete语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据 提交事务或者回滚事务（结束）：放在最后，代表结束一个事务 如果选择回滚ROLLBACK：只是把上述历史操作缓存中的记录清空，并不和数据打交道 如果选择提交COMMIT：会先让硬盘中的数据根据上述操作进行修改，然后清空上述历史操作缓存中的记录清空 还可以设置保存点savepoint： 在某些DML语句下面写一条：savepoint 保存点名;代表在这里设置了一个保存点。一个事务当中可以设置多个保存点。 如果不想回滚整个事务，只想回滚一部分怎么办？ 1mysql&gt; rollback to 保存点名; 这样会回滚到该savepoint处。 事务的特性事务包括四大特性：ACID Atomicity：原子性，整个事务中的所有操作，必须作为一个单元全部完成（或全部取消）。事务是最小的工作单元，不可再分 Consistency：一致性，事务必须保证多条DML语句同时成功或同时失败 Isolation：隔离性，一个事务不会影响其他事务的运行 Durability：持久性，在事务完成以后，该事务对数据库所作的更改将持久地保存在数据库之中，并不会被回滚 关于事务之间的隔离性事务隔离性存在隔离级别，理论上隔离级别包括四个（所有数据库都是从第二级别往上的，没人用第一级别）： 第一级别：读未提交（read uncommitted），允许一个事务可以看到其他事务未提交的修改。一个事务开始读取另外一个事务已经更新但没有能够及时提交的数据，这就出现了脏读取。读未提交存在脏读现象（Dirty Read），表示读到了脏的数据，数据很不稳定 第二级别：读已提交（read commited），允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。但存在一个问题：不可重复读（在同一个事务中，同一个读操作对同一个数据的前后两次读取产生了不同的结果）。这种隔离级别解决了脏读现象 第三级别：可重复读（repeatable read），确保如果在一个事务中执行两次相同的SELECT语句，都能得到相同的结果，不管其他事务是否提交这些修改。这种隔离级别解决了不可重复读问题。 第四级别：串行化读/序列化读（serializable），一个事务没结束的时候，另一个事务不允许开启。解决了所有问题，但效率低，需要事务排队 Oracle数据库默认的隔离级别是读已提交，MySQL默认的隔离级别是可重复读 MySQL事务默认情况下是自动提交的（只要执行任意一条DML语句则提交一次，即默认添加commit） 怎么关闭自动提交：start transaction; 如何设置MySQL数据库事务隔离级别： 1mysql&gt; set [global|session] transaction isolation level read uncommitted | read committed | repeatable read | serializable 设置事务的隔离级别的语句中，在SET关键字后可以放置GLOBAL关键字、SESSION关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下： 使用GLOBAL关键字（在全局范围影响）： 比方说这样： 1SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; 则： 只对执行完该语句之后产生的会话（每个客户端与服务器连接上之后，就可以称之为一个会话）起作用。 当前已经存在的会话无效。 使用SESSION关键字（在会话范围影响）： 比方说这样： 1SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; 则： 对当前会话的所有后续的事务有效 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。 如果在事务之间执行，则对后续的事务有效。 上述两个关键字都不用（只对执行语句后的下一个事务产生影响）： 比方说这样： 1SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 则： 只对当前会话中下一个即将开启的事务有效。 下一个事务执行完后，后续事务将恢复到之前的隔离级别。 该语句不能在已经开启的事务中间执行，会报错的。 如何查询当前事务隔离级别： 1mysql&gt; select @@transaction_isolation; 当多个客户端并发地访问同一个表时，可能出现下面的一致性问题： 脏读取（Dirty Read） 一个事务读到另一个事务尚未提交的修改，就是脏读。这里所谓的修改，除了Update操作,不要忘了还包括Insert和Delete操作。 脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。 不可重复读（Non-repeatable Read） 在同一个事务中，同一个读操作对同一个数据的前后两次读取产生了不同的结果，这就是不可重复读。针对update和delete 幻像读（Phantom Read） 幻像读是指在同一个事务中以前没有的行，由于其他事务的提交而出现的新行。针对insert 幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。如果delete了一些数据，后读取时发现数据少了，这个不叫幻读！ 那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。 隔离级别 脏读取 不可重复读 幻象读 read uncommitted 可能 可能 可能 read committed 不可能 可能 可能 repeatable read 不可能 不可能 对InnoDB不可能 serializable 不可能 不可能 不可能 注意：InnoDB存储引擎通过多版本并发控制（MVCC）解决了repeatable read中的幻象读的问题 不可重复读和幻读的区别很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。 如果使用锁机制来实现这两种隔离级别，在可重复读中，该SQL第一次读取到数据后，就将这些被读取的数据加行级锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免（当然了在InnoDB引擎中，采用可重复读就解决了幻象读的问题）。需要Serializable隔离级别 ，读用表级共享锁，写用表级排它锁，读锁和写锁互斥（即给表加表锁），这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。 所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。 对于这两种问题解决采用不同的办法，防止读到更改数据，只需对操作的数据添加行级锁，防止操作中的数据发生变化；而防止读到新增数据，往往需要添加表级锁，将整张表锁定，防止新增数据。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎]]></title>
    <url>%2F2020%2F04%2F13%2FMySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[什么是存储引擎存储引擎这个名字只有在MySQL中存在，Oracle中有对应的机制，但是不叫存储引擎，Oracle中没有特殊的名字，就是“表的存储方式” MySQL支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎 存储引擎的使用 数据库中的各表均被（在创建表时）指定的存储引擎来处理。 服务器可用的引擎依赖于以下因素： MySQL的版本 服务器在开发时如何被配置 启动选项 为了解当前服务器中有哪些存储引擎可用，可使用SHOW ENGINES语句： 1mysql&gt; SHOW ENGINES\G 在创建表时，可使用ENGINE选项为CREATE TABLE语句显式指定存储引擎。 1CREATE TABLE TABLENAME (NO INT) ENGINE = MyISAM; 如果在创建表时没有显式指定存储引擎，则该表使用当前默认的存储引擎 ，一般是InnoDB存储引擎 默认的存储引擎可在my.ini配置文件中使用default-storage-engine选项指定。 现有表的存储引擎可使用ALTER TABLE语句来改变： 1ALTER TABLE 表名 ENGINE = INNODB; 为确定某表所使用的存储引擎，可以使用SHOW CREATE TABLE或SHOW TABLE STATUS语句： 1234567891011121314151617181920212223mysql&gt; SHOW CREATE TABLE emp\Gmysql&gt; SHOW TABLE STATUS LIKE &apos;emp&apos; \G*************************** 1. row *************************** Name: emp Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 14 Avg_row_length: 1170 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2020-04-10 11:35:00 Update_time: 2020-04-10 11:35:00 Check_time: NULL Collation: utf8mb4_0900_ai_ci Checksum: NULL Create_options: Comment:1 row in set (0.00 sec) MySQL默认使用的存储引擎是InnoDB方式 MySQL8.0版本支持的存储引擎有9个 常用的存储引擎MyISAMEngine: MyISAMSupport: YESComment: MyISAM storage engineTransactions: NO XA: NO Savepoints: NO MyISAM这种存储引擎不支持事务，但是不是默认的存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表： 格式文件 — 存储表结构的定义（mytable.frm） 数据文件 — 存储表行的数据（mytable.MYD） 索引文件 — 存储表上索引（mytable.MYI） 灵活的AUTO_INCREMENT字段处理 可被转换为压缩、只读表来节省空间 优点：可被压缩，节省存储空间，并且可以转换成只读表，提高检索效率 缺点：不支持事务 InnoDB InnoDB存储引擎是MySQL的缺省引擎。 它管理的表具有下列主要特征： 每个InnoDB表结构的定义在数据库目录中以.frm格式文件表示 数据库中的所有表的数据和索引都存储在同一个InnoDB表空间tablespace中（这是默认情况下的。当然也可以为每一个表自定义一个独有的表空间） 提供一组用来记录事务性活动的日志文件 用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)支持事务处理，因为支持事务，所以很安全 提供全ACID兼容 在MySQL服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新 优点：支持事务、行级锁、外键等，这种存储引擎数据的安全得到保障（MyISAM不支持事务、不支持外键） MEMORY 使用MEMORY存储引擎的表，其数据和索引存储在内存中，且行的长度固定，这两个特点使得MEMORY存储引擎非常快。 MEMORY存储引擎管理的表具有下列特征： 在数据库目录内，每个表均以.frm格式的文件表示。 表数据及索引被存储在内存中（断电就没）。 表级锁机制。 不能包含TEXT或BLOB字段。 MEMORY存储引擎以前被称为HEAP引擎。 选择合适的存储引擎 MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制。 可使用MEMORY存储引擎来存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成的数据。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[union关键字]]></title>
    <url>%2F2020%2F04%2F13%2Funion%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[先说一下union的作用：可以将查询结果集相加 需求：找出工作岗位是MANAGER和SALESMAN的员工 方法一 12345678910111213mysql&gt; select ename,job from emp where job = &apos;manager&apos; or job = &apos;salesman&apos;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec) 方法二 12345678910111213mysql&gt; select ename,job from emp where job in (&apos;manager&apos;,&apos;salesman&apos;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec) 方法三：使用union 12345678910111213mysql&gt; select ename,job from emp where job = &apos;manager&apos; union select ename,job from emp where job = &apos;salesman&apos;;+--------+----------+| ename | job |+--------+----------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER || ALLEN | SALESMAN || WARD | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec) 注意：这里的查询结果的顺序是不一样的，因为我们是拼接而成的，所以顺序是排好序的。 有人可能就要问了，既然以前学的where子句中的or、in等操作符可以解决，那么为什么还要用union呢？ 因为存在or、in等操作符解决不了的问题。比如两张毫无相干的表结果想连接，or、in等就解决不了 比如： 123456789101112131415161718192021222324mysql&gt; select ename from emp union select dname from dept;+------------+| ename |+------------+| SMITH || ALLEN || WARD || JONES || MARTIN || BLAKE || CLARK || SCOTT || KING || TURNER || ADAMS || JAMES || FORD || MILLER || ACCOUNTING || RESEARCH || SALES || OPERATIONS |+------------+18 rows in set (0.00 sec) 这里emp和dept是两张毫无关系的表，如果想拼接在一块，必须使用unino。注意：最终查询结果显示的列名是第一个select语句中查询的列名。如果想显示别的名字，只需要给第一个select语句中的查询列重命名即可。 还要注意一点： union两边的seelct语句中的查询的字段的数目必须一致。比如union前面的select查询了两个字段，union后面的select查询的字段数目必须也是两个字段 建议：用union连接起来的各个查询语句的查询列表中位置相同的表达式的类型应该是相同的。当然这不是硬性要求，如果不匹配的话，MySQL将会自动的进行类型转换，比方说下边这个组合查询语句： 使用UNION来合并多个查询的记录会默认过滤掉重复的记录。举个例子 1234567891011121314151617181920212223242526272829303132mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | c |+------+------+3 rows in set (0.00 sec)mysql&gt; select * from t2;+------+------+| m2 | n2 |+------+------+| 2 | b || 3 | c || 4 | d || 2 | r |+------+------+4 rows in set (0.00 sec)mysql&gt; select m1,n2 from t1 union select m2,n2 from t2;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | c || 4 | d || 2 | r |+------+------+5 rows in set (0.00 sec) 由于t1表和t2表都有(2, b)、(3, c)这两条记录，所以合并后的结果集就把他俩去重了。如果我们想要保留重复记录，可以使用UNION ALL来连接多个查询： 12345678910111213mysql&gt; select m1,n1 from t1 union all select m2,n2 from t2;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | c || 2 | b || 3 | c || 4 | d || 2 | r |+------+------+7 rows in set (0.00 sec) 有union时如何使用order by和limit呢？ 组合查询会把各个查询的结果汇总到一块，如果我们想对最终的结果集进行排序或者只保留几行的话，可以在组合查询的语句末尾加上ORDER BY和LIMIT子句，就像这样： 12345678mysql&gt; select m1,n1 from t1 union select m2,n2 from t2 order by m1 desc limit 2;+------+------+| m1 | n1 |+------+------+| 4 | d || 3 | c |+------+------+2 rows in set (0.00 sec) 由于最后的结果集展示的列名是第一个查询中给定的列名，所以ORDER BY子句中指定的排序列也必须是第一个查询中给定的列名（别名也可以） 组合查询并不保证最后汇总起来的大结果集中的顺序是按照各个小查询的结果集中的顺序排序的，也就是说我们在各个小查询中加入ORDER BY子句的作用和没加一样 不过如果我们只是单纯的想从各个小的查询中获取有限条排序好的记录加入最终的汇总，那是可以滴，比如这样： 12345678mysql&gt; (SELECT m1, n1 FROM t1 ORDER BY m1 DESC LIMIT 1) UNION (SELECT m2, n2 FROM t2 ORDER BY m2 DESC LIMIT 1);+------+------+| m1 | n1 |+------+------+| 3 | c || 4 | d |+------+------+2 rows in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子查询]]></title>
    <url>%2F2020%2F04%2F10%2F%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[什么是子查询？子查询都可以出现在哪里？ select语句当中嵌套select语句，被嵌套的语句是子查询或内层查询。同理，嵌套子查询的语句称为外层查询。 子查询可以出现在： select后面 from后面 where后面 所有的子查询都必须用小括号扩起来，否则是非法的。 按位置分类where子句中嵌套子查询需求：找出高于平均薪资的员工 这里先写一个错误的方法： 12/*错误*/ mysql&gt; select * from emp where sal &gt; avg(sal); 为什么错误呢？因为where子句中不能使用聚集函数 正确做法如下： 第一步：找出平均薪资 123456mysql&gt; select avg(sal) from emp;+-------------+| avg(sal) |+-------------+| 2073.214286 |+-------------+ 第二步：where过滤 123456789101112mysql&gt; select * from emp where sal &gt; 2073.214286;+-------+-------+-----------+------+------------+---------+------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+-------+-----------+------+------------+---------+------+--------+| 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 |+-------+-------+-----------+------+------------+---------+------+--------+6 rows in set (0.00 sec) 第一步和第二步合并： 123456789101112mysql&gt; select * from emp where sal &gt; (select avg(sal) from emp);+-------+-------+-----------+------+------------+---------+------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+-------+-----------+------+------------+---------+------+--------+| 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 |+-------+-------+-----------+------+------------+---------+------+--------+6 rows in set (0.00 sec) from子句中嵌套子查询这个在实际应用中使用最多！！一定要掌握！！ from子句嵌套子查询的诀窍：一定要将中间结果当做一张临时表 需求：找出每个部门平均薪水的薪资等级 第一步：找出每个部门平均薪水（按照部门编号分组，求sal平均值） 123456789mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+3 rows in set (0.00 sec) 第二步：将以上的查询结果当作临时表t，让t表和salgrade表连接，连接条件是：t.avgsal between s.losal and s.hisal。 123456789mysql&gt; select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) as t join salgrade as s on t.avgsal between s.losal and s.hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 20 | 2175.000000 | 4 || 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 |+--------+-------------+-------+3 rows in set (0.00 sec) 再来一个需求：找出每个部门平均的薪水等级 第一步：找出每个员工的薪水等级，内连接查询，连接条件是e.sal between s.losal and s.hisal 1234567891011121314151617181920mysql&gt; select e.ename,e.deptno,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal;+--------+--------+-------+| ename | deptno | grade |+--------+--------+-------+| SMITH | 20 | 1 || ALLEN | 30 | 3 || WARD | 30 | 2 || JONES | 20 | 4 || MARTIN | 30 | 2 || BLAKE | 30 | 4 || CLARK | 10 | 4 || SCOTT | 20 | 4 || KING | 10 | 5 || TURNER | 30 | 3 || ADAMS | 20 | 1 || JAMES | 30 | 1 || FORD | 20 | 4 || MILLER | 10 | 2 |+--------+--------+-------+14 rows in set (0.00 sec) 第二步：将以上查询结果当作一张临时表t，针对表t以deptno进行分组，然后再对分组后的薪水等级求平均（avg） 123456789mysql&gt; select t.deptno,avg(t.grade) from (select e.ename,e.deptno,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal) as t group by t.deptno;+--------+--------------+| deptno | avg(t.grade) |+--------+--------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+--------------+3 rows in set (0.00 sec) 但是对于这个需求而言，没必要这么麻烦，下面有一种简单且效率更高的方法（不使用from子句嵌套子查询）： 123456789mysql&gt; select e.deptno,avg(s.grade) as avg_salgrade from emp as e join salgrade as s on e.sal between s.losal and hisal group by e.deptno;+--------+--------------+| deptno | avg_salgrade |+--------+--------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+--------------+3 rows in set (0.00 sec) 注意：不要一味的追求子查询！效率优先 select子句嵌套子查询select嵌套子查询十分少用，基本不用！！ 需求：找出每个员工所在的部门名称，要求显示员工名和部门名 这个用连接查询就可以解决 但是，这里为了学习子查询，我们重新考虑一下这个需求 123456789101112131415161718192021mysql&gt; select e.ename,(select d.dname from dept as d where e.deptno = d.deptno) as dname from emp as e;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec)/* 这是一个相关子查询，具体介绍见后面*/ 当然，如果你想写这个语句，先量一下你是不是发烧了！！连接查询它不香么？ 按结果分类上面的where子句嵌套子查询、from子句嵌套子查询和select子句嵌套子查询是根据子查询所处的位置来分类的。下面我们根据子查询出来的结果进行分类，主要包括： 标量子查询 列子查询 行子查询 表子查询 下面一一介绍！！ 标量子查询如果我们想查一下名叫&#39;杜琦燕&#39;的学生的各科成绩该怎么办呢？ 12345678mysql&gt; SELECT * FROM student_score WHERE number = (SELECT number FROM student_info WHERE name = &apos;杜琦燕&apos;);+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+-----------------------------+-------+2 rows in set (0.01 sec) 我们把第二条查询语句用小括号()扩起来作为一个操作数放到了第一条的搜索条件处，这样就起到了合并两条查询语句的作用。小括号中的查询语句也被称为子查询或者内层查询，使用内层查询的结果作为搜索条件的操作数的查询称为外层查询。如果你在一个查询语句中需要用到更多的表的话，那么在一个子查询中可以继续嵌套另一个子查询。 在这个例子中的子查询的结果只有一个值(也就是&#39;杜琦燕&#39;的学号)，这种子查询称之为标量子查询。 列子查询如果我们想查询&#39;计算机科学与工程&#39;专业的学生的成绩，我们需要先从student_info表中根据专业名称找到对应的学生学号，然后再通过学号到student_score表中找着对应的成绩信息，所以这个问题的解决方案就是书写下述两个查询语句： 第一步：找出计算机科学与工程相应学生的学号 12345678mysql&gt; select number from student_info where major=&apos;计算机科学与工程&apos;;+----------+| number |+----------+| 20180101 || 20180102 |+----------+2 rows in set (0.00 sec) 第二步：在student_score中找对应学号的成绩 12345678910mysql&gt; SELECT * FROM student_score WHERE number IN (20180101, 20180102);+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+-----------------------------+-------+4 rows in set (0.00 sec) 第二条查询语句的搜索条件也是用到了第一条查询语句的查询结果，我们自然可以想到把第一条查询语句作为内层查询，把第二条查询语句作为外层查询来将这两个查询语句合并为一个查询语句，就像这样： 12345678910mysql&gt; SELECT * FROM student_score WHERE number IN (SELECT number FROM student_info WHERE major = &apos;计算机科学与工程&apos;);+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+-----------------------------+-------+4 rows in set (0.00 sec) 很显然第一条查询语句的结果集中并不是一个单独的值，而是一个列（本例中第一条查询语句的结果集中该列包含2个值，分别是：20180101和20180102），所以它对应的子查询也被称之为列子查询。因为列子查询得到的结果是多个值，相当于一个列表。我们前边的章节中说过，IN和NOT IN操作符正好是用来匹配列表的，上边使用的例子是使用IN操作符和子查询的结果组成表达式来作为外层查询的搜索条件的。NOT IN和IN的操作符的使用方式是一样的，只不过语义不同罢了，我们就不赘述了。 行子查询有列子查询，大家肯定就好奇有没有行子查询。哈哈，当然有了，只要子查询的结果集中最多只包含一条记录，而且这条记录中有超过一个列的数据（如果该条记录只包含一个列的话，该子查询就成了标量子查询），那么这个子查询就可以被称之为行子查询，比如这样： 1234567mysql&gt; SELECT * FROM student_score WHERE (number, subject) = (SELECT number, &apos;母猪的产后护理&apos; FROM student_info LIMIT 1);+----------+-----------------------+-------+| number | subject | score |+----------+-----------------------+-------+| 20180104 | 母猪的产后护理 | 55 |+----------+-----------------------+-------+1 row in set (0.01 sec) 该子查询的查询列表是number, &#39;母猪的产后护理&#39;，其中number是列名，&#39;母猪的产后护理&#39;是一个常数。我们在子查询语句中加了LIMIT 1这个子句，意味着子查询最多只能返回一条记录，所以该子查询就可以被看作一个行子查询。 由于上述的子查询执行后产生的结果集是一个行（包含2个列），所以用作等值比较的另一个操作数也得是2个值，本例中就是(number, subject)（注意，这两个值必须用小括号()扩住，否则会产生歧义）。它表达的语义就是：先获取到子查询的执行结果，然后再执行外层查询，如果student_score中记录的number等于子查询结果中的number列并且subject列等于子查询结果中的&#39;母猪的产后护理&#39;，那么就将该记录加入到结果集。 表子查询如果子查询结果集中包含多行多列，那么这个子查询也可以被称之为表子查询，比如这样： 12345678mysql&gt; SELECT * FROM student_score WHERE (number, subject) IN (SELECT number, &apos;母猪的产后护理&apos; FROM student_info WHERE major = &apos;计算机科学与工程&apos;);+----------+-----------------------+-------+| number | subject | score |+----------+-----------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180102 | 母猪的产后护理 | 100 |+----------+-----------------------+-------+2 rows in set (0.00 sec) 按查询顺序分类按内层查询和外层查询的执行顺序，可分为两种： 不相关子查询 相关子查询 下面首先引入一个操作符 EXISTS和NOT EXISTS有时候外层查询并不关心子查询中的结果是什么，而只关心子查询的结果集是不是为空集，这时可以用到下边这两个操作符： 操作符 示例 描述 EXISTS EXISTS(SELECT…) 当子查询结果集不是空集时表达式为真 NOT EXISTS NOT EXISTS(SELECT…) 当子查询结果集是空集时表达式为真 我们来举个例子： 12mysql&gt; SELECT * FROM student_score WHERE EXISTS (SELECT * FROM student_info WHERE number = 20180108);Empty set (0.00 sec) 其中子查询的意思是在student_info表中查找学号为20180108的学生信息，很显然并没有学号为20180108的学生，所以子查询的结果集是一个空集，于是EXISTS表达式的结果为FALSE，所以外层查询也就不查了，直接返回了一个Empty set，表示没有结果。可以自己试一下NOT EXISTS的使用，和EXISTS用法一样。 不相关子查询当子查询和外层查询没有依赖关系，也就是说子查询可以独立运行并产生结果之后，再拿结果作为外层查询的条件去执行外层查询，这种子查询称为不相关子查询，比如下边这个查询： 12345678mysql&gt; SELECT * FROM student_score WHERE number = (SELECT number FROM student_info WHERE name = &apos;杜琦燕&apos;);+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+-----------------------------+-------+2 rows in set (0.00 sec) 子查询中只用到了student_info表而没有使用到student_score表，它可以单独运行并产生结果，这就是一种典型的不相关子查询。 上面的不相关子查询如何执行呢？ 先执行外层查询的from把student_score加载进来； 然后执行外层循环的where 先执行外层循环where子句中的子查询，由于是不相关子查询，所以查询结束后可以把查询结果缓存起来，将查询结果返回给外层查询 子循环的查询语句也遵循以下顺序：from -&gt; where -&gt; select 从student_score中一条一条的取记录，利用where条件进行筛选（记住，只有第一次筛选的时候才进入子查询，后面就不再进入了，直接去缓存里面取值！！这里和相关子查询有区别）。筛选完成后会得到一个结果集 最后再执行外层循环的select语句 对于不相关子查询而言，内层查询的执行独立于外层查询，内层查询仅执行一次，执行完毕后将结果作为外层查询的条件使用 相关子查询而有时候我们需要在子查询的语句中引用到外层查询的值，这样的话子查询就不能当作一个独立的语句去执行，这种子查询被称为相关子查询。比方说我们想查看一些学生的基本信息，但是前提是这些学生在student_score表中有成绩记录，那可以这么写： 12345678910mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE EXISTS (SELECT * FROM student_score WHERE student_score.number = student_info.number);+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 || 20180103 | 范统 | 17156319980116959X | 软件工程 || 20180104 | 史珍香 | 141992199701078600 | 软件工程 |+----------+-----------+--------------------+--------------------------+4 rows in set (0.00 sec) 这个例子中的相关子查询的查询过程是这样的（无论是相关子查询还是不相关子查询，都要严格遵守SQL查询语句执行顺序，见SQL查询语句的定义顺序和执行顺序）： 先执行外层查询获得到student_info表的第一条记录，发现它的number值是20180101。把20180101当作参数传入到子查询，此时子查询的意思是判断student_score表的number字段是否有20180101这个值存在，子查询的结果是该值存在，所以整个EXISTS表达式的值为TRUE，那么student_info表的第一条记录可以被加入到结果集。 再执行外层查询获得到student_info表的第二条记录，发现它的number值是20180102，与上边的步骤相同，student_info表的第二条记录也可以被加入到结果集。 与上边类似，student_info表的第三条记录也可以被加入到结果集。 与上边类似，student_info表的第四条记录也可以被加入到结果集。 再执行外层查询获得到student_info表的第五条记录，发现它的number值是20180105，把20180105当作参数传入到它的子查询，此时子查询的意思是判断student_score表的number字段是否有20180105这个值存在，子查询的结果是该值不存在，所以整个EXISTS表达式的值为FALSE，那么student_info表的第五条记录就不被加入结果集中。 与上一步骤类似，student_info表的第六条记录也不被加入结果集中。 student_info表没有更多的记录了，结束查询。 注意：在相关子查询中，内层查询的执行依赖于外层查询的数据，外部查询每执行一次，内部查询也会执行一次。这里和不相关子查询有较大的区别 个人理解：由于相关子查询的内层查询依赖于外层查询，所以不能放在from子句后面，只能放在where和select子句后面！ 为什么呢？个人理解是因为如果放在from子句中，肯定是存在连接查询的，和join共用。由于from…join…on是一套语句，基本可以认为同时进行，所以外层查询的表是不能用在内层查询中的（因为它们是同时载入进来的，当然不能用！只有from…join…on这一套语句用完之后，在其执行顺序后面的关键字语句才能使用该表名或者其表别名）]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接查询]]></title>
    <url>%2F2020%2F04%2F10%2F%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[什么是连接查询？在实际开发中，大部分情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。在实际开发中，一般一个业务都会对应多张表。比如：我们之前一直使用student_info和student_score两个表来分别存储学生的基本信息和学生的成绩信息，其实合并成一张表也不是不可以，假设将两张表合并后的新表名称为student_merge。student_merge中的每行记录可能是一个人的多条信息（因为一个人有多个成绩）。由于一个学生可能会有很多门学科的成绩信息，也就是说每当我们想为一个学生增加一门学科的成绩信息时，我们必须把他的基本信息再抄一遍，这种同一个学生的基本信息被冗余存储会带来下边的问题： 问题一：浪费存储空间。 问题二：当修改某个学生的基本信息时必须修改多处，很容易造成信息的不一致，增大维护的困难。 所以为了尽可能少的存储冗余信息，一开始我们就把这个所谓的student_merge表拆分成了student_info和student_score表，但是这两张表之间有某种关系作为纽带，这里的某种关系指的就是两个表都拥有的number列。拆分之后的表的确解决了数据冗余问题，但是查询数据却成了一个问题。 连接查询的分类 根据语法出现的年代来划分，包括： SQL92：一些老的DBA（数据库管理员）可能还在使用这种语法 SQL99：比较新的语法 根据表的连接方式来划分，包括： 内连接 等值连接 非等值连接 自连接 外连接 左外连接（又称为左连接） 右外连接（又称为右连接） 全连接：很少很少用 连接查询引入这里首先导入三张表，本节的内容全部是基于这三张表的： 员工信息表emp：字段从左到右依次为员工编号、员工姓名、职位、上级领导编号、入职日期、工资、补贴、部门编号 1234567891011121314151617181920mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+14 rows in set (0.01 sec) 部门信息表dept：字段从左到右依次为部门编号、部门名称、部门位置 12345678910mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+4 rows in set (0.01 sec) 薪资登记表salgrade：字段从左到右依次为薪资等级、该等级最低薪资、该等级最高薪资 1234567891011mysql&gt; select * from salgrade;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+5 rows in set (0.00 sec) 下面我们来个案例分析一下：找出每一个员工的部门名称，要求显示员工名和部门名。员工表中只有部门编号，没有部门名称。部门名称只存在于部门信息表中。下面我们先写一个连接查询语句（在MySQL中，连接查询的语法也很随意，只要在FROM语句后边跟多个用逗号,隔开的表名就好了）。 连接查询的语法较为简单： 1234567891011/*查询列表处的*代表从FROM语句后列出的表中选取每个列*/mysql&gt; select * from emp,dept;/*上面那种写法等效于下面这种写法*/mysql&gt; select emp.*,dept.* from emp,dept;/*如果只想查询出部分列*//*如果两个表中没有同名字段，可以这么查(但无论是否重名，建议加上表名，这样执行效率较高)*/mysql&gt; select ename,sal,dname from emp,dept;/*如果两个表中有同名字段，可以这么查*/mysql&gt; select emp.ename,emp.sal,dept.dname from emp,dept; 在表的连接查询方面有一种现象被称为：笛卡尔积现象。 举个例子： 1mysql&gt; select ename,dname from emp,dept; 最终上述语句会有56条查询结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061+--------+------------+| ename | dname |+--------+------------+| SMITH | ACCOUNTING || SMITH | RESEARCH || SMITH | SALES || SMITH | OPERATIONS || ALLEN | ACCOUNTING || ALLEN | RESEARCH || ALLEN | SALES || ALLEN | OPERATIONS || WARD | ACCOUNTING || WARD | RESEARCH || WARD | SALES || WARD | OPERATIONS || JONES | ACCOUNTING || JONES | RESEARCH || JONES | SALES || JONES | OPERATIONS || MARTIN | ACCOUNTING || MARTIN | RESEARCH || MARTIN | SALES || MARTIN | OPERATIONS || BLAKE | ACCOUNTING || BLAKE | RESEARCH || BLAKE | SALES || BLAKE | OPERATIONS || CLARK | ACCOUNTING || CLARK | RESEARCH || CLARK | SALES || CLARK | OPERATIONS || SCOTT | ACCOUNTING || SCOTT | RESEARCH || SCOTT | SALES || SCOTT | OPERATIONS || KING | ACCOUNTING || KING | RESEARCH || KING | SALES || KING | OPERATIONS || TURNER | ACCOUNTING || TURNER | RESEARCH || TURNER | SALES || TURNER | OPERATIONS || ADAMS | ACCOUNTING || ADAMS | RESEARCH || ADAMS | SALES || ADAMS | OPERATIONS || JAMES | ACCOUNTING || JAMES | RESEARCH || JAMES | SALES || JAMES | OPERATIONS || FORD | ACCOUNTING || FORD | RESEARCH || FORD | SALES || FORD | OPERATIONS || MILLER | ACCOUNTING || MILLER | RESEARCH || MILLER | SALES || MILLER | OPERATIONS |+--------+------------+56 rows in set (0.01 sec) 上面的连接查询结果显然是不符合要求的！因为一个人只会有一个部门，而上面一个人有四个部门，这显然是不可以的！ 连接的本质就是把各个表中的记录都取出来，依次匹配的组合加入结果集并返回给用户。上述查询结果看起来就是把emp表的记录和dept表的记录连接起来组成新的更大的记录，这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一个记录与另一个表中的每一条记录相互匹配的结果，像这样的结果集就可以称之为笛卡尔积。 那么什么是笛卡尔积现象呢：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果是两张表记录条数的乘积！ 上面连接查询的内部过程：在emp表中取出一条记录和dept表的每条记录依次组合，这样的话emp中的一条记录会组合成四条记录。这样最终查询结束后会有14*4=56条记录，这就是笛卡尔积现象 如果我们乐意，我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的笛卡尔积可能是非常巨大的。比方说3个100行记录的表连接起来产生的笛卡尔积就有100×100×100=1000000行数据！所以在连接的时候过滤掉特定记录组合是有必要的 关于表的别名对于上面那个案例中的连接查询语句： 1mysql&gt; select ename,dname from emp,dept; 上述语句肯定能查出来结果，没有问题！但是我们要注意：它只是恰巧两个表中没有重复的字段名，如果emp和dept中都有ename，那该查询哪一个呢？比如有两个表t1和t2，表t1中有字段m1,n1；表t2中有m1,n2，其中两个表有同名字段m1。现在要连接查询t1的m1和t2的n2的话，就不能用上面那种方法了，必须显示地表示出来： 1mysql&gt; select t1.m1,t2.n2 from t1,t2; 如果表名特别长的情况下，可以为表来定义别名，让语句表达更清晰一些。 表的别名语法：AS跟列别名一样，可以省略 1mysql&gt;select e.ename,d.dname from emp as e,dept as d; 表的别名有以下优点： 执行效率高：对于select ename,dname from emp,dept;这条连接查询语句而言，在找ename的时候既会去emp中找ename，也会去dept中找ename，这样效率较低。 可读性好 所以这里我们强调一下：连接查询一定要用表别名，这是一种好习惯！ 这里一定要注意一点：如果使用别名来代表一个表，那么在定义别名后的所有查询语句中，都必须使用别名来代表表的全名，否则系统会出错。 怎么避免笛卡尔积现象当然是加条件进行过滤！ 这里问个问题：避免了笛卡尔积现象，会减少记录的匹配次数么？ 答案：不会！上面的匹配次数还是56次，只不过显示的是有效记录。所以执行效率并没有提高 现在对于上面那个案例：找出每一个员工的部门名称，要求显示员工名和部门名。怎么解决呢？ 1234567891011121314151617181920mysql&gt; select e.ename,d.dname from emp as e,dept as d where e.deptno = d.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec) 上述代码就解决了我们的需求，避免了笛卡尔积现象！但是匹配此时还是56次，只不过是4选1。但是上面的语法是SQL92语法，已经过时了，我们一般不用它了，哈哈哈！别急，我们下面来讲SQL99（下面的内连接和外连接都是基于SQL99来讲的）！SQL99中的连接查询也可以称为join on语法 内连接等值连接最大的特点是：连接条件中的关系是等量关系（等号=） 需求：找出每一个员工的部门名称，要求显示员工名和部门名 1mysql&gt; select e.ename,d.dname from emp as e join dept as d on e.deptno = d.deptno; 注意上述语句和SQL92语句的区别！ 上面的语句还可以写成： 1mysql&gt; select e.ename,d.dname from emp as e inner join dept as d on e.deptno = d.deptno; 它们的区别是：下面的语句在join前多了一个inner，代表内连接。inner可以省略，带上inner之后可读性更好！ 为什么一定要用SQL99呢？因为它优秀呀： SQL99表连接条件ON和进行数据过滤的条件where分离了。SQL92中把表连接条件和数据过滤条件全部融合在where中，语法结构不清晰；但是对于SQL99，表连接条件就在ON，数据过滤条件就在where，语法十分清晰 非等值连接最大的特点：连接条件中的关系是非等量关系 再来个需求：找出每个员工的工资等级，要求显示员工名、工资和工资等级 上面需求的连接条件：emp表中员工的薪资sal，在salgrade表中薪资等级对应的最低和最高工资之间。 根据上述条件，可以这么写 1234567891011121314151617181920mysql&gt; select e.ename,e.sal,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal;+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+14 rows in set (0.00 sec) 自连接最大的特点是：一张表硬看成两张表，自己连接自己，且一定要用表别名 其实自连接既可以是内连接，也可以是外连接，它本质上还是两张表的连接，只不过自连接的两张表是同一张表 需求：找出每个员工的上级领导，要求显示员工名和对应的领导名 所有员工（有的员工是领导）的信息都在员工信息表emp中，每个员工有对应的上级领导编号，而这个上级领导编号也是该领导的员工编号，这里好像有点绕~，但自己要理解一下 员工的上级领导编号 = 领导的员工编号（这句话一定要理解） 所以这里我们可以认为有两张表，它们都是emp表，分别取别名a和b，我们自己可以认为a是员工表，b是领导表（a和b本质上是同一张表） SQL语句该这么写： 12345678910111213141516171819mysql&gt;select a.ename as &apos;员工&apos;,b.ename as &apos;领导&apos; from emp as a join emp as b on a.mgr = b.empno;+--------+-------+| ename | ename |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+13 rows in set (0.01 sec) 注意：为什么上面的结果只有13条记录呢？明明这个公司有14个人呀！仔细观察emp表可以发现，KING这个员工没有上级领导，他对应的上级领导编号为NULL，所以这里匹配不到！ 注意：表的自连接既可以是等值连接，也可以是非等值连接 外连接什么是外连接？和内连接有什么区别？ 内连接： ​ 假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来 ​ A表和B表没有主副之分，两张表是平等的 ​ 对于内连接的两个表，如果A表中的记录在B表中找不到匹配的记录，该记录不会加入到最后的结果集 外连接： ​ 假设A和B表进行连接，使用外连接的话，A、B两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表。当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配 ​ 对于外连接的两个表，主表中的记录即使在副表中没有匹配的记录，也仍然需要加入到结果集，只不过该记录中对应的副表中的字段全部自动赋值为NULL 外连接的分类 左外连接：表示左边的表是主表 右外连接：表示右边的表是主表 任何一个左连接都有一个右连接的写法，任何一个右连接都有一个左连接的写法 ​ 左连接需求：找出每个员工的上级领导，要求显示员工名和对应的领导名 上面用内连接解决这个需求的时候，只查出了13条记录，KING的员工记录不存在于最终的结果集中，这是不符合需求的。如果我们想查出全部14个员工的记录呢，此时就需要用外连接！ SQL语句怎么写？ 1234567891011121314151617181920mysql&gt; select a.ename as &apos;员工&apos;,b.ename as &apos;领导&apos; from emp as a left join emp as b on a.mgr = b.empno;+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+14 rows in set (0.00 sec) 注意和内连接的区别，现在就是有14条记录了，KING对应的领导是NULL。由于我们想对所有的员工都有记录，所以要将a设置为主表，因此采用左连接。 注意：上面的左连接语句也是省略写法，完整写法是： 1mysql&gt; select a.ename as &apos;员工&apos;,b.ename as &apos;领导&apos; from emp as a left join emp as b on a.mgr = b.empno; outer可以省略 右连接需求和上面一样，右连接写法如下： 1234567891011121314151617181920mysql&gt; select a.ename as &apos;员工&apos;,b.ename as &apos;领导&apos; from emp as b right join emp as a on a.mgr = b.empno;+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+14 rows in set (0.00 sec) 任何一个左连接都有一个右连接的写法，任何一个右连接都有一个左连接的写法 上面的右连接完整写法是： 1mysql&gt; select a.ename as &apos;员工&apos;,b.ename as &apos;领导&apos; from emp as b right outer join emp as a on a.mgr = b.empno; outer可以省略 区分内连接和外连接，不是靠的outer或inner，而是right或left。省略后，只要没有left或right一定是内连接；只要有了right或left一定是外连接 实际开发中，外连接使用居多！！！因为内连接可能存在数据丢失！！！ 外连接最重要的特点是：主表的数据无条件的全部查询出来 下面来个需求测试一下学习结果：找出哪个部门没有员工，并显示出该部门的信息 用外连接来写 1234567mysql&gt; select d.* from dept as d left join emp as e on d.deptno = e.deptno where e.ename is NULL;+--------+------------+--------+| DEPTNO | DNAME | LOC |+--------+------------+--------+| 40 | OPERATIONS | BOSTON |+--------+------------+--------+1 row in set (0.00 sec) 多表连接查询多表连接查询语法： 1mysql&gt; select * from A join B on 连接条件1 join C on 连接条件2; 上面语法的解释：A先跟B连接查询（这里内连接、外连接均可），利用连接条件1进行筛选，这样A和B连接查询结果集中会有一个结果；然后这个结果再跟C表进行连接查询，利用连接条件2进行筛选。 需求：找出每一个员工的部门名称以及工资等级 1234567891011121314151617181920mysql&gt; select e.ename,d.dname,s.grade from emp as e join dept as d on e.deptno = d.deptno join salgrade as s on e.sal between s.losal and s.hisal;+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+14 rows in set (0.00 sec) 下面对上面的需求升级难度：找出每一个员工的部门名称、工资等级以及上级领导姓名 这个时候其实是四个表相连，而上面那个需求是三个表相连，并且这个要用到外连接。其实这个需求只需要在上个需求的基础上再连接一个表即可（自连接且左连接，注意left的位置不能放到前面的join，因为这里代表e和e1外连接，所以只能放在最后一个join前面） 1234567891011121314151617181920mysql&gt; select e.ename as &apos;员工&apos;,d.dname,s.grade,e1.ename as &apos;领导&apos; from emp as e join dept as d on e.deptno = d.deptno join salgrade as s on e.sal between s.losal and s.hisal left join emp as e1 on e.mgr = e1.empno;+--------+------------+-------+-------+| 员工 | dname | grade | 领导 |+--------+------------+-------+-------+| SMITH | RESEARCH | 1 | FORD || ALLEN | SALES | 3 | BLAKE || WARD | SALES | 2 | BLAKE || JONES | RESEARCH | 4 | KING || MARTIN | SALES | 2 | BLAKE || BLAKE | SALES | 4 | KING || CLARK | ACCOUNTING | 4 | KING || SCOTT | RESEARCH | 4 | JONES || KING | ACCOUNTING | 5 | NULL || TURNER | SALES | 3 | BLAKE || ADAMS | RESEARCH | 1 | SCOTT || JAMES | SALES | 1 | BLAKE || FORD | RESEARCH | 4 | JONES || MILLER | ACCOUNTING | 2 | CLARK |+--------+------------+-------+-------+14 rows in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分组查询]]></title>
    <url>%2F2020%2F04%2F09%2F%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[进行分组查询主要有两个关键字： group by：按照某个字段或者某些字段进行分组 having：having是对分组后的数据再次过滤（注意和where的区别，where子句的作用是在分组前就对数据进行过滤，having子句的作用是筛选满足条件的组，即在分组后过滤数据） 分组数据复杂的数据统计前边介绍了一些用来统计数据的聚集函数，我们可以方便的使用这些函数来统计出某列数据的行数、最大值、最小值、平均值以及整列数据的和。但是有些统计是比较麻烦的，比如说老师想根据成绩表分别统计出&#39;母猪的产后护理&#39;和&#39;论萨达姆的战争准备&#39;这两门课的平均分，那我们需要下边两个查询： 123456789101112131415mysql&gt; SELECT AVG(score) FROM student_score WHERE subject = &apos;母猪的产后护理&apos;;+------------+| AVG(score) |+------------+| 73.0000 |+------------+1 row in set (0.00 sec)mysql&gt; SELECT AVG(score) FROM student_score WHERE subject = &apos;论萨达姆的战争准备&apos;;+------------+| AVG(score) |+------------+| 73.2500 |+------------+1 row in set (0.00 sec) 如果课程增加到20门怎么办呢？我们一共需要写20个查询语句，这样神烦哎。为了在一条查询语句中就完成这20条语句的任务，所以引入了分组的概念，就是：针对某个列，将该列的值相同的记录分到一个组中。拿subject列来说，按照subject列分组的意思就是将subject列的值是&#39;母猪的产后护理&#39;的记录划分到一个组中，将subject列的值是&#39;论萨达姆的战争准备&#39;的记录划分到另一个组中，如果subject列还有别的值，则划分更多的组。其中分组依靠的列我们可以称之为分组列。所以在student_score表中按照subject列分组后的图示就是这样： subject列中有多少不重复的课程，那就会有多少个分组。幸运的是，只要我们在GROUP BY子句中添加上分组列就好了，MySQL会帮助我们自动建立分组来方便我们统计信息。 group by：按照某个字段或某些字段对数据进行分组 如果我们想统计每门课的平均分，具体语句如下： 12345678mysql&gt; SELECT subject, AVG(score) FROM student_score GROUP BY subject;+-----------------------------+------------+| subject | AVG(score) |+-----------------------------+------------+| 母猪的产后护理 | 73.0000 || 论萨达姆的战争准备 | 73.2500 |+-----------------------------+------------+2 rows in set (0.01 sec) 这个查询的执行过程就是按照subject中的值将所有的记录分成两组，然后分别对每个分组中记录的score列调用AVG函数进行数据统计。 注意：SQL语句中有一个规则：当一条语句中有group by 的话，select后面只能跟聚集函数（count、max、min、sum和avg，注意聚集函数里面的字段可以随意，不一定非要是参与分组的字段）和参与分组的字段。如果select后面跟了别的字段，对于Oracle而言会报错，语法错误；但是在MySQL中是有查询结果的，但是结果毫无意义。Oracle的语法规则比MySQL的语法规则更严谨。 带有WHERE子句的分组查询上边的例子是将表中每条记录都划分到某个分组中，我们也可以在划分分组前就将某些记录过滤掉，这时就需要使用WHERE子句了。比如老师觉得各个科目的平均分太低了，所以想先把分数低于60分的记录去掉之后再统计平均分，就可以这么写： 12345678mysql&gt; SELECT subject, AVG(score) FROM student_score WHERE score &gt;= 60 GROUP BY subject;+-----------------------------+------------+| subject | AVG(score) |+-----------------------------+------------+| 母猪的产后护理 | 89.0000 || 论萨达姆的战争准备 | 82.3333 |+-----------------------------+------------+2 rows in set (0.00 sec) 这个过程可以分成两个步骤理解： 将记录进行过滤后再分组。 在进行分组前就过滤掉不符合WHERE子句的记录，所以，最后的分组情况其实是这样的（少于60分的记录被过滤掉了） 分别对各个分组进行数据统计。 统计之后就产生了上述的结果。 多字段分组有时候按照某个列进行分组太笼统，一个分组内可以被继续划分成更小的分组。比方说对于student_info表来说，我们可以先按照department来进行分组，所以可以被划分为2个分组： 我们觉得这样按照department分组后，各个分组可以再按照major来继续分组，从而划分成更小的分组，所以再次分组之后的样子就是这样： 所以现在有了2个大分组，4个小分组，我们把这种对大的分组下继续分组的的情形叫做嵌套分组，如果你乐意，你可以继续把小分组划分成更小的分组。我们只需要在GROUP BY子句中把各个分组列依次写上，用逗号,分隔开就好了。比如这样： 12345678910mysql&gt; SELECT department, major, COUNT(*) FROM student_info GROUP BY department, major;+-----------------+--------------------------+----------+| department | major | COUNT(*) |+-----------------+--------------------------+----------+| 航天学院 | 电子信息 | 1 || 航天学院 | 飞行器设计 | 1 || 计算机学院 | 计算机科学与工程 | 2 || 计算机学院 | 软件工程 | 2 |+-----------------+--------------------------+----------+4 rows in set (0.00 sec) 可以看到，在嵌套分组中，聚集函数将作用在最后一个分组列上，在这个例子中就是major列。注意：select后面还是只能跟分组列和聚集函数，只不过这里可以写多个分组列。那能不能在select后面只写部分分组列呢？答案是可以，但是聚集函数只针对最后一个分组列。例如 12345678910mysql&gt; SELECT department, COUNT(*) FROM student_info GROUP BY department, major;+------------+----------+| department | COUNT(*) |+------------+----------+| 计算机学院 | 2 || 计算机学院 | 2 || 航天学院 | 1 || 航天学院 | 1 |+------------+----------+4 rows in set (0.00 sec) 分组和排序如果我们想对各个分组查询出来的统计数据进行排序，需要为select列表中有聚集函数的表达式添加别名，比如想按照各个学科的平均分从大到小降序排序，可以这么写： 12345678mysql&gt; SELECT subject, AVG(score) AS avg_score FROM student_score GROUP BY subject ORDER BY avg_score DESC;+-----------------------------+-----------+| subject | avg_score |+-----------------------------+-----------+| 论萨达姆的战争准备 | 73.2500 || 母猪的产后护理 | 73.0000 |+-----------------------------+-----------+2 rows in set (0.01 sec) 前面已经详细介绍了order by的用法。这里需要注意下当group by和order by一起使用时，有以下注意事项： order by后面排序的字段必须是聚合函数（当然这里并不是只能放置在select中出现的聚集函数，只要是针对分组的聚集函数都可以）或者group by中参与分组的字段（我在MySQL也尝试使用了非分组列，同样没有报错，但是排序结果毫无意义！） 当有group by时，order by后面也可以多列排序（用什么列见第一条） 作用于分组的过滤条件有时候某个带有GROUP BY子句的查询中可能会产生非常多的分组，假设student_score表中存储了100门学科的成绩，也就是subject列中有100个不重复的值，那就会产生100个分组，也就意味着这个查询的结果集中会产生100条记录。如果我们不想在结果集中得到这么多记录，只想把那些符合某些条件的分组加入到结果集，从而减少结果集中记录的条数，那就需要把针对分组的条件放到HAVING子句了。比方说老师想要查询平均分大于73分的课程，就可以这么写： 1234567mysql&gt; SELECT subject, AVG(score) FROM student_score GROUP BY subject HAVING AVG(score) &gt; 73;+-----------------------------+------------+| subject | AVG(score) |+-----------------------------+------------+| 论萨达姆的战争准备 | 73.2500 |+-----------------------------+------------+1 row in set (0.00 sec) 那么问题来了，having子句后面可以跟什么东西来进行组筛选呢？ 有两种： 分组列：也就是说我们可以把group by中用于分组的列放到HAVING子句的条件中，比如这样： 1SELECT subject, AVG(score) FROM student_score GROUP BY subject having subject = &apos;母猪的产后护理&apos;; 聚集函数：当然，并不是HAVING子句中只能放置在select列表出现的那些聚集函数，只要是针对这个分组进行统计的聚集函数都可以，比方说老师想查询最高分大于98分的课程的平均分，可以这么写： 1234567mysql&gt; SELECT subject, AVG(score) FROM student_score GROUP BY subject HAVING MAX(score) &gt; 98;+-----------------------+------------+| subject | AVG(score) |+-----------------------+------------+| 母猪的产后护理 | 73.0000 |+-----------------------+------------+1 row in set (0.00 sec) 其中的MAX(score)这个聚集函数并没有出现在查询列表中，但仍然可以作为HAVING子句中表达式的一部分。 下面我们考虑一个需求：有一个表emp，表中有每个人的部门字段no，薪资字段sal。查询每个部门的最高薪资，要求显示的最高薪资大于2000。可以用下面这种方式： 1mysql&gt; select no,max(sal) from emp group by no having max(sal)&gt;2000; 但是上面这种方式效率较低：它已经将所有的数据进行了分组，然后再进行分组后的筛选。下面给出一种效率高的方式 1mysql&gt; select no,max(sal) from emp where sal&gt;2000 group by no; 由于where子句在group by子句之前执行，即先进行数据筛选再分组，这样可大幅提高效率。所以，在having和where都能用的情况下，尽量用where，这样效率高 但是有的时候，有些需求只能用having，不能用where。例如：查询每个部门的平均工资，要求显示平均薪资大于2000的数据。 这里不能再用where了，只能使用having。如下所示 1mysql&gt; select no,avg(sal) from emp group by no having avg(sal)&gt;2000; 注意：having是group by的搭档，只有group by出现的时候，having才能用！没有group by，having是不能用的 使用分组注意事项使用分组来统计数据给我们带来了非常大的便利，但是要随时提防有坑的地方： 如果分组列中含有NULL值，那么NULL也会作为一个独立的分组存在。 如果存在多个分组列，也就是嵌套分组，聚集函数将作用在最后的那个分组列上。 如果查询语句中存在WHERE子句和ORDER BY子句，那么GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 非分组列不能单独出现在select列表中(可以被放到聚集函数中)。 GROUP BY子句后也可以跟随表达式(但不能是聚集函数，聚集函数只能出现在having、select和order by子句中)。 上边介绍的GROUP BY后跟随的都是表中的某个列或者某些列，其实一个表达式也可以，比如这样： 123456789101112mysql&gt; SELECT concat(&apos;专业：&apos;, major), COUNT(*) FROM student_info GROUP BY concat(&apos;专业：&apos;, major);+-----------------------------------+----------+| concat(&apos;专业：&apos;, major) | COUNT(*) |+-----------------------------------+----------+| 专业：电子信息 | 1 || 专业：计算机科学与工程 | 2 || 专业：软件工程 | 2 || 专业：飞行器设计 | 1 |+-----------------------------------+----------+4 rows in set (0.00 sec)mysql&gt; MySQL会根据这个表达式的值来对记录进行分组，使用表达式进行分组的时候需要特别注意，查询列表中的表达式和GROUP BY子句中的表达式必须完全一样。不过一般情况下我们也不会用表达式进行分组，所以目前基本没啥用～ WHERE子句和HAVING子句的区别。 WHERE子句在分组前进行过滤，作用于每一条记录，WHERE子句过滤掉的记录将不包括在分组中。而HAVING子句在数据分组后进行过滤，作用于整个分组，所以使用having进行筛选就是一组一组的筛选，如果这个组不符合条件，那么这个组的数据我都不要，就是这么傲娇~。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种运算对于NULL值的处理]]></title>
    <url>%2F2020%2F04%2F09%2F%E5%90%84%E7%A7%8D%E8%BF%90%E7%AE%97%E5%AF%B9%E4%BA%8ENULL%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[我们首先来看一下MySQL默认对于NULL值怎么处理： 只要有NULL参与的运算结果一定是NULL。比如A是表中的一个列，如果列中存在NULL值，那么该行的运算结果也为NULL值。注意：这里如果有函数参与，比如COS(A)、CONCAT(A,’OK’)，只要A中有NULL值，最终该行的运算结果一定是NULL值 12mysql&gt; select A*12 from package;/* 如果A中的一些行有NULL值，那么该行最终的运算结果一定是NULL值*/ 五个聚集函数对于NULL值的处理 count(*)比较特殊，它会包含NULL count(列名)会忽略NULL值 count(NULL)的结果是0 avg、max、min、avg全部忽略NULL值 avg(NULL)、max(NULL)、min(NULL)、avg(NULL)运算结果均为NULL 分组函数group by对于NULL值的处理 不会忽略它，会将其单独作为组中的一项 distinct对于NULL值的处理 同group by 那么碰到NULL值该怎么处理呢？ 场景：表emp，每个人的工资由两部分组成：基本工资+津贴。每个人的月基本工资sal一定不是NULL，而有的人的月津贴com可能为NULL。现在我们需要计算每个人的年薪。先说一下错误的处理方式： 1mysql&gt; select name,(sal+com)*12 as yearsal from emp; 上述SQL语句可能存在一个问题：如果有人的津贴为NULL，那么最终计算出来的年薪就为NULL。这显然是不符合要求的。 于是，引入ifnull(expression,alt_value)函数，该函数代表如果该表达式的结果为NULL，那么就用0代替它。 上面的问题可以这样解决 1mysql&gt; select name,(sal+ifnull(com,0))*12 as yearsal from emp;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MySQL中的单引号、双引号和反引号]]></title>
    <url>%2F2020%2F04%2F09%2F%E5%85%B3%E4%BA%8EMySQL%E4%B8%AD%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E3%80%81%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8D%E5%BC%95%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[有以下四条使用规则： MySQL的数据库名、表名、字段名通常不需要加任何引号；如果非要加上引号，必须加反引号（一般在ESC键的下方。它是为了区分MySQL的保留字与普通字符而引入的符号）。通常哪些情况要加呢？ 如果你建表的时候，列名选用了关键字，比如select、insert等。此时不加反引号会报错，因此必须加上反引号 如果建表的时候，列名之间包含空格，此时必须要加反引号 MySQL的列别名可以不加引号；如果要加引号，单引号、双引号和反引号都可以。那么什么时候要加引号呢？ 如果在查询时设置的列别名之间有空格、或是采用了保留关键字，不加引号会报错 MySQL的表别名可以不加引号；如果要加引号，只能是反引号（注意这里和列别名有区别，表别名只能用反引号） 如果在查询时设置的表别名之间有空格、或是采用了保留关键字，不加反引号会报错 单引号和双引号都可以表示字符串（但是在Oracle里是没有双引号的概念的，只有单引号。所以我们平时使用也尽量全用单引号就可以了）。这一条主要有以下的情况： 比如往表中insert数据时，数据里如果有字符串，就用单引号或双引号括起来 总而言之，除了上面三种情况，其余SQL语句中出现的字符串都需要加上单引号或双引号]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数据的导入导出]]></title>
    <url>%2F2020%2F04%2F09%2FSQL%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[利用数据库开发时，可能会存在下面的小需求： 我们想将数据库备份一下，以免后面有小白兔删库跑路~ 想将一个数据库里面的表导入到另一个数据库里面 下班想回家加班，就把单位的数据库备份一份带回去开发 凡是上面的需求，都需要将数据库导出成sql脚本文件，会生成一个*.sql文件。下面我们分别讲解一下如何导出和导入 导出数据其实很简单的，就是一条语句就可以了，首先我们打开cmd，不用进mysql指令界面，直接在windows的dos命令窗口按照下列格式将导出语句敲进去，然后再输入密码即可了。但有时候我们想导出整个数据库，有时候又想导出数据库里面的一个表，这个时候就会有细小的差别，下面分别说一下： 导出整个数据库 123mysqldump -u用户名 -p 数据库名&gt;路径+导出的文件名// 举个例子，这里run是待导出的数据库，存储在D盘下，导出的文件名是run.sqlmysqldump -uroot -p run&gt;d:/run.sql 导出一个表 123mysqldump -u用户名 -p 数据库名 表名&gt;路径+导出的文件名// 举个例子，这里run是待导出的数据库，t1是run中待导出的表名，存储在D盘下，导出的文件名是t1.sqlmysqldump -uroot -p run t1&gt;d:/t1.sql 导出多个表 123mysqldump -u用户名 -p 数据库名 表名1 表名2&gt;路径+导出的文件名// 举个例子，这里run是待导出的数据库，t1、t2是run中待导出的表名，存储在D盘下，导出的文件名是t1.sqlmysqldump -uroot -p run t1 t2&gt;d:/t.sql 导出一个数据库结构 意味着只导出数据库中所有表的结构，不导出数据 123mysqldump -u用户名 -p -d 数据库名&gt;路径+导出的文件名mysqldump -uroot -p -d run&gt;d:/run.sql// -d表示没有数据 只导出一个表结构 意味着只导出一个表中的结构，不导出数据 123mysqldump -u用户名 -p -d 数据库名 表名&gt;路径+导出的文件名mysqldump -uroot -p -d run t1&gt;d:/t1.sql// -d表示没有数据 导入数据 进入mysql控制台 1mysql -uroot -p 使用CREATE DATRABSE [数据库名字]创建一个数据库，然后使用use [数据库名]选择要使用的数据库 12mysql&gt; create database copy;mysql&gt; use copy; 直接使用source [所在的路径/*.sql] 将SQL文件进行导入 1mysql&gt; source d:/t1.sql;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL概述]]></title>
    <url>%2F2020%2F04%2F09%2FMySQL%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[sql、DB和DBMS分别是什么，它们之间的关系？ DB：DataBase，数据库，数据库实际上在硬盘上以文件的形式存在 DBMS：DataBase Management System，数据库管理系统，常见的有MySQL、Oracle、SqlServer等 SQL：结构化查询语言，是一门标准通用的语言，标准的sql适合于所有的数据库产品。SQL语句在执行的时候，实际上内部也会进行编译，然后再执行SQL语句，SQL语句的编译由DBMS完成 总结：DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据 SQL语句分类 DQL（数据查询语言）：查询语句，凡是select语句都是DQL DML（数据操作语言）：insert，delete、update，对表当中的数据进行增删改 DDL（数据定义语言）：create，drop，alter，对表结构的增删改 TCL（事务控制语言）：commit提交事务，rollback回滚事务 DCL（数据控制语言）：grant授权，revoke撤销权限等]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于访问控制权限]]></title>
    <url>%2F2020%2F04%2F08%2F%E5%85%B3%E4%BA%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[访问控制权限修饰符： 访问控制权限修饰符来控制元素的访问范围 访问控制权限修饰符包括： public：表示公开的，在任何位置都能访问 private：表示私有的，只能在本类访问 protected：同包下可以访问，子类（可以不同包的子类）中可以访问 缺省：只有同包下可以访问 可以修饰类和接口（类和接口只能使用public和缺省进行修饰，内部类除外）、变量、方法 修饰符的范围：private &lt; 缺省 &lt; protected &lt; public 下面对四种修饰符分别介绍一下： public 当public修饰类时，该类可以在同包中被访问（比如在同一个包下的另一个文件中，可以直接访问到该类，用该类实例化对象、继承等）；也可以在不同包中被访问，不过此时需要用import把该类先引入进来，随后可以用该类实例化对象、继承等 当public修饰变量、方法时，分以下情况： 变量、方法所处的类被public修饰，该类可以被本包的类继承，也可以被别的包的类继承，可以在本包被实例化，也可以在别的包中被实例化，无论是继承还是实例化，子类和实例化对象都可以访问该被public修饰的变量和方法 变量、方法所处的类默认缺省修饰符，该类只能被本包的类继承或在本包被实例化，注意不能被别的包的类继承或在别的包被实例化。在本包被继承或本包实例化后，可以访问该被public修饰的变量和方法 protected protected只能修饰变量和方法，当protected修饰变量、方法时，分以下情况： 变量、方法所处的类被public修饰，该类可以被本包的类继承，也可以被别的包的类继承，可以在本包被实例化，也可以在别的包中被实例化。当被本包的类继承、被别的包的类继承或者在本包被实例化时，可以访问该被protected修饰的变量或方法；当在别的包中实例化时，不能访问该变量或方法 变量、方法所处的类默认缺省修饰符，该类只能被本包的类继承或在本包被实例化，注意不能被别的包的类继承或在别的包被实例化。在本包被继承或本包实例化后，可以访问该被protected修饰的变量和方法 private private只能修饰变量和方法，当private修饰变量、方法时，分以下情况： 变量、方法所处的类被public修饰，该类可以被本包的类继承，也可以被别的包的类继承，可以在本包被实例化，也可以在别的包中被实例化。无论是哪一种，都不能被访问，只能在本类中被访问 变量、方法所处的类默认缺省修饰符，该类只能被本包的类继承或在本包被实例化，注意不能被别的包的类继承或在别的包被实例化。在本包被继承或本包实例化后，也不可能访问该被private修饰的变量和方法，只能在本类中被访问 缺省 当缺省修饰类时，该类只能在同包中被访问（比如在同一个包下的另一个文件中，可以直接访问到该类，用该类实例化对象、继承等）；不能在别的包中被继承、实例化。 当缺省修饰变量、方法时，分以下情况： 变量、方法所处的类被public修饰，该类可以被本包的类继承，也可以被别的包的类继承，可以在本包被实例化，也可以在别的包中被实例化。当被本包的类继承或在本包被实例化，可以访问到该被缺省修饰的变量和方法；当被别的包的类继承或在别的包中被实例化，则不能访问（注意和protected的区别）。 变量、方法所处的类默认缺省修饰符，该类只能被本包的类继承或在本包被实例化，注意不能被别的包的类继承或在别的包被实例化。在本包被继承或本包实例化后，可以访问该被缺省修饰的变量和方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java的package和import]]></title>
    <url>%2F2020%2F04%2F08%2F%E5%85%B3%E4%BA%8EJava%E7%9A%84package%E5%92%8Cimport%2F</url>
    <content type="text"><![CDATA[关于java语言当中的包机制： 包又称为package，java引入package这种语法机制主要是为了方便程序的管理，不同功能的类被分别放到不同的软件包当中，查找比较方便，管理比较方法，易维护 怎么定义package？ 在java源程序的第一行上编写package语句 package只能编写一个语句 语法结构 package 包名； 包名的命名规范： 公司域名倒序+项目名+模块名+功能名。采用这种方式重名的几率较低，因为公司域名具有全球唯一性 例如： com.bjpowernode.user.service； 包名要求全部小写，包名也是标识符必须遵守标识符命名规则 一个包对应的是一个目录，比如上面那个com.bjpowernode.user.service对应的是4个目录（目录之间使用”.“隔开） 使用了package机制后，怎么编译？怎么运行？ 使用了package机制之后，类名将发生改变 1234567package com.bjpowernode.javase.day11;public class test&#123; public static void main(String[] args)&#123; System.out.println("test"); &#125;&#125; 上面这个类在加入包机制之后，完整的类名将变成：com.bjpowernode.user.service.test。 编译还是在java源文件路径下运行：javac test.java 但运行会出现问题，如果直接java test会导致找不到该类。此时可以手动创建四个目录，从上到下依次是com、bjpowernode、user和service，然后将编译的test.class放在service中。随后返回到包含com的目录下运行：java com.bjpowernode.user.service.test即可运行成功 另一种方式： javac -d 编译之后的存放路径 java源文件的路径，例： 12345javac -d . test.java// -d 带包编译// . 代表编译之后生成的东西放到当前目录下// 将当前目录下的test.java文件编译后放到当前目录下的com/bjpowernode/user/service目录中（自动创建，不用手动创建）// 运行跟上面的方式一样 使用IntelliJ IDEA完成包机制将会非常简单，直接建包即可 下面举个例子： 12345678910111213141516171819202122232425262728293031323334// test01.javapackage com.bjpowernode.user.service;public class test01&#123; &#125;// test02.javapackage com.bjpowernode.user.service;public class test02&#123; public static void main(String[] args)&#123; // 以下两种方式均可 // 第一种，完整包名 com.bjpowernode.user.service.test01 t = new com.bjpowernode.user.service.test01; // 第二种 // 可以省略包名,因为test01和test02在同一个包中 test01 tt = new test01(); &#125;&#125;// test03.javapackage com.bjpowernode;public class test03&#123; public static void main(String[] args)&#123; // 这里的包名不能省略 // 下面代码编译会报错：当省略包名后，会在当前包下找test01 // 实际上编译器去找com.bjpowernode.test01了，这个类不存在 test01 t = new test01(); // 下面正确 com.bjpowernode.user.service.test01 t = new com.bjpowernode.user.service.test01; &#125;&#125; 什么时候包名可以省略？ 在同一个包下的时候可以省略 但是上面如果不在同一个包下，每次都需要加包名，这样太累了！于是就引入了import语法 12345678910111213141516171819202122232425262728// test01.javapackage com.bjpowernode.user.service;public class test01&#123; &#125;// test02.javapackage org.apache;public class test02&#123; public static void main(String[] args)&#123; // 不能省略，必须要写完整，太麻烦！ com.bjpowernode.user.service.test01 t = new com.bjpowernode.user.service.test01; &#125;&#125;// test03.javapackage org.apacheimport com.bjpowernode.user.service.test01;public class test03&#123; public static void main(String[] args)&#123; // 这里由于导入了包，所以可以省略包名 test01 t = new test01(); &#125;&#125; impot语句用来完成导入其它类，同一个包下的类不需要导入。不在同一个包需要手动导入 import语法格式： import 完整类名；(导入特定类) import 包名.*；(导入包中全部的类) import需要编写在package语句下面，class语句上面（一人之下，万人之上） 但为什么String不用导入就可以直接使用呢？ String类属于java.lang包，java.lang.*不需要手动引入，系统自动引入 java.lang：language语言包，是java语言的核心类，不需要手动引入 除java.lang.*，其余所有的包在使用的时候必须要手动引入 什么时候需要import？ 不是java.lang包下，并且不再同一个包下的时候，需要import进行导入 这里需要注意几个问题： import只能导入同一个module下面的类，不能导入其它module下面的类，除非建立了依赖关系 如果有两个不同的包中存在同名类，在另一个包中的测试文件test.java中不能同时引用上述两个类，只能引用其中某一个，否则会报错 如果有两个包，一个包P1中有test.java和A.java文件，另一个包P2中有A.java文件 如果在test.java中不写import P2.A，则这里如果使用A代表的是P1中的A 如果在test.java中写了import P2.A，则这里如果使用A代表的是P2中的A 如果两个A类都想使用，可以先import P2.A，然后A代表的是P2中的A，使用P1.A代表P1中的A，这样就可以区分开了 其它module 的类需要add dependency on other modules之后，才能import该模块下的各种类。如果存在多个模块，需要指定模块的依赖顺序（如果不同模块下存在相同的包和类，那么在import的时候，会根据依赖顺序引入第一个有该同名包下的同名类）。如何指定依赖顺序呢？以IntelliJ IDEA为例：File —&gt; project sturcture —&gt; modules，然后就可以添加修改依赖顺序了，如下图：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2020%2F04%2F08%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关于final关键字： final是一个关键字，表示最终的，不可变的 final可以修饰变量、方法、类等 final修饰的类无法被继承 final修饰的方法无法被覆盖，也无法被隐藏，但可以被继承（该方法可以被子类使用） final修饰的变量（无论是实例变量、局部变量还是静态变量）一旦赋值之后，不可重新赋值，final修饰的变量只能赋一次值 final修饰的实例变量必须手动初始化（但是final修饰的局部变量可以不初始化），系统不管赋默认值，要求程序员必须手动赋值。否则将报错，有两种解决方案： 第一种 1final int age = 20; 第二种 123456public class Person&#123; final int age; public Person(age)&#123; this.age = age; &#125;&#125; 其实上述两种方法本质是一样的，因为都是在构造方法执行过程中给实例变量赋值 final修饰的引用一旦指向某一个对象，就不能再指向别的对象（因为引用是一个变量，final修饰的变量只能赋一次值）。所以该对象将永远无法被垃圾回收器回收，直至程序结束 final修饰的实例变量是不可变的，这种变量一般和static联合使用（加了static后存储在方法区中，可以节省内存空间），被称为常量。常量名通常全部大写，语法格式如下 public static final 类型 常量名 = 值； 实际上常量和静态变量一样，区别在于常量的值不可变。常量和静态变量都是存储在方法区，并且都是在类加载时初始化 常量一般都是public的，因为改不了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字]]></title>
    <url>%2F2020%2F04%2F08%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[super： super代表的是“当前对象（this）”的那部分“父类型特征”，所以在创建子类对象的时候并没有创建父类型对象，而是在子类对象中有一部分是父类型特征。 比如我继承了我父亲的眼睛、皮肤，这些虽然继承于父亲，但这部分是在我身上的 和this对比 this只能出现在实例方法和构造方法，不能使用在静态方法。大部分情况下可以省略，在区分局部变量和实例变量时不能省略。有两种语法：1、this.表示调用本类变量或方法；2、this()表示通过当前构造方法调用本类其它构造方法，只能出现在构造方法第一行 super只能出现在实例方法和构造方法，不能使用在静态方法。大部分情况下可以省略，如果父类和子类有同名变量，并且想在子类中访问父类变量，super.不能省略。有两种语法：1、super.表示调用变量或方法；2、super()表示通过当前构造方法调用父类其它构造方法，只能出现在构造方法第一行，创建子类对象的时候先初始化父类型特征 当一个构造方法的第一行既没有this()又没有super()，默认会有一个super()；表示通过当前子类的构造方法调用父类的无参数构造方法 this()和super()不能共存，因为他们都需要在构造函数的第一行 super不是引用，不保存内存地址，也不指向任何对象，只是代表当前对象内部的那一块父类型特征，所以super不能单独打印输出，但this可以单独打印输出 super关键字使用情况，主要有以下三种： 子类方法中调用被重写的父类的方法 12345678910111213141516171819202122class A &#123; private String nameA="A"; public void getName() &#123; System.out.println("父类"+nameA); &#125;&#125; class B extends A&#123; private String nameB="B"; @Override public void getName() &#123; System.out.println("子类"+nameB); super.getName(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; B f=new B(); f.getName(); &#125;&#125; 运行结果为： 12子类B父类A 结果分析： 在子类B中，我们重写了父类的getName方法，如果在重写的getName方法中我们去调用了父类的相同方法，必须要通过super关键字显示的指明出来。 如果不明确出来，按照子类优先的原则，相当于还是再调用重写的getName()方法，此时就形成了死循环，会一直输出”子类B“。执行后会报java.lang.StackOverflowError异常。 子类中访问被隐藏的父类成员变量 12345678910111213141516171819202122class A &#123; String nameA="A";&#125; class B extends A&#123; String nameA="B"; public void getName() &#123; System.out.println("子类"+nameA); System.out.println("父类"+super.nameA); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; B b=new B(); b.getName(); &#125;&#125;/* 输出结果为：* 子类B* 父类A*/ 此时子类B中有一个和父类一样的字段（也可以说成父类字段被隐藏了），为了获得父类的这个字段我们就必须加上super，如果没有加，都是访问的子类B里面的那么字段。 我们通过super是不能访问父类private修饰的变量和方法 在子类构造方法中调用父类构造方法 编译器会自动在子类构造函数的第一句加上 super(); 来调用父类的无参构造器；此时可以省略不写。如果想写上的话必须在子类构造函数的第一句，可以通过super来调用父类其他重载的构造方法，只要相应的把参数传过去就好 在java语言中不管new什么对象，最后object类的无参构造方法一定会执行，且一定是最先执行的 但是有时候会存在问题： 如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为super()，一般这句话省略了）。但是当在父类中定义了有参构造函数，没有定义无参构造函数时，IDE会强制要求我们定义一个相同参数类型的构造器。如果在子类构造函数中没有显示的调用父类中的有参构造函数会报错。所以此时必须要显示的调用有参构造函数 123456789101112131415161718class father&#123; public father(String name)&#123; System.out.println(name); &#125;&#125;class son estends father&#123; /* 报错，因为默认调用super()，但是父类中没有无参构造方法 public son()&#123; &#125; */ // 下面代码编译正确 public son()&#123; super("我是子类传过去的"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类继承实现的底层原理]]></title>
    <url>%2F2020%2F04%2F07%2F%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[先定义一个基类 123456789101112131415161718192021222324252627282930// 基类代码public class base&#123; private static int s; private int a; static &#123; System.out.println("基类静态代码块, s: "+s); s = 1; &#125; &#123; System.out.println("基类实例代码块, a: "+a); a = 1; &#125; public base()&#123; System.out.println("基类构造方法, a: "+a); a = 2; &#125; protected void step()&#123; System.out.println("base s: " + s +", a: "+a); &#125; public void action()&#123; System.out.println("start"); step(); System.out.println("end"); &#125;&#125; Base包括一个静态变量s，一个实例变量a，一段静态初始化代码块，一段实例初始化代码块，一个构造方法，两个方法step和action。 再定义一个子类 123456789101112131415161718192021222324// 子类代码public class Child extends Base &#123; public static int s; private int a; static &#123; System.out.println("子类静态代码块, s: "+s); s = 10; &#125; &#123; System.out.println("子类实例代码块, a: "+a); a = 10; &#125; public Child()&#123; System.out.println("子类构造方法, a: "+a); a = 20; &#125; protected void step()&#123; System.out.println("child s: " + s +", a: "+a); &#125;&#125; Child继承了Base，也定义了和基类同名的静态变量s和实例变量a，静态初始化代码块，实例初始化代码块，构造方法，重写了方法step。 测试代码如下： 123456789101112131415public static void main(String[] args) &#123; System.out.println("---- new Child()"); Child c = new Child(); System.out.println("\n---- c.action()"); c.action(); Base b = c; System.out.println("\n---- b.action()"); b.action(); System.out.println("\n---- b.s: " + b.s); System.out.println("\n---- c.s: " + c.s); &#125; 创建了Child类型的对象，赋值给了Child类型的引用变量c，通过c调用action方法，又赋值给了Base类型的引用变量b，通过b也调用了action，最后通过b和c访问静态变量s并输出。输出结果如下： 123456789101112131415161718192021---- new Child()基类静态代码块, s: 0子类静态代码块, s: 0基类实例代码块, a: 0基类构造方法, a: 1子类实例代码块, a: 0子类构造方法, a: 10---- c.action()startchild s: 10, a: 20end---- b.action()startchild s: 10, a: 20end---- b.s: 1---- c.s: 10 上述类加载后，对于每一个类，在Java方法区就有了一份这个类的信息，以我们的例子来说，有三份类信息，分别是Child，Base，Object，内存示意图如下： 我们用class_init()来表示类初始化代码，用instance_init()表示实例初始化代码，实例初始化代码包括了实例初始化代码块和构造方法。例子中只有一个构造方法，实际中可能有多个实例初始化方法。 类初始化代码包括： 定义静态变量时的赋值语句 静态初始化代码块 实例初始化代码包括： 定义实例变量时的赋值语句 实例初始化代码块 构造方法 本例中，类的加载大概就是在内存中形成了类似上面的布局，然后分别执行了Base和Child的类初始化代码。接下来，我们看对象创建的过程。 创建对象 在类加载之后，new Child()就是创建Child对象，创建对象过程包括： 分配内存 对所有实例变量赋默认值 执行实例初始化代码 分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，先执行父类的，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。 每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。 Child c = new Child();会将新创建的Child对象引用赋给变量c，而Base b = c;会让b也引用这个Child对象。创建和赋值后，内存布局大概如下图所示： 引用型变量c和b分配在栈中，它们指向相同的堆中的Child对象，Child对象存储着方法区中Child类型的地址，还有Base中的实例变量a和Child中的实例变量a。创建了对象，接下来，来看方法调用的过程。 方法调用 我们先来看c.action();这句代码的执行过程是： 查看c的对象类型，找到Child类型，在Child类型中找action方法，发现没有，到父类中寻找 在父类Base中找到了方法action，开始执行action方法 action先输出了start，然后发现需要调用step()方法，就从Child类型开始寻找step方法 在Child类型中找到了step()方法，执行Child中的step()方法，执行完后返回action方法 继续执行action方法，输出end 寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。 我们来看b.action();，这句代码的输出和c.action是一样的，这称之为动态绑定，而动态绑定实现的机制，就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。这里，因为b和c指向相同的对象，所以执行结果是一样的。 如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。大多数系统使用一种称为虚方法表的方法来优化调用的效率。 虚方法表 所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。虚方法表存储在方法区内存中，虚方法表只存储有虚方法，不包括静态方法、private方法、构造方法和final方法。虚方法表是专为实现多态的动态绑定机制而生的。 对于本例来说，Child和Base的虚方法表如下所示： 对Child类型来说，action方法指向Base中的代码，toString方法指向Object中的代码，而step()指向本类中的代码。 这个表在类加载的时候生成，当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。 变量访问和静态方法调用 对变量和静态方法的访问是静态绑定的，无论是类变量还是实例变量。代码中演示的是类变量：b.s和c.s，通过对象访问类变量，系统会转换为直接访问类变量Base.s和Child.s。 例子中的实例变量都是private的，不能直接访问，如果是public的，则b.a访问的是对象中Base类定义的实例变量a，而c.a访问的是对象中Child类定义的实例变量a。 关于继承的几个小细节： 子类可以继承父类的private属性和private方法 如果一个子类继承了父类，那么这个子类拥有父类所有的成员属性和方法，即使是父类里有private属性的变量，子类也是继承的，只不过不能使用，也就是说，它继承了，但是没有使用权，但可以通过set和get来间接访问 创建子类对象的同时到底有没有创建父类对象？ 没有创建父类对象！即只创建了一个对象！类的创建过程是这样的，首先开辟内存，然后调用类的构造函数，类的构造函数第一步会去调用父类的构造函数(如果存在父类)，父类构造函数首先对这个对象进行初始化，该赋值的赋值，该做什么做什么，所有父类构造函数运行完毕后才继续运行这个类自己的构造函数。 见下面例子 12345678910class Parent &#123; private short six; private int age;&#125;class Sub extend Parent&#123; private String name; private int age; private float price;&#125; 上述代码的堆内存布局如下： 上图中绿色是从父类继承来的变量，蓝色是子类自己的变量。那么在子类中如何来区分它们呢？super.name就代表从父类继承而来的，直接写name或this.name就代表子类定义的。如果变量名不同的话 可以直接省略super和this。 这里需要注意一点：this指向的是对象本身，而super指向的是子对象中的那部分父类型特征，super是this指向的那个对象中的一块空间 简单理解：new子类对象时，先开辟一片内存空间，先给父类的成员变量安排好内存单元，然后子类自己的数据接着来分配给予内存单元，相当于父类数据与子类数据合租一个房子，房子是子类的 子类可以继承父类的static变量和static方法，可以访问，但是不能覆盖，只能隐藏 当子类没有与之同名的static变量（或方法时），子类的对象也可以操控这块内存空间。 即使子类和父类中都有同样的static方法和变量，他们是没有任何关系的，他们是相互独立的，他们是属于各自类本身的。因此也是不存在多态特性的，遵循静态绑定原则 总结：当子类没有重新定义同名变量时，子类父类共享该变量。当子类重新定义同名变量时，不共享，是两个不同变量，值不同。 父类的构造方法不能被子类继承]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2020%2F04%2F07%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[12345678910111213// Chinese.javapublic class Chinese&#123; // 身份证号（每一个对象的身份证号不同） String id; // 姓名（每一个对象的姓名不同） String name; // 国籍 // 每一个对象的国籍都是中国，属于类属性，应定义为静态变量 // 如果定义为实例变量，每一个对象都需要有一块内存空间来保存它，太浪费，没必要让每一个对象都保存一份内存 // 静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了 // 静态变量存储在方法区中 static String country;&#125; 什么时候成员变量声明为实例变量？ 所有对象都有这个属性，但这个属性的值会随着对象的的变化而变化 什么时候成员变量声明为静态变量？ 所有对象都有这个属性，并且所有对象的这个属性是一样的，建议定义为静态变量，节省内存开销 静态变量在类加载的时候初始化，内存在方法区中开辟，访问不需要创建对象，只有一份。用“类名.”的方式访问 关于Java中的static关键字： static修饰的方法是静态方法 static修饰的变量是静态变量 所有static修饰的元素都成为静态的，都可以用“类名.”的方式访问，当然也可以用“引用.”的方式访问（但不建议） static修饰的所有元素都是类级别的特征，和具体的对象无关 静态代码块 可以使用static关键字定义静态代码块 语法格式 static{ ​ java语句; } 静态代码块在类加载的时候执行，并且只执行一次。后面无论创建多少个对象，都只执行一次 静态代码块在一个类中可以编写多个，并且尊徐自上而下的顺序依次执行. 静态代码块的作用？怎么用？用在哪？什么时候用？ 和具体需求有关，例如项目中要求在类加载的时刻执行代码完成日志的记录，那么这段记录日志的代码就可以编写到静态代码当中，完成日志记录 静态代码块是Java为程序员准备的一个特殊的时机，这个特殊的时机被称为类加载时机。若希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码块当中 通常在静态代码块当中完成预备工作，例如初始化连接池、解析XML配置文件等 实例代码块 语法结构 { ​ java语句; } 实例代码块可编写多个，遵循自上而下的原则。实例代码块在构造方法执行之前执行，构造方法执行一次，实例代码块对应执行一次 实例代码块也是java为程序员准备的一个特殊的时机，称为对象初始化时机 方法什么时候定义为静态的？ 方法描述的是动作，当所有对象执行这个动作的时候，最终产生影响是一样的。那么这个动作已经不再属于一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作 静态方法中无法直接访问实例变量和实例方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2020%2F04%2F06%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[先看一段代码： 1234567891011121314151617181920212223242526272829303132// customer.javapublic class customer&#123; // 姓名 String name; // 实例变量必须采用“引用.”的方法访问 // 构造方法 public customer()&#123; &#125; // 不带有static关键字的一个方法 // 顾客的购物行为，每一个顾客购物的最终结果是不一样的 // 所以购物这个行为是属于对象级别的行为 // 由于每一个对象在执行购物这个动作的时候最终结果不同，所以购物这个动作必须有“对象”的参与 // 没有static的方法是实例方法，“引用.”的方式调用 // 当一个行为执行中是需要对象参与的，那么一定要定义为实例方法 public void shopping()&#123; System.out.println(this.name + "在购物"); &#125;&#125;// customerTest.javapublic class customerTest&#123; public static void main(String[] args)&#123; // 创建customer对象 customer c1 = new customer(); c1.name = "zhang"; c1.shopping(); // zhang在购物 // 创建customer对象 customer c2 = new customer(); c2.name = "li"; c2.shopping(); // li在购物 &#125;&#125; 上述代码内存图如下所示： 关于Java语言当中的this关键字： this是一个关键字，翻译为这个 this是一个引用，this是一个变量，this变量中保存了内存地址指向了自身，this存储在JVM堆内存Java对象内部 this就是代表当前对象 创建100个Java对象，每一个对象都有this，也就是说有100个不同的this this可以出现在实例方法当中，this指向当前正在执行这个动作的对象 this在多数情况下可以省略不写（不造成歧义的情况下）。 this在区分实例变量和局部变量的时候不能省略。下面这个例子如果省略了this就会造成歧义 123456789101112131415public class hello&#123; int age; String name; public hello(int age,String name)&#123; this.age = age; this.name = name; &#125; /* * 这种情况下可以省略 * public hello(int a,String n)&#123; * age = a; * name = n; */ &#125;&#125; this不能使用在静态方法当中（因为实例方法属于类，没有对象也可以访问，所以this用不了） 如果静态方法里想访问实例变量怎么办？ 在方法里创建对象即可 1234public static void doSome()&#123; customer c = new customer(); System.out.println(c.name);&#125; 构造方法、实例方法的第一个参数是this！这是由编译器自动添加的 实例方法中（非构造非静态）：this指代的是正在调用当前方法的对象 构造方法中：this指代的是正在new的对象本身 个人小理解： 调用实例或构造方法肯定是堆中的对象来调用的，因为它们存有方法区中方法的入口地址。但是堆中可能存在同一个类的多个对象，但是方法区中的代码只有一份，如何指定调用的是哪一个的对象的方法，以使得产生不同的运行结果？比如给实例变量赋值（选择给哪个对象的实例变量赋值呢？）因为不同对象有差异性，但方法区里面的代码是唯一的，这个时候将每个对象内部的this作为参数传递给实例或构造方法，就可以解决上面的指定问题了。因为不同的对象是有不同的this的，this指向堆内存对象本身。 同一类中的一个构造方法可以调法用类中其他构造方法，便于代码复用。调用其他构造方法的语法是this(实参)，并且只能出现在第一行 this既可以使用在实例方法中，也可以使用在类中其它构造方法中。但不能使用在静态方法中 静态方法既可以采用类名的方式访问，也可以采用引用的方式访问。但是即使采用引用的方式访问，实际上执行的时候和引用指向的对象无关。可以简单的认为在执行的时候还是把前面的引用换成了类，本质还是类名的方式访问]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类初始化顺序]]></title>
    <url>%2F2020%2F04%2F05%2FJava%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（实例变量、普通初始化块）&gt; 构造器。 代码初始化块是类的成员之一，每次类的创建会隐式的调用它。本质上是一个代码块，或方法体。初始化块分为静态初始化块和普通初始化块。其好处是减少多个构造器内重用的代码。 初始化顺序图示： 123456789101112131415161718192021222324252627282930313233/** * 类的初始化顺序 * 静态变量-&gt;静态初始化块-&gt;实例变量-&gt;初始化块-&gt;构造方法 */public class InitialOrderTest &#123; // 静态变量 public static String staticField = "静态变量"; // 变量 public String field = "变量"; // 静态初始化块 static &#123; System.out.println(staticField); System.out.println("静态初始化块"); &#125; // 初始化块 &#123; System.out.println(field); System.out.println("初始化块"); &#125; // 构造器方法 public InitialOrderTest() &#123; System.out.println("构造方法"); &#125; public static void main(String[] args) &#123; new InitialOrderTest(); &#125; &#125; 上述代码的运行结果如下： 而对于继承的情况初始化顺序又会是怎么样的呢？ 初始化块的特点： 何时调用？ 普通初始化块：创建对象时隐式调用 静态初始化块：类加载（包括加载、验证、准备、解析和初始化五个阶段）时隐式调用 静态初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。也就是说如果创建100个对象，静态初始化仍然只调用依次，而普通初始化块会调用100次 一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型（静态或普通）的初始化块的执行顺序取决于定义的先后顺序！ 在一个类中如果有多个不同的初始化块，初始化属性，构造器执行顺序是：静态初始化块|静态属性初始化 &gt; 普通初始化块|普通属性初始化 &gt; 构造器 在父子类中，执行顺序是： 爷爷类的静态初始化块|静态属性初始化 父类静态初始化块|静态属性初始化 子类静态初始化块|静态属性初始化 爷爷类普通初始化块|普通属性初始化&gt;构造方法 父类普通初始化块|普通属性初始化&gt;构造方法 子类普通初始化块|普通属性初始化&gt;构造方法 静态初始化块中遵循静态成员的特点，只能直接访问静态成员！也就是在静态初始化块只能修改静态成员 个人底层小总结： 类加载过程中包含一个准备阶段，该阶段正式为类中定义的静态变量（并不包括实例变量，并且只有静态变量，不包括静态代码块）分配内存（在方法区中）并设置初始值（注意这里的初始值通常情况下是系统默认的数据类型零值）。比如下面这个语句 1public static int val = 123; 变量val在准备阶段过后的初始值为0而不是123。只有当类加载中的初始化阶段后该变量才被赋值为123。 这里说了通常情况下在准备阶段被初始为数据类型零值。但也存在例外，如果是常量的话，那么在准备阶段就会被赋值为123。如下： 1public static final int val = 123; 进行准备阶段时，静态变量已经赋过一次系统要求的初始零值。在类加载的初始化阶段，会根据程序员编写的代码去初始化类变量。初始化阶段就是执行类构造器&lt; clinit &gt;()方法的过程。&lt; clinit &gt;()并不是程序员在Java代码中直接编写的代码，它是Javac编译器的自动生成物。&lt; clinit &gt;()方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的（静态变量的声明操作不会被收集）。编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块只能访问到定义在静态语句块之前的静态变量。定义在它之后的静态变量只能赋值，但不能访问。所以最好把静态变量写在静态代码块前面。 类初始化前，其直接超类已经被初始化，直接超类的直接超类也需如此。即javac生成的 &lt; clinit &gt;方法由JVM在“类初始化阶段”调用，调用类的&lt; clinit &gt;方法前，必须先调用父类的&lt; clinit &gt;方法。因此在Java虚拟机中第一个被执行的&lt; clinit &gt;()方法的类型肯定是java.lang.Object &lt; clinit &gt;方法只在类加载阶段的初始化过程中被执行一次，后续创建实例对象将不再执行该方法。也就是创建100个实例对象，只执行依次&lt; clinit &gt;方法，但会执行100次构造方法。 &lt; clinit &gt;方法不是必须的，如果一个类中没有静态代码块，也没有对静态变量的赋值操作，那么编译器可以不为这个类生成&lt; clinit &gt;方法 上面说过，实例变量和普通代码块的初始化顺序要早于构造方法。实际情况是这样的：编译的时候，javac编译器把“实例变量的初始化语句”和“实例代码块的语句”按照代码中的顺序编译到了构造方法中（并且该位置要放在构造方法里面已经有的代码的前面），所以才会造成实例变量和普通代码块要早于构造方法初始化。 执行构造方法在堆中创建一个对象。在没有显示调用父类构造方法情况下，所有构造方法的首行都会隐含调用父类的无参构造方法super()。所以才会造成父类的实例变量、普通代码块和构造方法的初始化要早于子类的实例变量、普通代码块和构造方法的初始化。 构造方法是在创建对象的时候才会调用的 类加载过程：① JVM启动，加载所需要的class文件② JVM加载class文件时，会把所有的静态内容(静态成员变量、静态方法、静态代码块)都先加载到方法区中的静态区中，此时实例方法也会被加载到方法区的非静态区中（这点很重要，一定要注意）。类加载的时候，静态方法和实例方法都会加载到方法区中，只不过要调用到实例方法时需要先实例化一个对象才能调用实例方法③ 静态加载完成之后，JVM开始给所有的静态变量开辟空间并默认初始化。④ 当给类中的所有静态成员变量默认初始化完成，开始按照代码的顺序依次执行(遇到静态代码块就执行，遇到静态成员变量就显示初始化)⑤ 静态都执行完毕，类才彻底加载完成 对象的加载过程：① 当类加载完成，使用new关键字创建对象，在堆给对象分配内存空间② 给对象所属的类的实例变量分配空间并进行默认初始化（数据类型系统零值）③ 在JVM自动调取构造函数时先执行隐式两步 super()区访问父类构造，对父类进行初始化 给实例变量进行显示赋值，执行普通代码块（什么时候变量赋值，什么时候执行代码块，取决于他们在源文件中的顺序） ④ 执行构造函数中的其它代码⑤ 构造函数执行完毕，对象创建完成。 实际上，在jvm层面上，在执行构造方法之前，jvm已经为在堆中给对象分配好了内存空间，并将该对象的引用this当做参数传递到构造方法中，构造方法的执行，只是为了给对象进行初始化。所以，构造方法是由新创建的对象来调用的，构造方法中的this，仍然指代的是正在调用该构造方法的对象。 注意： 静态方法存储在方法区的静态区里面，实例方法存储在方法区的非静态区里面（注意：实例方法不随创建的对象保存于堆中） 静态方法是在类加载的时候就在内存中加载完成，可以直接通过类名调用运行的函数。(只要是函数最终都要进入栈内存，方法是什么时候调用，什么时候执行，不调用不执行。记住：加载，是将类文件中的一行行内容存放到了内存当中，并不会执行任何语句) 静态方法和实例方法加载过程 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。 对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出才被取消。 静态不能访问非静态、非静态可以访问静态 静态方法在类的字节码加载到内存时就分配了入口地址，因此，Java语言允许通过类名直接调用类方法，而实例方法不能通过类名调用。在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址。 静态变量/方法、实例变量/方法在内存中的存储： 静态变量/方法：只有一份，共用一块记忆体 实例方法：只有一份，共用一块记忆体 实例变量：随着每个对象各有一块记忆体 为什么实例方法共用一块记忆体呢？ ​ 如果让类中所有的实例方法都随着对象的实例化而建立一次，那么会大量消耗内存资源，所以才会让所有对象共享这些实例方法，然后用this关键字指向调用实例方法的对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法调用时的参数传递问题]]></title>
    <url>%2F2020%2F04%2F04%2F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java方法在调用的时候，需要传递参数。参数一般有两种数据类型：基本数据类型和引用数据类型。下面我们分别针对这两种类型分析一下参数在传递的时候发生了些什么？ 基本数据类型 12345678910111213public class test&#123; public static void main(String[] args)&#123; int i = 10; // add方法在调用的时候，给add方法传递了一个变量i，到底传递的是什么？ add(i); System.out.println(i); // 10 &#125; public static void add(int i)&#123; i++; System.out.println(i); // 11 &#125;&#125; 上述代码内存结构如图所示 Java语言当中方法调用的时候需进行参数传递，参数传递实际上传递的是变量中保存的具体值，与变量无关（相当于复制了一份）。所以上面add方法里对i进行自增，不影响main函数里的i变量。 引用数据类型 1234567891011121314151617181920public class test&#123; public static void main(String[] args)&#123; User u = new User(20); add(u); System.out.println(u.age); // 21 &#125; public static void add(User u)&#123; u.age++; System.out.println(u.age); // 21 &#125;&#125;class User&#123; int age; public User(int age)&#123; this.age = age; &#125;&#125; 上述代码内存结构如图所示 上面在传递参数的时候，还是传递的是变量中保存的值。但这里保存的是堆内存地址，所以这里传递的是地址。但本质上和上面是一样的。 最终结论：方法调用的时候，涉及到参数传递问题，java只遵循一种语法机制，就是将变量中保存的值传递过去了。只不过有时候这个值是一个字面值（比如10），有时候这个值是另一个java对象的内存地址（比如0x1234）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象封装性]]></title>
    <url>%2F2020%2F04%2F03%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[下面先举个小例子 1234567891011121314151617// user.javapublic class user&#123; // 这里的age属性显然完全暴露给外部程序的，对于程序员来说可以操作user对象当中所有的细节，导致user中部分数据不安全 // 不建议这样，建议user类型进行封装，建议在外部程序中不能随意访问user对象中的属性，这样可以保证属性的安全 int age;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 下面代码可以顺利编译运行，但是存在逻辑问题，因为年龄不可能是负数 u.age = -100; System.out.println(u.age); &#125;&#125; 对上述代码而言，user类中的age属性在外部程序可以随意访问，导致age属性不安全。一个user对象表示一个用户，用户的年龄不可能是负数。 封装的好处： 封装之后，对于那个事物来说，看不到这个事物比较复杂的那一面，只能看到该事物简单的那一面。复杂性封装，对外提供简单的操作入口。照相机就是一个很好的封装的案例，照相机的实现原理非常复杂。但是对于使用照相机的人来说，操作起来是非常便捷的。还有电视机也是封装的，电视机内部实现非常复杂，但是对于使用者来说不需要关心内部的实现原理，只需要会操作遥控器就行 封装之后才会形成真正的对象，真正的独立体 封装就意味着以后的程序可以重复使用，并且这个事物适应性比较强，在任何场合都可以使用 封装之后，对于事物本身，提高了安全性（安全级别高） 封装的步骤： 所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问 对外提供简单的操作入口，也就是说以后外部程序要想访问age属性，必须通过这些简单的入口进行访问 对外提供两个公开的方法，分别是set方法和get方法 想修改age属性，调用set方法 想读取age属性，调用get方法 set方法的命名规范： 123public void setAge(int a)&#123; age = a;&#125; get方法的命名规范： 123public int getAge()&#123; return age;&#125; 注意 setter和getter方法没有static关键字 有static关键字修饰的方法怎么调用：类名.方法名(实参) 没有static关键字修饰的方法怎么调用：引用.方法名(实参) 12345678910111213141516// user.javapublic class user&#123; private int age;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 编译报错 // age属性私有化，在外部程序中不能直接访问 // 从此之后age属性非常的安全，但是有点太安全了 // 对于目前的程序来说，age属性彻底在外部访问不到了 System.out.println(u.age); &#125;&#125; 回想一下，一个属性通常访问的时候包括几种访问形式？ 第一种方式：想读取这个属性的值，读取get 第二种方式：想修改这个属性的值，修改set 下面介绍一下封装后该怎么写？ 12345678910111213141516171819202122232425262728293031// user.javapublic class user&#123; private int age; // set方法没有返回值，因为set方法只负责修改数据 // setter public void setAge(int age)&#123; // 编写业务逻辑代码进行安全控制 if(age&lt;0 || age&gt;150)&#123; System.out.println("不符合逻辑！"); return; &#125; this.age = age; &#125; // getter public int getAge()&#123; return age; &#125;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 修改 u.setAge(20); // 读取 System.out.println(u.getAge()); &#125;&#125; 这样的话，如果利用setAge()给age赋值为-100的时候，就会报错。这样就可以保证安全性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建与使用-内存分析]]></title>
    <url>%2F2020%2F04%2F03%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[首先定义一个学生类，学生类是一个模板，描述了所有学生的共同特征（状态+行为）： 1234567891011121314151617181920212223// student是类，属于引用数据类型，这个类型名就是studentpublic class student&#123; // 类体：属性+方法 // 学号 int number; // 属性（存储数据采用变量的形式） // 由于变量定义在类体当中，方法体之外，这种变量称为成员变量 // 所有学生都有学号信息，但是每一个学生的学号都是不同的 // 所以要访问这个学号必须先创建对象，通过对象去访问学号信息 // 学号信息不能直接通过类去访问，所以这种成员变量又称为实例变量 // 对象又被称为实例，实例变量又被称为对象变量（对象级别的变量） // 不创建对象，这个number变量的内存空间是不存在的，只有创建了对象，这个number内存空间才会创建 // 姓名 String name; // 年龄 int age; // 性别 boolean sex; // 住址 String addr;&#125; 对象的创建与使用通过一个类可以实例化N个对象，实例化对象的语法： 1student s = new student(); new是Java语言当中一个运算符，它的作用是创建对象，在JVM堆内存当中开辟新的内存空间 方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中 栈内存（存储局部变量）：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈 堆内存：new的对象在堆内存中存储 123456789101112131415public class test&#123; public static void main(String[] args)&#123; // i是一个变量名，10是一个int类型字面值 int i = 10; // student是一个引用数据类型 // s是一个变量名 // new student()是一个学生对象 // s是一个局部变量（在栈内存中存储） // 什么是对象？new运算符在堆内存中开辟的内存空间称为对象 // 什么是引用？引用是一个变量，只不过这个变量中保存了另一个java对象的内存地址 // 这里的s被称为一个student对象的引用 student s = new student(); &#125;&#125; 下面介绍一下上述代码的内存分析 首先说明：成员变量没有手动赋值的话，系统赋默认值（局部变量不会，如果不赋值就访问局部变量会报错） 数据类型 默认值 byte,short,int,long 0 flaot,double 0.0 boolean false char ‘/u0000’ 引用数据类型 null 内存分析如下所所示： Java语言当中，程序员不能直接地操作堆内存，java中没有指针，不像C语言。java语言当中，程序员只能通过引用去访问堆内存当中对象内部的实例变量。访问实例变量的语法格式： 1234// 读取数据引用.变量名// 修改数据引用.变量名 = 数据 注意 局部变量在栈内存中存储 成员变量中的实例变量在堆内存中的java对象内部存储。实例变量是一个对象一份，100个对象有100份 下面我们再针对一个更复杂的情况，对创建对象进行内存分析： 123456789101112131415161718192021222324252627282930// address.javapublic class address&#123; // 城市 // String是一种引用数据类型，city是一个实例变量 // city是一个引用，保存内存地址的一个变量，该变量保存的内存地址指向了堆内存中的对象 String city; // 街道 String street; // 邮编 String zipcode;&#125;// user.javapublic class user&#123; // 用户名 String name; // 用户编号 int no; // 家庭住址 // address是一种引用数据类型，addr是一个实例变量，是一个引用 address addr;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); &#125;&#125; 上述代码的内存图如下所示： 下面修改user对象内部实例变量的值 12345678910// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); u.no = 110; u.name = "jack"; u.addr = new address(); &#125;&#125; 上面代码的内存图如下： 注意：上图的u、name、addr、city、street和zipcpde都是引用。 如何访问对象u他家在那个城市、街道、邮编是多少？ 12345678910111213141516171819// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); u.no = 110; u.name = "jack"; u.addr = new address(); // 在main方法当中只能看到一个引用u // 一切都是只能通过u来进行方法 u.addr.city = "Beijing"; u.addr.street = "top"; u.addr.zipcode = "123456"; System.out.println(u.addr.city); System.out.println(u.addr.street); System.out.println(u.addr.zipcode); &#125;&#125; 根据上述分析可得：引用既可以是局部变量，也可以是成员变量。引用保存了内存地址，指向了堆内存当中的对象。 下面继续分析对象创建过程中的内存： 123456789// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); address a = new address(); u.addr = a; &#125;&#125; 注意；这里u.addr和a是两个引用。a中存储的地址赋值给了u.addr，a和u.addr指向了同一块堆中的对象。 1234567891011121314// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); address a = new address(); u.addr = a; System.out.println(u.addr.city); // null a.city = "beijing"; System.out.println(u.addr.city); // beijing // 这里a和u.addr指向同一块堆内存，因此通过a修改后，再利用u.addr访问的是修改后的对象 &#125;&#125; 下面对JVM内存进行一个总结： JVM主要包括三块内存空间，分别是栈内存、堆内存和方法区内存 堆内存和方法区内存各有一个，栈内存是一个线程一个栈内存 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行结束后，该方法所属的内存空间释放，称为弹栈 栈中主要存储的是方法体中的局部变量 方法的代码片段以及整个类的代码片段都存储到方法区内存当中，在类加载的时候这些代码片段会载入 在程序执行过程中使用new创建的java对象存储在堆内存当中，对象内部有实例变量，所以实例变量存储在堆内存当中。实例变量只有创建对象才能访问，不创建是没有对应的内存空间的 变量分类 局部变量：方法体内声明 成员变量：方法体外声明 实例变量：修饰符没有static 静态变量：修饰符有static 静态变量存储在方法区内存当中 三块内存当中变换最频繁的是栈内存，最先有数据的方法区内存，垃圾回收器主要针对的是堆内存 垃圾回收器(GC机制)什么时候会考虑将某个java对象的内存回收呢？ 当堆内存当中java对象成为垃圾数据的时候会被回收 什么时候堆内存当中的java对象会成为垃圾呢？ 没有任何引用指向它的时候。因为如果没有引用，这个对象就无法被访问，因为访问对象只能通过引用的方式访问 下面看一个情况 12345678910111213141516171819// customer.javapublic class customer&#123; int id;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; customer c = new customer(); // 空引用 c = null; // 以下程序编译可以通过，因为符合语法 // 运行出现空指针异常：java.lang.NullPointerException // 空引用访问“实例相关的数据”一定会出现空指针异常 // 实例相关的数据表示这个数据访问的时候必须要有对象的参与，比如实例变量。但对于静态变量是可以的 System.out.println(c.id); &#125;&#125; 注意： 1234567891011121314151617public class test&#123; public static void main(String[] args)&#123; test t = new test(); /* doSome是静态函数，这里不会出现空指针异常。 * 静态方法既可以采用类名的方式访问，也可以采用引用的方式访问。 * 但是即使采用引用的方式访问，实际上执行的时候和引用指向的对象无关。 * 可以简单的认为在执行的时候还是把前面的引用换成了类，本质还是类名的方式访问 */ t = null; t.doSome(); &#125; public static void doSome()&#123; System.out.println("x"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法执行内存分析]]></title>
    <url>%2F2020%2F04%2F01%2F%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[方法在执行过程当中，在JVM中的内存是如何分配的？内存是如何变化的？ 方法只定义，不调用，是不会执行的，并且在JVM当中也不会给该方法分配运行所属的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的内存空间。 在JVM内存划分上有这样三块主要的内存空间（当然除了这三块之外还有其他的内存空间） 方法区内存 堆内存 栈内存 方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？ 方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中。所以JVM中的三块主要的内存空间中，方法区内存是最先有数据的，存放了代码片段。 代码片段虽然在方法区内存中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配（栈内存中分配方法运行时所属的内存空间） 方法在调用的时候，会给该方法分配独立的内存空间，在栈中发生压栈操作；方法执行结束后，给该方法分配的内存空前全部释放，此时发生弹栈操作 压栈：给方法分配内存 弹栈：释放该方法的内存空间 局部变量在方法体中声明，局部变量运行阶段在栈中存储 下面我们图解一下上述过程，代码如下： 1234567891011121314151617181920public class Hello&#123; public static void main(String[] args)&#123; int a = 10; int b = 20; int retValue = sumInt(a,b); System.out.println(retValue); &#125; public static int sunInt(int i,int j)&#123; int result = i+j; int num = 3; int retValue = divide(result,num); return retValue; &#125; public static int divide(int x,int y)&#123; int z = x/y; return z; &#125;&#125; 下面我将一步一步对上述代码的执行过程进行图解： 执行前的JVM内存空间如下图（主要考虑三块内存，其余的可以先不考虑） 对Hello编译后，类加载器会将Hello.class字节码文件放到方法区内存中。其中的String.class和System.class是Java提供的类库 main方法是入口方法，所以首先在栈内存中给main方法分配一块内存。会在main方法对应的栈内存中为局部变量a和b分配内存（变量名和字面值两个不同的概念，当声明基本类型变量时，变量名和字面值（变量名和字面值是两个概念）均放在栈中，变量名指向字面值。当声明为引用数据类型时，变量名指向栈中一块内存，该内存中存放的是堆内存中对象实例的引用，该引用指向对象实例） 此时在main方法中调用sumInt方法，需要在栈内存中给sumInt方法开辟一块内存（参数也是局部变量） 注意：方法调用时，参数传递实际传递的是变量中保存的那个值（值传递）。比如这里：是把a保存的10传给了i，b保存的20传给了j，而不是把a和b传给了i和j。这样如果修改i和j，是不会影响a和b所对应的内存空间的。如果直接把a和b传给i和j，那么会存在问题：修改i和j的时候也会不知不觉的修改了a和b。 此时在sumInt方法中调用divide方法，需要在栈内存中给divide方法开辟一块内存 divide在返回值时，将z对应的数据值传递给sumInt方法中的retValue，然后divide方法内存释放，弹栈 sumInt在返回值时，将retValue对应的数据值传递给main方法中的retValue，然后sunInt方法内存释放，弹栈 当main方法执行结束后，对应的内存也将释放，弹栈 小问题：我们在Java入门（含Java基本介绍、数据类型、流程控制和数组操作）举过这样一个例子 123456789101112131415161718public class Hello&#123; /* 报错 public static void main(String[] args)&#123; String name = "l"; &#123; String name = "x"; &#125; &#125; */ // 没有报错 public static void main(String[] args)&#123; &#123; String name = "l"; &#125; String name = "x"; &#125;&#125; 这里第二个方法没有报错，那么其被调用时对于两个同名局部变量name是如何分配内存的？ ​ 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。 ​ 所以在main方法对应的栈内存中首先会为第一个name分配空间，当大括号结束后，该变量的内存空间会被释放。此时再为第二个name分配内存空间就不会出错。而第一个方法由于第一个name还没有被释放栈内存空间，就出现了第二个同名局部变量，这显然会报错。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL查询语句的定义顺序和执行顺序]]></title>
    <url>%2F2020%2F03%2F31%2FSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[我们前面介绍了查询语句的各个子句，但是除了SELECT之外，其他的子句全都是可以省略的。如果在一个查询语句中出现了多个子句，那么它们之间的顺序是不能乱放的，顺序如下所示： 123456789SELECT [DISTINCT] 查询列表[FROM 表名][JOIN 表名][ON 连接条件][WHERE 布尔表达式][GROUP BY 分组列表 ][HAVING 分组过滤条件][ORDER BY 排序列表][LIMIT 开始行, 限制条数] 其中中括号[]中的内容表示可以省略，我们在书写查询语句的时候各个子句必须严格遵守这个顺序，不然会报错的！ 注意：定义顺序和语句的具体执行顺序是不一致的。上述查询语句中各子句的执行顺序如下： from join on where group by having select distinct order by limit 以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应用程序或者外部查询)不可用，只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。 逻辑查询处理阶段简介（个人理解：除了from是一次性将表加载进来，其余所有的关键字都是对虚拟表一行一行的进行处理）： 1、 FROM：对FROM子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表VT1。 2、 ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。 3、 OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。（这里需要注意一下，from… join…on可以认为是一组语句，它们执行可以看做是同时的） 4、 WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。 5、 GROUP BY：按GROUP BY子句中的列表对TV4中的行进行分组，生成TV5。 6、 HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。 7、 SELECT：处理SELECT列表，产生VT8。 8、 DISTINCT：将重复的行从VT8中删除，产品VT9。 9、ORDER BY：将VT9中的行按ORDER BY子句中的列表顺序，生成一个游标(VC10)。 ​ 10、LIMIT：从VC10的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。 特别注意列别名的使用问题。 我们在定义列别名的时候是在select中定义列别名。可能存在使用列别名情况的子句包括：where、group by、having和order by。 对于SQL Server而言 由于where、group by和having的执行顺序在select前面，所以他们不能使用列别名。而对于order by而言，它在select后才执行，所以可以使用别名。 总结：只有order by才能使用别名 对于MySQL而言 我们只需要记住MySQL比较特殊，它可以在group by、having和order by中使用列别名，在where中不能使用列别名 mysql特殊是因为mysql中对查询做了加强]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式类型转换]]></title>
    <url>%2F2020%2F03%2F30%2F%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[隐式类型转换的场景只要某个值的类型与上下文要求的类型不符，MySQL就会根据上下文环境中需要的类型对该值进行类型转换，由于这些类型转换都是MySQL自动完成的，所以也可以被称为隐式类型转换。我们列举几种常见的隐式类型转换的场景： 把操作数类型转换为适合操作符计算的相应类型 比方说对于加法操作符+来说，它要求两个操作数都必须是数字才能进行计算，所以如果某个操作数不是数字的话，会将其隐式转换为数字，比方说下边这几个例子： 1231 + 2 → 3&apos;1&apos; + 2 → 3&apos;1&apos; + &apos;2&apos; → 3 虽然&#39;1&#39;、&#39;2&#39;都是字符串，但是如果它们作为加法操作符+的操作数的话，都会被强制转换为数字，所以上边几个表达式其实都会被当作1 + 2去处理的，这些表达式被放在查询列表时的效果如下： 1234567mysql&gt; SELECT 1 + 2, &apos;1&apos; + 2, &apos;1&apos; + &apos;2&apos;;+-------+---------+-----------+| 1 + 2 | &apos;1&apos; + 2 | &apos;1&apos; + &apos;2&apos; |+-------+---------+-----------+| 3 | 3 | 3 |+-------+---------+-----------+1 row in set (0.00 sec) 将函数参数转换为该函数期望的类型 我们拿用于拼接字符串的CONCAT函数举例，这个函数以字符串类型的值作为参数，如果我们在调用这个函数的时候，传入了别的类型的值作为参数，MySQL会自动把这些值的类型转换为字符串类型的： 123CONCAT(&apos;1&apos;, &apos;2&apos;) → &apos;12&apos;CONCAT(&apos;1&apos;, 2) → &apos;12&apos;CONCAT(1, 2) → &apos;12&apos; 虽然1、2都是数字，但是如果它们作为CONCAT函数的参数的话，都会被强制转换为字符串，所以上边几个表达式其实都会被当作CONCAT(&#39;1&#39;, &#39;2)去处理的，这些表达式被放到查询列表时的效果如下： 1234567mysql&gt; SELECT CONCAT(&apos;1&apos;, &apos;2&apos;), CONCAT(&apos;1&apos;, 2), CONCAT(1, 2);+------------------+----------------+--------------+| CONCAT(&apos;1&apos;, &apos;2&apos;) | CONCAT(&apos;1&apos;, 2) | CONCAT(1, 2) |+------------------+----------------+--------------+| 12 | 12 | 12 |+------------------+----------------+--------------+1 row in set (0.00 sec) 存储数据时，把某个值转换为某个列需要的类型 我们先新建一个简单的表t： 12345CREATE TABLE t ( i1 TINYINT, i2 TINYINT, s VARCHAR(100)); 这个表有三个列，列i1和i2是用来存储整数的，列s是用来存储字符串的，如果我们在存储数据的时候填入的不是期望的类型，就像这样： 12mysql&gt; INSERT INTO t(i1, i2, s) VALUES(&apos;100&apos;, &apos;100&apos;, 200);Query OK, 1 row affected (0.01 sec) 我们为列i1和i2填入的值是一个字符串值：&#39;100&#39;，列s填入的值是一个整数值：200，虽然说类型都不对，但是由于隐式类型转换的存在，在插入数据的时候字符串&#39;100&#39;会被转型为整数100，整数200会被转型成字符串&#39;200&#39;，所以最后插入成功，我们来看一下效果： 1234567mysql&gt; SELECT * FROM t;+------+------+------+| i1 | i2 | s |+------+------+------+| 100 | 100 | 200 |+------+------+------+1 row in set (0.00 sec) 类型转换的注意事项 MySQL会尽量把值转换为表达式中需要的类型，而不是产生错误。 按理说&#39;23sfd&#39;这个字符串无法转换为数字，但是MySQL规定只要字符串的开头部分包含数字，那么就把这个字符串转换为开头的数字，如果开头并没有包含数字，那么将被转换成`0`，比方说这样： 1234&apos;23sfd&apos; → 23&apos;2019-08-28&apos; → 2019&apos;11:30:32&apos; → 11&apos;sfd&apos; → 0 看个例子： 1234567mysql&gt; SELECT &apos;23sfd&apos; + 0, &apos;sfd&apos; + 0;+-------------+-----------+| &apos;23sfd&apos; + 0 | &apos;sfd&apos; + 0 |+-------------+-----------+| 23 | 0 |+-------------+-----------+1 row in set, 2 warnings (0.00 sec) 不过需要注意的是，这种强制转换不能用于存储数据中，比方说这样： 12mysql&gt; INSERT INTO t(i1, i2, s) VALUES(&apos;sfd&apos;, &apos;sfd&apos;, &apos;aaa&apos;);ERROR 1366 (HY000): Incorrect integer value: &apos;sfd&apos; for column &apos;i1&apos; at row 1 在运算时会自动提升操作数的类型。 我们知道不同数据类型能表示的数值范围是不一样的，在小的数据类型经过算数计算后得出的结果可能大于该可以表示的范围。比方说t表中有一条记录如下： 1234567mysql&gt; SELECT * FROM t;+------+------+------+| i1 | i2 | s |+------+------+------+| 100 | 100 | 200 |+------+------+------+1 row in set (0.00 sec) 其中的i1列和i2列的类型都是TINYINT，而TINYINT能表示的最大正整数是127，如果我们把i1列的值和i2列的值相加会发生什么呢？请看： 1234567mysql&gt; SELECT i1 + i2 FROM t;+---------+| i1 + i2 |+---------+| 200 |+---------+1 row in set (0.00 sec) 可以看到最后的结果是200，可是它已经超过TINYINT类型的表示范围了。其实在运算的过程中，MySQL自动将整数类型的操作数提升到了BIGINT，这样就不会产生运算结果太大超过TINYINT能表示的数值范围的尴尬情况了。类似的，有浮点数的运算过程会把操作数自动转型为DOUBLE类型。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式与函数]]></title>
    <url>%2F2020%2F03%2F26%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[表达式如果拥有小学学历，就知道将数字和运算符连接起来的组合称之为表达式，比方说这样： 121 + 14 * 3 其中的数字称之为操作数，运算符可以称之为操作符。特殊的，单个操作数也可以被看作是一个特殊的表达式。 在MySQL中也有表达式的概念，不过操作数和操作符的含义有了扩充。下边详细看一下。 操作数MySQL中操作数可以是下边这几种类型： 常数：常数很好理解，我们平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字1，字符串&#39;abc&#39;，时间值2019-08-16 17:10:43啥的。 列名：针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于student_info表来说，number、name都可以作为操作数。 函数调用：MySQL中有函数的概念，比方说获取当前时间的函数NOW，而在函数后边加个小括号就算是一个函数调用，比如NOW()。 标量子查询或行子查询 其它表达式：一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式，比方说（假设col是一个列名）： (1 + 1) 2 + col 3 操作符 算数操作符：就是加减乘除法那一堆，我们看一下MySQL中都支持哪些 操作符 示例 描述 + a + b 加法 - a - b 减法 * a * b 乘法 / a / b 除法 DIV a DIV b 除法，取商的整数部分 % a % b 取余数 - -a 负号 在使用MySQL中的算术操作符时需要注意，DIV和/都表示除法操作符，但是DIV只会取商的整数部分，/会保留商的小数部分。比如表达式 2 DIV 3的结果是0，而2 / 3的结果是0.6667。 比较操作符：就是在搜索条件中我们已经看过的比较操作符，我们把常用的都抄下来看一下： 操作符 示例 描述 = a = b a等于b &lt;&gt; 或 != a &lt;&gt; b a不等于b &lt; a &lt; b a小于b &lt;= a &lt;= b a小于等于b &gt; a &gt; b a大于b >= a &gt;= b a大于等于b BETWEEN a BETWEEN b AND c b &lt;= a &lt;= c NOT BETWEEN a NOT BETWEEN b AND c 不满足b &lt;= a &lt;= c IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2,…) a不是b1,b2,…中的任意一个 IS NULL a IS NULL a是NULL IS NOT NULL a IS NOT NULL a不是NULL LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b 由比较操作符连接而成的表达式也称为布尔表达式，表示真或者假，也可以称为TRUE或者FALSE。比如1 &gt; 3就代表FALSE，3 != 2就代表TRUE。 逻辑操作符：逻辑操作符是用来将多个布尔表达式连接起来，我们需要了解这几个逻辑操作符： 操作符 示例 描述 AND a AND b 只有a和b同时为真，表达式才为真 OR a OR b 只要a或b有任意一个为真，表达式就为真 XOR a XOR b a和b有且只有一个为真，表达式为真 表达式的使用只要把这些操作数和操作符相互组合起来就可以组成一个表达式。表达式主要以下边这两种方式使用： 放在查询列表中 我们前边都是将列名放在查询列表中的(*号代表所有的列名～)。列名只是表达式中超级简单的一种，我们可以将任意一个表达式作为查询列表的一部分来处理，比方说我们可以在查询student_score表时把score字段的数据都加100，就像这样： 1234567891011121314mysql&gt; SELECT number, subject, score + 100 FROM student_score;+----------+-----------------------------+-------------+| number | subject | score + 100 |+----------+-----------------------------+-------------+| 20180101 | 母猪的产后护理 | 178 || 20180101 | 论萨达姆的战争准备 | 188 || 20180102 | 母猪的产后护理 | 200 || 20180102 | 论萨达姆的战争准备 | 198 || 20180103 | 母猪的产后护理 | 159 || 20180103 | 论萨达姆的战争准备 | 161 || 20180104 | 母猪的产后护理 | 155 || 20180104 | 论萨达姆的战争准备 | 146 |+----------+-----------------------------+-------------+8 rows in set (0.00 sec) 其中的number、subject、score + 100都是表达式，结果集中的列的名称也将默认使用这些表达式的名称，所以如果你觉得原名称不好，我们可以使用别名： 1234567891011121314mysql&gt; SELECT number, subject, score + 100 AS score FROM student_score;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180101 | 母猪的产后护理 | 178 || 20180101 | 论萨达姆的战争准备 | 188 || 20180102 | 母猪的产后护理 | 200 || 20180102 | 论萨达姆的战争准备 | 198 || 20180103 | 母猪的产后护理 | 159 || 20180103 | 论萨达姆的战争准备 | 161 || 20180104 | 母猪的产后护理 | 155 || 20180104 | 论萨达姆的战争准备 | 146 |+----------+-----------------------------+-------+8 rows in set (0.00 sec) 需要注意的是，放在查询列表的表达式也可以不涉及列名，就像这样： 123456789101112mysql&gt; SELECT 1 FROM student_info;+---+| 1 |+---+| 1 || 1 || 1 || 1 || 1 || 1 |+---+6 rows in set (0.01 sec) 因为student_info中有6条记录，所以结果集中也就展示了6条结果，不过我们的查询列表处只有一个常数1，所以所有的结果的值也都是常数1。这种查询列表中不涉及列名的情况下，我们甚至可以省略掉FROM子句后边的表名，就像这样： 1234567mysql&gt; SELECT 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec) 作为搜索条件 我们在介绍搜索条件的时候介绍的都是带有列名的表达式，搜索条件也可以不带列名，比如这样： 123456789101112mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE 2 &gt; 1;+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 || 20180103 | 范统 | 17156319980116959X | 软件工程 || 20180104 | 史珍香 | 141992199701078600 | 软件工程 || 20180105 | 范剑 | 181048199308156368 | 飞行器设计 || 20180106 | 朱逸群 | 197995199501078445 | 电子信息 |+----------+-----------+--------------------+--------------------------+6 rows in set (0.00 sec) 由于我们的搜索条件是2 &gt; 1，这个条件对于表中的每一条记录都成立，所以最后的查询结果就是全部的记录。不过这么写有点儿傻哈，没有一毛钱卵用，没一点实际意义～ 所以通常情况下搜索条件中都会包含列名的。 函数如果我们想使用函数，可以在函数名后加一个小括号()就好，表示调用一下这个函数，简称函数调用。比方说NOW()就代表调用NOW函数来获取当前日期和时间。针对某些包含参数的函数，我们也可以在小括号()里将参数填入，比方说UPPER(&#39;abc&#39;)表示将字符串&#39;abc&#39;转换为大写格式。 下边来介绍一些常用的MySQL内置函数： 文本处理函数 名称 调用示例 示例结果 描述 LEFT LEFT(‘abc123’,3) abc 给定字符串从左边取指定长度的子串 RIGHT RIGHT(‘abc123’,3) 123 给定字符串从右边取指定长度的子串 LENGTH LENGTH(‘abc’) 3 给定字符串的长度 LOWER LOWER(‘ABC’) abc 给定字符串的小写格式 UPPER UPPER(‘abc’) ABC 给定字符串的大写格式 LTRIM LTRIM(‘ abc’) abc 给定字符串左边空格去除后的格式 RTRIM RTRIM(‘abc ‘) abc 给定字符串右边空格去除后的格式 SUBSTRING SUBSTRING(‘abc123’,2,3) bc1 给定字符串从指定位置截取指定长度的子串 CONCAT CONCAT(‘abc’,’123’,’xyz’) abc123xyz 将给定的各个字符串拼接成一个新字符串 我们以SUBSTRING函数为例试一下： 1234567mysql&gt; SELECT SUBSTRING(&apos;abc123&apos;, 2, 3);+---------------------------+| SUBSTRING(&apos;abc123&apos;, 2, 3) |+---------------------------+| bc1 |+---------------------------+1 row in set (0.00 sec) 我们前边在唠叨表达式的说过，函数调用也算是一种表达式的操作数，它可以和其他操作数用操作符连接起来组成一个表达式来作为查询列表的一部分或者放到搜索条件中。我们来以CONCAT函数为例来看一下： 1234567891011121314mysql&gt; SELECT CONCAT(&apos;学号为&apos;, number, &apos;的学生在《&apos;, subject, &apos;》课程的成绩是：&apos;, score) AS 成绩描述 FROM student_score;+---------------------------------------------------------------------------------------+| 成绩描述 |+---------------------------------------------------------------------------------------+| 学号为20180101的学生在《母猪的产后护理》课程的成绩是：78 || 学号为20180101的学生在《论萨达姆的战争准备》课程的成绩是：88 || 学号为20180102的学生在《母猪的产后护理》课程的成绩是：100 || 学号为20180102的学生在《论萨达姆的战争准备》课程的成绩是：98 || 学号为20180103的学生在《母猪的产后护理》课程的成绩是：59 || 学号为20180103的学生在《论萨达姆的战争准备》课程的成绩是：61 || 学号为20180104的学生在《母猪的产后护理》课程的成绩是：55 || 学号为20180104的学生在《论萨达姆的战争准备》课程的成绩是：46 |+---------------------------------------------------------------------------------------+8 rows in set (0.00 sec) 日期和时间处理函数 名称 调用示例 示例结果 描述 NOW NOW() 2019-08-16 17:10:43 返回当前日期和时间 CURDATE CURDATE() 2019-08-16 返回当前日期 CURTIME CURTIME() 17:10:43 返回当前时间 DATE DATE(‘2019-08-16 17:10:43’) 2019-08-16 将给定日期和时间值的日期提取出来 DATE_ADD DATE_ADD(‘2019-08-16 17:10:43’, INTERVAL 2 DAY) 2019-08-18 17:10:43 将给定的日期和时间值添加指定的时间间隔 DATE_SUB DATE_SUB(‘2019-08-16 17:10:43’, INTERVAL 2 DAY) 2019-08-14 17:10:43 将给定的日期和时间值减去指定的时间间隔 DATEDIFF DATEDIFF(‘2019-08-16’, ‘2019-08-17’); -1 返回两个日期之间的天数（负数代表前一个参数代表的日期比较小） DATE_FORMAT DATE_FORMAT(NOW(),’%m-%d-%Y’) 08-16-2019 用给定的格式显示日期和时间 在使用这些函数时需要注意一些地方： 在使用DATE_ADD和DATE_SUB这两个函数时需要注意，增加或减去的时间间隔单位可以自己定义，下边是MySQL支持的一些时间单位： | 时间单位 | 描述 || :————-: | :—: || MICROSECOND | 毫秒 || SECOND | 秒 || MINUTE | 分钟 || HOUR | 小时 || DAY | 天 || WEEK | 星期 || MONTH | 月 || QUARTER | 季度 || YEAR | 年 | 如果我们相让2019-08-16 17:10:43这个时间值增加2分钟，可以这么写： 1234567mysql&gt; SELECT DATE_ADD(&apos;2019-08-16 17:10:43&apos;, INTERVAL 2 MINUTE);+----------------------------------------------------+| DATE_ADD(&apos;2019-08-16 17:10:43&apos;, INTERVAL 2 MINUTE) |+----------------------------------------------------+| 2019-08-16 17:12:43 |+----------------------------------------------------+1 row in set (0.00 sec) 在使用DATE_FORMAT函数时需要注意，我们可以通过一些所谓的格式符来自定义日期和时间的显示格式，下边是MySQL中常用的一些日期和时间的格式符以及它们对应的含义： 格式符 描述 %b 简写的月份名称（Jan、Feb、…、Dec) %D 带有英文后缀的月份中的日期（0th、1st、2nd、…、31st)） %d 数字格式的月份中的日期(00、01、02、…、31) %f 微秒（000000-999999） %H 二十四小时制的小时 (00-23) %h 十二小时制的小时 (01-12) %i 数值格式的分钟(00-59) %M 月份名（January、February、…、December） %m 数值形式的月份(00-12) %p 上午或下午（AM代表上午、PM代表下午） %S 秒(00-59) %s 秒(00-59) %W 星期名（Sunday、Monday、…、Saturday） %w 周内第几天 （0=星期日、1=星期一、 6=星期六） %Y 4位数字形式的年（例如2019） %y 2位数字形式的年（例如19） 我们可以把我们想要的显示格式用对应的格式符描述出来，就像这样： 1234567mysql&gt; SELECT DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;);+----------------------------------------+| DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;) |+----------------------------------------+| Mar 30 2020 10:54 AM |+----------------------------------------+1 row in set 数值处理函数下边列举一些数学上常用到的函数，在遇到需要数学计算的业务时会很有用： 名称 调用示例 示例结果 描述 ABS ABS(-1) 1 取绝对值 Pi PI() 3.141593 返回圆周率 COS COS(PI()) -1 返回一个角度的余弦 EXP EXP(1) 2.718281828459045 返回e的指定次方 MOD MOD(5,2) 1 返回除法的余数 RAND RAND() 0.7537623539136372 返回一个随机数 SIN SIN(PI()/2) 1 返回一个角度的正弦 SQRT SQRT(9) 3 返回一个数的平方根 TAN TAN(0) 0 返回一个角度的正切 聚集函数聚集函数又称为多行处理函数，和上面的函数（单行处理函数有区别）。聚集函数一共有5个，它的特点是输入多行，最终输出一行。而单行处理函数的特点书输入单行，输出单行。 有些函数是用来统计数据的，比方说统计一下表中的行数，某一列数据的最大值是什么，我们把这种函数称之为聚集函数，下边介绍MySQL中常用的几种聚集函数： 函数名 描述 COUNT 返回某列的行数 MAX 返回某列的最大值 MIN 返回某列的最小值 SUM 返回某列值之和 AVG 返回某列的平均值 注意：在mysql中除了count(*)为特例（不忽略null值）外，其余聚集函数是忽略null值 COUNT函数COUNT函数使用来统计行数的，它有下边两种使用方式： COUNT(*)：对表中行的数目进行计数，不管列的值是不是NULL。 COUNT(列名)：对特定的列进行计数，会忽略掉该列为NULL的行。 两者的区别是会不会忽略统计列的值为NULL的行！两者的区别是会不会忽略统计列的值为NULL的行！两者的区别是会不会忽略统计列的值为NULL的行！重要的事情说3遍 MAX函数MAX函数是用来查询某列中数据的最大值，以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT MAX(score) FROM student_score;+------------+| MAX(score) |+------------+| 100 |+------------+1 row in set (0.00 sec) MIN函数MIN函数是用来查询某列中数据的最小值，以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT MIN(score) FROM student_score;+------------+| MIN(score) |+------------+| 46 |+------------+1 row in set (0.00 sec) SUM函数SUM函数是用来计算某列数据的和，还是以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT SUM(score) FROM student_score;+------------+| SUM(score) |+------------+| 585 |+------------+1 row in set (0.01 sec) AVG函数AVG函数是用来计算某列数据的平均数，还是以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT AVG(score) FROM student_score;+------------+| AVG(score) |+------------+| 73.1250 |+------------+1 row in set (0.00 sec) 注意：上述五个聚集函数不可直接出现在where子句当中！例如有个需求，表emp中有每个人的个人信息（姓名name、工资sal等），要找出工资大于平均工资的人的信息。我们可能会想到下面这种写法，但是要注意这种写法是完全错误的！ 12mysql&gt; select name from emp where sal &gt; avg(sal);/* 错误信息：ERROR 1111 (HY000): Invalid use of group function*/ 那这到底是为什么呢？为什么聚集函数不能出现在where子句当中呢？ 因为聚集函数一般都会和group by联合使用！并且任何一个聚集函数（count、sum、max、min、avg）都是在group by语句执行之后才会执行的。当一条sql语句没有group by的时候，整张表的数据会自成一组。但这里好像还是没说明为啥不能出现在where子句当中？其实已经说明了，因为group by的执行顺序是在where之后，所以当然不能在where中用聚集函数了，因为聚集函数要在group by执行之后使用 但是还有个问题： 1mysql&gt; SELECT AVG(score) FROM student_score; 上面这个语句为什么可以运行呢？它也没有group by语句啊！这里我们需要注意，如果一个查询语句中没有显示地写出group by语句，会默认的存在一个缺省的group by语句，使得整张表自成一组。 好啦，现在疑问解决了！那么上面的那个需求怎么解决呢？可以使用子查询 1mysql&gt; select name from emp where sal &gt; (select avg(sal) from emp); 这里先给个结论：聚集函数只能出现在select子句、having子句和order by子句中！！！ 给定搜索条件下聚集函数的使用聚集函数并不是一定要统计一个表中的所有记录，我们也可以指定搜索条件来限定这些聚集函数作用的范围。比方说我们只想统计&#39;母猪的产后护理&#39;这门课程的平均分可以这么写： 1234567mysql&gt; SELECT AVG(score) FROM student_score WHERE subject = &apos;母猪的产后护理&apos;;+------------+| AVG(score) |+------------+| 73.0000 |+------------+1 row in set (0.00 sec) 换句话说就是：不在搜索条件中的那些记录是不参与统计的。 聚集函数中DISTINCT的使用默认情况下，上边介绍的聚集函数将计算指定列的所有非NULL数据，如果我们指定的列中有重复数据的话，可以选择使用DISTINCT来过滤掉这些重复数据。比方说我们想查看一下student_info表中存储了多少个专业的学生信息，就可以这么写： 1234567mysql&gt; SELECT COUNT(DISTINCT major) FROM student_info;+-----------------------+| COUNT(DISTINCT major) |+-----------------------+| 4 |+-----------------------+1 row in set (0.01 sec) 组合聚集函数这些聚集函数也可以集中在一个查询中使用，比如这样： 1234567mysql&gt; SELECT COUNT(*) AS 成绩记录总数, MAX(score) AS 最高成绩, MIN(score) AS 最低成绩, AVG(score) AS 平均成绩 FROM student_score;+--------------------+--------------+--------------+--------------+| 成绩记录总数 | 最高成绩 | 最低成绩 | 平均成绩 |+--------------------+--------------+--------------+--------------+| 8 | 100 | 46 | 73.1250 |+--------------------+--------------+--------------+--------------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之使用通配符进行模糊查询]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[有时候我们并不能精确地描述我们要查询的哪些结果，比如我们只想看看姓&#39;杜&#39;的学生信息，而不能精确的描述出这些姓&#39;杜&#39;的同学的完整姓名，我们称这种查询为模糊查询。MySQL中使用下边这两个操作符来支持模糊查询： 操作符 示例 描述 LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b 注意：如果要进行模糊查询，只能使用上述操作符。不能使用 = 等操作符 既然我们不能完整描述要查询的信息，那就用某个符号来替代这些模糊的信息，这个符号就被称为通配符。MySQL中支持下边这两个通配符： %：表示任何字符出现任意次数 (可以是0次) 具体使用如下： 匹配以&quot;yves&quot;开头的记录:(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;yves%&#39;; 匹配包含&quot;yves&quot;的记录(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;%yves%&#39;; 匹配以&quot;yves&quot;结尾的记录(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;%yves&#39;; _：下划线通配符，表示只能匹配单个字符,不能多也不能少,就是一个字符 有的时候我们知道要查询的字符串中有多少个字符，而使用%时匹配的范围太大，我们就可以用_来做通配符。 具体使用： SELECT * FROM products WHERE prod_name like &#39;_yves&#39;;匹配结果为: 像&quot;yyves&quot;这样记录. SELECT * FROM products WHERE prod_name like &#39;yves__&#39;;匹配结果为: 像&quot;yvesHe&quot;这样的记录.(一个下划线只能匹配一个字符,不能多也不能少) 小细节：如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE prod_name like &#39;1000&#39;;只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果. 注意：LIKE或者NOT LIKE操作符只用于字符串匹配。通配符不能代表NULL，如果需要匹配NULL的话，需要使用IS NULL或者IS NOT NULL。%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE prod_name like &#39;%&#39;;是匹配不到prod_name为NULL的的记录 转义通配符 如果待匹配的字符串中本身就包含普通字符&#39;%&#39;或者&#39;_&#39;该咋办，怎么区分它是一个通配符还是一个普通字符呢？ 答：如果匹配字符串中需要普通字符&#39;%&#39;或者&#39;_&#39;的话，需要在它们前边加一个反斜杠\来和通配符区分开来，也就是说： &#39;\%&#39;代表普通字符&#39;%&#39; &#39;\_&#39;代表普通字符&#39;_&#39; 比方说这样： 上面我们说到了LIKE和NOT LIKE只能用于字符串匹配，但我在实际中却发现了这个问题： 123456789mysql&gt; select * from student_score where score like &apos;_8&apos;;+----------+--------------------+-------+| number | subject | score |+----------+--------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+--------------------+-------+3 rows in set 这里score字段是INT型，但为什么还是可以进行模糊查询？后来发现是这里发生了隐式类型转换（具体介绍见：隐式类型转换）。 正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之带条件的查询]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E5%B8%A6%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[通常并不是对所有的记录都感兴趣，只是想查询到符合某些条件的那些记录。这些条件也被称为搜索条件或者过滤条件，当某条记录符合搜索条件时，它将被放入结果集中。 简单搜索条件我们需要把搜索条件放在WHERE子句中，比如我们想查询student_info表中名字是范剑的学生的一些信息，可以这么写： 1234567mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE name = &apos;范剑&apos;;+----------+------+--------------------+------------+| number | name | id_number | major |+----------+------+--------------------+------------+| 20180105 | 范剑 | 181048199308156368 | 飞行器设计 |+----------+------+--------------------+------------+1 row in set 这个例子中的搜索条件就是name = &#39;范剑&#39;，也就是当记录中的name列的值是&#39;范剑&#39;的时候，该条记录的number、name、id_number、major这些字段才可以被放入结果集。搜索条件name = &#39;范剑&#39;中的=称之为比较操作符，除了=之外，设计MySQL的大叔还提供了很多别的比较操作符，比如： 操作符 示例 描述 = a = b a等于b &lt;&gt; 或 != a &lt;&gt; b a不等于b &lt; a &lt; b a小于b &gt; a &gt; b a 大于b &lt;= a &lt;= b a小于等于b >= a &gt;= b a大于等于b BETWEEN a BETWEEN b AND c（必须b小于c） 满足b &lt;= a &lt;= c NOT BETWEEN a NOT BETWEEN b AND c 不满足b &lt;= a &lt;= c 匹配多个元素有时候搜索条件中指定的匹配值并不是单个值，而是一个列表，只要匹配到列表中的某一项就算匹配成功，这种情况可以使用IN操作符： 操作符 示例 描述 IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2,…) a不是b1,b2,…中的任意一个 比如我们想查询软件工程和飞行器设计专业的学生信息，可以这么写： 123456789mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE major IN (&apos;软件工程&apos;, &apos;飞行器设计&apos;);+----------+-----------+--------------------+-----------------+| number | name | id_number | major |+----------+-----------+--------------------+-----------------+| 20180103 | 范统 | 17156319980116959X | 软件工程 || 20180104 | 史珍香 | 141992199701078600 | 软件工程 || 20180105 | 范剑 | 181048199308156368 | 飞行器设计 |+----------+-----------+--------------------+-----------------+3 rows in set (0.01 sec) 如果想查询不是这两个专业的学生的信息，可以这么写： 123456789mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE major NOT IN (&apos;软件工程&apos;, &apos;飞行器设计&apos;);+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 || 20180106 | 朱逸群 | 197995199501078445 | 电子信息 |+----------+-----------+--------------------+--------------------------+3 rows in set (0.00 sec) 有个小问题，如果表中存在NULL值，该如何匹配搜索呢？ NULL代表没有值，意味着你并不知道该列应该填入什么数据，在判断某一列是否为NULL的时候并不能单纯的使用=操作符，而是需要专业判断值是否是NULL的操作符： 操作符 示例 描述 IS NULL a IS NULL a的值是NULL IS NOT NULL a IS NOT NULL a的值不是NULL 比如我们想看一下student_info表的name列是NULL的学生记录有哪些，可以这么写： 12mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE name IS NULL;Empty set (0.00 sec) 由于所有记录的name列都不是NULL值，所以最后的结果集是空的 再次强调一遍，不能直接使用普通的操作符来与NULL值进行比较，必须使用IS NULL或者IS NOT NULL！ 多个搜索条件的查询上边介绍的都是指定单个的搜索条件的查询，我们也可以在一个查询语句中指定多个搜索条件。 AND操作符在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候才将其加入结果集，这种情况我们可以使用AND操作符来连接多个搜索条件。 12345678mysql&gt; SELECT * FROM student_score WHERE subject = &apos;母猪的产后护理&apos; AND score &gt; 75;+----------+-----------------------+-------+| number | subject | score |+----------+-----------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180102 | 母猪的产后护理 | 100 |+----------+-----------------------+-------+2 rows in set (0.00 sec) 其中的subject = &#39;母猪的产后护理&#39;和score &gt; 75是两个搜索条件，我们使用AND操作符把这两个搜索条件连接起来表示只有当两个条件都满足的记录才能被加入到结果集。 OR操作符在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用OR操作符来连接多个搜索条件。 比如我们想从student_score表中找出成绩大于95分或者小于55分的记录，可以这么写： 123456789mysql&gt; SELECT * FROM student_score WHERE score &gt; 95 OR score &lt; 55;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 || 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+3 rows in set (0.00 sec) 注意：AND操作符的优先级高于OR操作符，也就是说在判断某条记录是否符合条件时会先检测AND操作符两边的搜索条件 例如： 1score &gt; 95 OR score &lt; 55 AND subject = &apos;论萨达姆的战争准备&apos; 上述语句可以被看作下面两个条件中任意一个条件成立则使整个式子成立： score &gt; 95 score &lt; 55 AND subject = ‘论萨达姆的战争准备’ 这种优先级是非常尴尬的！因此为了避免这种尴尬，可以用小括号()显示指定各搜索条件优先级，比如上面式子可以写成这样： 1(score &gt; 95 OR score &lt; 55) AND subject = &apos;论萨达姆的战争准备&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之查询、去重、限制条数、排序]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E3%80%81%E5%8E%BB%E9%87%8D%E3%80%81%E9%99%90%E5%88%B6%E6%9D%A1%E6%95%B0%E3%80%81%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[对于使用MySQL的我们来说，平时使用频率最高的还是查询功能，就是按照我们给定的要求将数据给查出来。 查询查询单个列查看某个表中的某一列的数据的通用格式是这样： 1SELECT 列名 FROM 表名; 也就是说把需要查询的列名放到单词SELECT后边就好了，比如查看student_info表中的number列的数据可以这么写： 123456789101112mysql&gt; SELECT number FROM student_info;+----------+| number |+----------+| 20180104 || 20180102 || 20180101 || 20180103 || 20180105 || 20180106 |+----------+6 rows in set 可以看到查询结构中就把所有记录的number列都展示了出来，我们有时候也把这个结果称之为结果集。 列的别名我们也可以为结果集中的列重新定义一个别名，命令格式如下： 1SELECT 列名 [AS] 列的别名 FROM 表名; 我们看到AS被加了个中括号，意味着可有可无，没有AS的话，列名和列的别名之间用空白字符隔开就好了。比如我们想给number列起个别名，可以使用下边这两种方式之一： 方式一 1SELECT number AS 学号 FROM student_info; 方式二 1SELECT number 学号 FROM student_info; 执行结果如下： 123456789101112mysql&gt; SELECT number AS 学号 FROM student_info;+----------+| 学号 |+----------+| 20180104 || 20180102 || 20180101 || 20180103 || 20180105 || 20180106 |+----------+6 rows in set 看到黑框框里的结果集中显示的列名就不再是number，而是我们刚刚定义的别名学号了。不过需要注意的是：别名只是在本次查询的到的结果集中展示，而不会改变真实表中的列名。下一次查询中你对number列取其他的别名也可以。 查询多个列如果想查询多个列的数据，可以在SELECT后边写多个列名，用逗号,分隔开就好： 1mysql&gt; SELECT 列名1, 列名2, ... 列名n FROM 表名; 我们把SELECT语句后边跟随的多个列统称为查询列表，需要注意的是，查询列表中的列名可以按任意顺序摆放，结果集将按照我们摆放的列名顺序显示 注意，查询多个列也能分别加别名 1mysql&gt; SELECT 列名1 as a, 列名2 as b, ... 列名n as n FROM 表名; 查询所有列如果需要把记录中的所有列都查出来，MySQL也提供一个省事儿的办法，我们之前也介绍过，就是直接用星号*来表示要查询的东西，就像这样： 1SELECT * FROM 表名; 注意：除非你确实需要表中的每个列，否则一般最好别使用星号*来查询所有列，虽然星号*看起来很方便，不用明确列出所需的列，但是查询不需要的列通常会降低性能。 查询结果去重去除单列的重复结果有的时候我们查询某个列的数据时会有一些重复的结果，比如我们查询一下student_info表的学院信息： 123456789101112mysql&gt; SELECT department FROM student_info;+------------+| department |+------------+| 计算机学院 || 计算机学院 || 计算机学院 || 计算机学院 || 航天学院 || 航天学院 |+------------+6 rows in set 因为表里有6条记录，所以给我们返回了6条结果。但是其实好多都是重复的结果，如果我们想去除重复结果的话，可以将DISTINCT放在被查询的列前边，就是这样： 1SELECT DISTINCT 列名 FROM 表名; 结果如下： 12345678mysql&gt; SELECT DISTINCT department FROM student_info;+------------+| department |+------------+| 计算机学院 || 航天学院 |+------------+2 rows in set 去除多列的重复结果对于查询多列的情况，两条结果重复的意思是：两条结果的每一个列中的值都相同。比如查询学院和专业信息： 如果我们想对多列查询的结果去重的话，可以直接把DISTINCT放在被查询的列的最前边： 1SELECT DISTINCT 列名1, 列名2, ... 列名n FROM 表名; 结果如下： 12345678910mysql&gt; SELECT DISTINCT department, major FROM student_info;+------------+------------------+| department | major |+------------+------------------+| 计算机学院 | 计算机科学与工程 || 计算机学院 | 软件工程 || 航天学院 | 飞行器设计 || 航天学院 | 电子信息 |+------------+------------------+4 rows in set 注意：distinct只能出现在所有字段的最前方，即前面不能出现的别的字段，要不然查询出来的数目不对应（因为有的去重了，有的没去重） 限制查询结果条数注意：LIMIT是MySQL特有的，其它数据库不通用（Oracle有一个相同的机制，叫做rownum） 有时候查询结果的条数会很多，都显示出来可能会撑爆屏幕～ 所以MySQL给我们提供了一种限制结果集中的记录条数的方式，就是在查询语句的末尾使用这样的语法： 1LIMIT 开始行, 限制条数; 开始行指的是我们想从第几行数据开始查询，限制条数是结果集中最多包含多少条记录。从0开始，0代表第一行 比如我们查询一下student_info表，从第1条记录开始，最多查询2条记录可以这么写： 12345678mysql&gt; SELECT number, name, id_number, major FROM student_info LIMIT 0, 2;+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 |+----------+-----------+--------------------+--------------------------+2 rows in set (0.00 sec) 注意：如果指定的开始行大于表中的最大行数，那查询结果就什么都没有：开始行默认从第0行开始（计算机中的第0行是我们平时说的第一行）。如果查询的结果条数不超过限制条数，那就可以全部显式出来 LIMIT后边也可以只有一个参数，那这个参数就代表着限制行数。也就是说我们可以不指定开始行，默认的开始行就是第0行。 重点：通用的标准分页SQL？ 每页显示三条记录： 第一页：0,3 第二页：3,3 第三页：6,3 第五页：9,3 …….. 通用公式如下： 每页显示pageSize记录： 第pageNo页：（pageNo-1）*pageSize，pageSize pageSize是每页显示多少条记录，pageNo是显示第几页 对查询结果排序我们之前查询number列的时候得到的记录并不是有序的，这是为什么呢？MySQL其实默认会按照这些数据底层存储的顺序来给我们返回数据，但是这些数据可能会经过更新或者删除，如果我们不明确指定按照什么顺序来排序返回结果的话，那我们可以认为该结果中记录的顺序是不确定的。换句话说如果我们想让返回结果中的记录按照某种特定的规则排序，那我们必须显式的指定排序规则。 按照单个列的值排序我们可以用下边的语法来指定返回结果的记录按照某一列的值进行排序： 1ORDER BY 列名 ASC|DESC ASC和DESC指的是排序方向。ASC是指按照指定列的值进行由小到大进行排序，也叫做升序，DESC是指按照指定列的值进行由大到小进行排序，也叫做降序，中间的|表示这两种方式只能选一个。这回我们用student_score表测试一下 1234567891011121314mysql&gt; SELECT * FROM student_score ORDER BY score ASC;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180104 | 论萨达姆的战争准备 | 46 || 20180104 | 母猪的产后护理 | 55 || 20180103 | 母猪的产后护理 | 59 || 20180103 | 论萨达姆的战争准备 | 61 || 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 论萨达姆的战争准备 | 98 || 20180102 | 母猪的产后护理 | 100 |+----------+-----------------------------+-------+8 rows in set (0.01 sec) 可以看到输出的记录就是按照成绩由小到大进行排序的。如果省略了 ORDER BY 语句中的排序方向，则默认按照从小到大的顺序进行排序，也就是说ORDER BY 列名和ORDER BY 列名 ASC的语义是一样的 按照多个列的值排序我们也可以同时指定多个排序的列，多个排序列之间用逗号,隔开就好了，就是这样： 1ORDER BY 列1 ASC|DESC, 列2 ASC|DESC ... 它的意思是根据顺序依次进行排序，比如先按列1排序，排完之后再按照列2排序，以此类推。 比如我们想让对student_score的查询结果先按照subjuect排序，再按照score值从大到小的顺序进行排列，可以这么写： 1234567891011121314mysql&gt; SELECT * FROM student_score ORDER BY subject, score DESC;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180101 | 母猪的产后护理 | 78 || 20180103 | 母猪的产后护理 | 59 || 20180104 | 母猪的产后护理 | 55 || 20180102 | 论萨达姆的战争准备 | 98 || 20180101 | 论萨达姆的战争准备 | 88 || 20180103 | 论萨达姆的战争准备 | 61 || 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+8 rows in set (0.00 sec) 注意：MySQL中用order by排序的字段不一定要在select语句中，而且order by后面还可以跟聚集函数 我们还可以让ORDER BY语句和LIMIT语句结合使用，不过 ORDER BY 语句必须放在 LIMIT 语句前边 1234567mysql&gt; SELECT * FROM student_score ORDER BY score LIMIT 1;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+1 row in set (0.00 sec) 这样就能找出成绩最低的那条记录了]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底弄懂Unicode编码那些事儿]]></title>
    <url>%2F2020%2F03%2F22%2F%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[Java中是采用Unicode编码方式的，作为万国码，它的应用非常广泛，因此下面我们就开始彻底弄懂它吧！ ASCII码在学校学 C 语言的时候，了解到一些计算机内部的机制，知道所有的信息最终都表示为一个二进制的字符串，每一个二进制位有 0 和 1 两种状态，通过不同的排列组合，使用 0 和 1 就可以表示世界上所有的东西，感觉有点中国“太极”的感觉——“太极生两仪，两仪生四象，四象生八卦”。 在计算机种中，1 字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256 中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码，即ASCII码用一个字节完成字符表示。 ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 对应的ASCII码是65（这是十进制数，对应二进制是0100 0001）。这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0。 历史遗留问题英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 因此，ASCII码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。 Unicode编码最终，人们意识到应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。 Unicode相当于是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，即Unicode没有说明如何用二进制存储这些字符。我们只用知道 Unicode 给所有的字符指定了一个数字（后面可以看到，这个数字叫码点）用来表示该字符。 Unicode是计算机领域的一项行业标准，它对世界上绝大部分的文字的进行整理和统一编码，Unicode的编码空间可以划分为17个平面（plane），每个平面包含2的16次方（65536）个码位。在Unicode编码标准中，码点采用十六 进制书写，并加上前缀U+ 例如：U+0041就是A的码点。17个平面的码位可表示为从U+0000到U+10FFFF，共计1114112个码位，第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区段是永久保留不映射到Unicode字符，所以有效码位为1112064个。 对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 Unicode编码方式之前提到，Unicode没有规定其中的字符对应的二进制码点如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。 这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。 于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。 UTF-8UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8是目前互联网上使用最广泛的一种Unicode编码方式，它的特点是可变长。它可以使用1-4个字节来存储一个字符，根据字符的不同而变换长度。编码规则如下： 对于单个字节的字符（码点范围是0 ~ 127），第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同，即可兼容ASCII码。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充 编码规则如下： Unicode十六进制码点范围 UTF-8二进制模板 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16在了解UTF-16编码方式前，先了解以下另外一个概念——“平面” 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个平面，也就是说，整个 Unicode 字符集的大小现在是17*65536=1114112。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 UTF-32UTF-32是一种定长编码，使用一个32bit的码元，其值域Unicode码点值相等。举例如下 字符 Unicode码点值 UTF-32编码 A U+0041 0x00 0x00 0x00 0x41 破 U+7834 0x00 0x00 0x78 0x34 晓 U+6653 0x00 0x00 0x66 0x53 𪚥 U+2A6A5 0x00 0x02 0xA6 0xA5 UTF-8、UTF-16和UTF-32的比较这三种编码方案各有优缺点，下面分别介绍 UTF-8优点 兼容 ASCII 没有字节序问题 以英文和西文符号比较多的场景下（例如 HTML/XML），编码较短 由于是变长，字符空间足够大，未来 Unicode 新标准收录更多字符，UTF-8 也能妥妥的兼容，因此不会再出现 UTF-16 那样的尴尬 容错性高，局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，因为 UTF-8 的字符边界很容易检测出来，这是一个巨大的优点（正是为了实现这一点，咱们中日韩人民不得不忍受 3 字节 1 个字符的苦日子） 缺点 文化上的不平衡——对于欧美地区一些以英语为母语的国家 UTF-8 简直是太棒了，因为它和 ASCII 一样，一个字符只占一个字节，没有任何额外的存储负担；但是对于中日韩等国家来说，UTF-8 实在是太冗余，一个字符竟然要占用 3 个字节，存储和传输的效率不但没有提升，反而下降了。所以欧美人民常常毫不犹豫的采用 UTF-8，而我们却老是要犹豫一会儿。 变长字节表示带来的效率问题——大家对 UTF-8 疑虑重重的一个问题就是在于其因为是变长字节表示，因此无论是计算字符数，还是执行索引操作效率都不高。为了解决这个问题，常常会考虑把 UTF-8 先转换为 UTF-16 或者 UTF-32 后再操作，操作完毕后再转换回去。而这显然是一种性能负担。 UTF-16优点 最流行的操作系统和 UI framework 的内部字符串表达都是 UTF-16 曾经在计算字符串长度、执行索引操作时速度很快。（但随着Unicode收录的字符超过了65536个，UTF-16也从定长变成了变长，就没那么快了） 缺点 UTF-16 能表示的字符数有 65536，看起来很多，但是实际上目前 Unicode 5.0 收录的字符已经达到 99024 个字符，早已超过 UTF-16 的存储范围；这直接导致 UTF-16 地位颇为尴尬——如果谁还在想着只要使用 UTF-16 的定常特性就可以高枕无忧的话，恐怕要失望了。 UTF-16 存在大小端字节序问题，这个问题在进行信息交换时特别突出——如果字节序未协商好，将导致乱码；如果协商好，但是双方一个采用大端一个采用小端，则必然有一方要进行大小端转换，性能损失不可避免（大小端问题其实不像看起来那么简单，有时会涉及硬件、操作系统、上层软件多个层次，可能会进行多次转换）。 另外，容错性低有时候也是一大问题——局部的字节错误，特别是丢失或增加可能导致所有后续字符全部错乱，错乱后要想恢复，可能很简单，也可能会非常困难。（这一点在日常生活里大家感觉似乎无关紧要，但是在很多特殊环境下却是巨大的缺陷）。 UTF-32优点 定长编码，UTF-32 表示任何字符都用 4 字节，读到内存中是个均匀的整形数组，于是我们可以很方便地随机访问任何一个字符 由于是定长，索引比变长的要快，你想访问一个字符串中的第 n 个字符，UTF-32 直接偏移 n 个整型距离即可，UTF-8 得从第一个字节一个字一个字地往后蹦，非常蛋疼。 缺点 太占内存啦 那么在实际使用中，该如何选择上述编码方式呢？ UTF-8，用于存储及传输 UTF-32，用于程序内存中 因为UTF-8灵活，在互联网通信中被编码影响小，兼容性强。UTF-32定长，在内存中程序处理优秀，查询快。]]></content>
      <categories>
        <category>Java</category>
        <category>字符编码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源文件名和类名的关系]]></title>
    <url>%2F2020%2F03%2F21%2F%E6%BA%90%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E7%B1%BB%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一个源文件中可以定义多个类，每个class定义会生成一个对应的字节码文件 123456789// Test.java源文件class A&#123;&#125;class B&#123; &#125;class C&#123;&#125; 上述java源文件编译后，会生成A.class、B.class和C.class三个字节码文件 如果源文件中有被public关键字修饰所修饰的类，那么源文件名必须与public所修饰的类同名 源文件中定义的类，最多只能有一个类被public关键字修饰（可以这么理解，如果有两个public类，它们都需要和源文件同名，这显然是不可能的） 如果源文件中没有public修饰的类，源文件可任意命名 每一个class当中都可以编写main方法，都可以设定程序的入口。可以在所有类里都写上 main 方法，给程序提供N多个入口，但是最后你运行程序的时候也只能从其中的一个入口进去（程序员在做单元测试时，会往自己做的很多类里面添加 main 方法，因为他要为自己做的东西添加运行入口，从而能方便测试） 123456789101112131415161718// A.java源文件public class A&#123; public static void main(String[] args)&#123; System.out.println("A's main method!"); &#125;&#125;class B&#123; public static void main(String[] args)&#123; System.out.println("B's main method!"); &#125;&#125;class C&#123; public static void main(String[] args)&#123; System.out.println("C's main method!"); &#125;&#125; 上述代码编译后会生成三个字节码文件：A.class、B.class和C.class。在DOS界面执行 java A会输出 “A‘s main method！”。同样的，执行 java B会输出 “B’s main method!”。C类似 当在命令窗口执行 java x的时候，要求定义x这个类当中必须有main方法。没有main方法会出现运行阶段的错误]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境变量那些事儿]]></title>
    <url>%2F2020%2F03%2F20%2FJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[虽然现在Java版本已经更新到Java14，且从Java11开始，不提供JRE的下载，只提供JDK的下载。但Java1.8由于其稳定性，依然具有广泛的应用。（注意：Java1.8在安装时会有两套JRE，一套在Java目录下，一套在Java目录下的JDK目录中）。 JDK自带的jre称为专用jre，后面独立安装的jre称为公共jre如果安装了JDK的话，其实是没必要再安装公共jre的，公共jre的作用是自动向系统和浏览器注册Java运行环境，以及提供了一些Java更新服务，所以没必要再去单独安装这个公共jre，只要正常安装JDK，指定好环境变量后，就OK了 从JDK11开始，无论是开发机器还是部署机器都需要下载JDK，且配置环境变量。因为不再提供JRE的下载了。 JDK7与JDK8安装的区别 JDK7在安装公共jre时会在System32中放置ava.exe，javaw.exe，javaws.exe。而JDK8不会在system32里放置java.exe，javaw.exe，javaws.exe，所以在只安装了JDK8未做任何设置的情况下，应该是无法执行java.exe命令的，那么JDK8就只安装了jdk1.8的文件夹和jre1.8么，也不是，在 C:\Program Files (x86)\Common Files\Oracle\Java\javapath路径下可以找到JDK8版本的java.exe，javaw.exe，javaws.exe，只不过由于这个目录并不在PATH变量下（好气呀，我的path里面有这个哎，所以我默认可以用java.exe嘿嘿，但是javac还是不行的），所以命令行中java命令无法找到这里，当你把这个目录添加到PATH之后，就可以找到了。 下面先聊一聊Java环境变量配置（主要是Path和ClassPath）： 高级系统设置-&gt; 环境变量-&gt; 系统变量 新建JAVA_HOME变量，变量值为下载的JDK路径 新建CLASSPATH变量（非必须），变量值如下（最前面的点不能省略，它代表当前路径） 1.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 在Path变量中，加入如下路径 1%JAVA_HOME%\bin 至此，环境变量配置完毕。可以在DOS界面使用javac和java了 下面介绍一下CLASSPATH这个环境变量 默认情况下，ClassLoader从当前路径下加载.class字节码文件。当然，也可以让ClassLoader去某个指定路径下加载字节码文件，这时需要配置环境变量CLASSPATH。 CLASSPATH环境变量属于java语言中的环境变量，不属于windows操作系统（Path环境变量属于操作系统）。CLASSPATH是给ClassLoader类加载器指路的。 当CLASSPATH环境变量没有配置的话，类加载器默认从当前路径下找字节码文件；当CLASSPATH环境变量配置为某个指定路径之后，类加载器只去指定的路径中加载字节码。 综上，CLASSPATH环境变量不是必须要配置的。 安装JDK时，有两套JRE的相关问题（JDK1.8版本及以前才存在这个问题） 记得在环境变量path中设置%JAVA_HOME%/bin路径M么？这应该是学习Java的第一步吧，不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。 可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin（公共JRE）目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ 但是，明明没有设置 jre/bin目录到环境变量中啊？ 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？ 所以安装公共jre的时候安装程序自动帮你把公共jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%\system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java.exe，不过除非有必要，我不建议大家这么做。 两套jre，Java程序具体执行时最后使用哪个jre？这个机制是什么？ 这个问题只存在于Java1.8版本及以前，从Java11开始后就不存在了，因为没有JRE可下载，只有JDK。 系统存在多套jre时，那么由谁来决定使用哪一套jre呢？这个重担就落在java.exe的身上。 比如如果在命令行中输入java xxx的时候，java.exe的任务就是在我们电脑系统中众多的jre中找到合适的jre来执行xxx。java.exe依据以下顺序来寻找jre： 当前目录下是否是JRE目录下的bin，适用于JRE\bin目录下的java.exe 父目录下是否存在JRE目录，适用于JDK\bin目录下的java.exe（D:\Java\jdk1.8.0_40\bin中的java.exe执行时只会使用D:\Java\jdk1.8.0_40\jre的jre，就是出于这个原因） 查询注册表HKEY_LOCAL_MACHINE\Software\JavaSoft\JavaRuntime Environment\，适用于system32以及C:\ProgramData\Oracle\Java\javapath下的java.exe 所以java.exe的执行结果与我们电脑里哪一个java.exe（搜索一下就会发现我们电脑里面也不止一个java.exe）被执行有很大的关系。 另外，java.exe在找到合适的jre以后，还有一个验证版本的程序，也就是java.exe与jre的版本一致才可以执行。如果出现版本不一致的问题，一定要记得两件事情： 哪一个java.exe被执行； java.exe找到哪一套jre。 只要这两件事情确定了，我们就抓住了问题的来龙去脉，理解起来也就轻而易举了。 有一篇博客也介绍了类似问题：Windows的JDK与JRE，java.exe在哪里是谁干了什么，用来参考 当存在多个java.exe时，如何知道哪个java.exe被执行？ 1where java 在cmd中输入where java，如果系统环境变量path中存在，就会输出相应的路径。 在windows上实现多个JDK的共存解决办法 安装两个版本的JDK，比如JDK6和JDK7 环境变量如下设置： JAVA7_HOME = JDK7的安装路径 JAVA6_HOME = JDK6的安装路径 JAVA_HOME = %JAVA6_HOME%（注意:如果你想切换jdk，就在此处设置切换即可） 添加%JAVA_HOME%\bin到环境变量path中 可能存在的问题：如果先安装JDK1.6，再安装JDK1.7。未修改JAVA_HOME（仍然为JAVA6_HOME），但调用java -version指令显示1.7的版本。其实原因很简单，上面已经说过了。在安装JDK1.7时（本机先安装jdk1.6再安装的jdk1.7），自动将java.exe、javaw.exe、javaws.exe三个可执行文件复制到了C:\Windows\System32目录，这个目录在WINDOWS环境变量中的优先级高于JAVA_HOME设置的环境变量优先级。 解决方案：删除C:\Windows\System32目录下的java.exe即可 解决后，使用的即为各JDK版本的专用JRE，而非共用JRE。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK和JRE间的那些事儿]]></title>
    <url>%2F2020%2F03%2F20%2FJDK%E5%92%8CJRE%E9%97%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[首先了解下这两者的概念 JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。 JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe等。 显然，这两者的关系是：包含关系。JDK 包含了 JRE。 在JDK1.8（包含以前）的版本中，安装成功后，会存在两个JRE文件夹：…/Java/jre和…/Java/jdk/jre 这两个JRE有什么联系么？ 答案是：没有联系。甚至准确的来说，它俩是一样的，无论是用哪一个都是可以的。只是很多人习惯将会单独安装另一个 jre，虽然单独安装的 jre 也并没有被使用，原因可能就是刚开始大家都不清楚 jdk 和 jre 之间的关系，所以就默认的都安装上了。 在 jdk 的 bin 目录下，基本上都是一些可执行文件，并且它们还不大。其实这些可执行文件只是外层的一层封装而已，这样的目的是避免输入的命令过长。例如 javac.exe 内部调用的其实是 JDK 中 lib 目录中的 tools.jar 中 com.sun.tools.javac.Main 类，也就是说这些工具只是入口而已。而实际上它们本身又都是由 Java 编写的，所以在 jdk 目录下的 jre 既提供了这些工具的运行时环境，也提供了我们编写完成的 Java 程序的运行时环境。 所以，很明显，jdk 是我们的开发工具包，它集成了 jre ，因此我们在安装 jdk 的时候可以选择不再安装 jre 而直接使用 jdk 中的 jre 运行我们的 Java 程序。（但是大部分人都默认将两个都装上了）。但是如果你的电脑不是用来开发 Java 程序的，而仅仅是用来部署和运行 Java 程序的，那么完全可以不用安装 jdk，只需要安装 jre 即可。 从Java 11后Oracle不再单独发布JRE和Server JRE了，并统一JDK名称为：Oracle JDK 。也就是说从Java11开始不再区分JDK和JRE，下载的jdk本身就是jre，默认没有jre目录。11之后不再区分具体的jre和jdk，你非要自己做的话，你用jlink把所有java开头的jmod都打进去就是你要的jre了。 为什么JDK11后不带JRE? jdk本身就是jre的超集，包含了jre，同时也提供了一些开发者工具 jre是jvm的超集，包含了jvm同时也提供了rt.jar，也就是runtime.jar 现在这些都没有了，就只提供一个jdk下载，不再区分jvm，jre和jdk 你下载下来的jdk本身就是一个大的jre（java runtime） 你要的功能jdk里面都有，只是jdk顺便也提供了更多的东西 Java开始没有JRE下载，只有JDK下载。但JDK是包含JRE的，所以Java程序仍旧可以正常运行。 Jlink可以从JDK中分离JRE，创建一个更小的JRE。步骤如下： 管理员模式打开Cmd，运行到jdk目录 输入下面指令 1bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre 即可在JDK目录下生成一个JRE文件夹 Java1.8及以前，服务器上是否只安装 JRE 就可以了？（从Java11开始不存在这个问题，因为没有单独的JRE下载，全都要下载JDK） 理论上是可以的，但是有前提条件。 服务器上只安装 JRE 的前提： 发布到服务器上时所有文件都是编译好的文件，包括 JSP 文件 后期不在服务器上直接修改（修改后需要编译，必须要有JDK） 如果部署的项目都是编译后重新部署，不在服务器上直接修改的话是可以只安装 JRE 的。 综合考虑，为避免以后这样那样的麻烦事发生，服务器上还是安装 JDK 吧！毕竟项目后期维护才是主要的事情。 在服务器上安装 JDK 的好处： 可以编译 java 文件，方便后期维护 保证 JSP 文件修改后稳定运行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的加载与执行]]></title>
    <url>%2F2020%2F03%2F18%2FJava%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Java程序的运行包含两个非常重要的阶段 编译阶段 运行阶段 编译阶段编译阶段主要的任务是检查Java源程序是否符合Java语法，符合Java语法则能够生成正常的字节码文件（xxx.class）;不符合Java语法规则则无法生成字节码文件。 字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。 编译阶段的过程： 程序员在硬盘的某个位置新建一个.java扩展名的文件，该文件被称为Java源文件，源文件当中编写的是Java源代码，必须符合Java语法规范 Java程序员使用 JDK当中自带的javac.exe命令进行Java程序的编译 javac怎么用？在哪用？ 在DOS命令窗口使用 javac使用规则：javac 源文件.java javac是一个java编译器工具/命令 一个java源文件可以编译生成多个.class文件（由文件中所定义的类的数量决定，class文件的名字即为类名） 字节码文件/class文件是最终要执行的文件，所以class文件生成之后，java源文件删除并不会影响java程序的运行 运行阶段JDK安装之后，除了自带一个javac.exe之外，还有另一个工具，叫做java.exe，它主要负责运行阶段 java.exe在哪里？怎么用？ 在DOS窗口使用 使用方法：java 类名 例如：硬盘上有一个A.class，就是java A 运行阶段的过程： 打开DOS窗口，输入java A java.exe命令会启动JVM，JVM会启动类加载器ClassLoader ClassLoader会去硬盘搜索A.class文件，找到文件后将该字节码文件装载到JVM中 JVM中的解释器将A.class字节码文件解释称二进制数据文件 然后操作系统执行二进制文件和底层硬件平台进行交互]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件反汇编]]></title>
    <url>%2F2020%2F03%2F16%2Fclass%E6%96%87%E4%BB%B6%E5%8F%8D%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[jdk自带的很多命令都很有用，今天就来简单介绍下jdk的javap命令，javap是jdk自带的反汇编器，使用此命令， 可以将 Java文件编译后的class文件反汇编进而看到 Java编译器给我们生成的字节码，以便我们能更好的分析代码 的执行过程和运行流程。 使用方法： 先写好一个demo.java文件 在cmd中进入到该java文件的目录下，然后使用javac demo.java将其编译，这时你会在当前目录看到一个demo.class文件 之后再cmd中输入javap -c demo命令，将其字节码文件进行反汇编。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从JVM角度看Java多态]]></title>
    <url>%2F2020%2F03%2F15%2F%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E7%9C%8BJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态举例如下： 12345678910111213141516171819202122232425262728293031public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); // 调用子类eat() //f.play(); 编译错误 System.out.println("年龄："+f.age ); // 父类age &#125;&#125; 下面从JVM的角度解释上面这种现象，从下面这句代码切入 1Father f = new Child(); 这句代码首先会执行new Child()，在堆中分配一个对象。当然在创建Child类的实例前，先要通过JVM的类加载器将Child类对应的class文件加载到JVM中，然后JVM根据class文件中的字节流产生一个表示class文件的类型信息结构体。 这个表示class文件的类型信息结构体大概由以下几部分构成： 常量池（较为复杂，存放该类型所用到的常量的有序集合，包括直接常量（字符串、整数、浮点数）和对其他类的字段、方法的符号引用） 类变量（静态变量，只包含本类所定义的，不包含继承自父类的，下面字段信息、方法信息类似） 字段信息 方法信息 类型信息 指向类加载器的引用 指向class实例的引用 方法表 父类信息引用 之后，JVM会根据上面这个结构体生成一个叫做虚方法表(vtable)的东西。这个方法表是实现Java多态的一个关键。方法表中包含的是实例方法（就是相对于静态方法而言的，用对象访问的那些方法，即不包含static、final和private修饰的方法）的直接引用，也就是说通过这个方法表就能够访问到该类的实例方法。 而且，这些实例方法不仅包括本类的方法，还包括其父类的实例方法，以及父类的父类的实例方法（就是一直到Object）。 方法表中的这些直接引用会指向到JVM中表示类型信息的那个结构体（就是上面那个结构体）的相应的方法信息（就是上面结构体中第4块的某个位置），当然这只是本类的方法，方法表中还有父类的方法，相应地指向父类类型信息结构体的具体位置。如图所示 上面提到过，方法表中不仅包括本类的方法，还包括父类的方法，方法表值这样产生的，以Child类的方法表为例： 首先方法表中，会产生指向继承自Object类的方法的引用，这些包括指向toString的和指向equals的，当然Object中还包括很多方法，这里就不写了 然后方法表中产生指向继承自Parent类的方法的引用，这包括eat， 最后产生指向本类的方法的引用。 这里需要注意的一点是，当Child类的方法表产生指向Parent类中的方法的引用时，会有一个指向eat方法的引用，最后产生指向本类的方法的引用时，也有一个指向eat的引用，这时候，新的数据会覆盖原有的数据，也就是说原来指向Parent.eat的那个引用会被替换成指向Child.eat的引用（占据原来表中的位置）。所以我们看到在Child类的方法表中指向的是Child.eat而Parent类的方法表中指向的是Parent.eat。子类的方法表中就没有指向Parent.eat的引用了。(重写的底层实现) 而且还要注意一个特点就是，Parent和Child的方法表中，指向eat的引用在表中的偏移量是一样的，都是第三个位置。（这是因为子类eat方法覆盖掉了父类eat方法，占据了原来父类eat方法的引用在表中的位置） 这里再多说一句，表示类型信息的结构体（非方法表）中的方法信息，只包含本类特有的，或者是重写的方法信息，没有父类的方法信息。 这里介绍一下方法表的两个特点： 方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。 方法表满足两个性质： 子类方法表中包含父类方法表中的所有方法 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。（即如果子类方法表和父类方法表中同时含有一个函数，那么该函数在各自方法表中的索引值相同） 了解了方法区的结构后，再来看堆中对象的结构 从图中可以看出，堆中的实例对象不仅包含本类实例变量，也包含父类实例变量，分配不同的内存，不存在冲突。本类实例变量分配在本类实例变量区，父类实例变量分配在父类实例变量区。子类实例变量区和父类实例变量区不冲突不重合，都存在于该实例对象堆内存空间中。 由于类的实例变量属于类对象实例，所以分配在堆内存中。静态变量属于类，不属于类实例，所以分配在方法区中。 接下来是栈区，产生Father类型的引用，这个引用指向堆区中的Child类的实例。 这里需要解释一下Father f的含义，我们知道f表示一个引用，这个引用指向堆中的Child类的实例，说白了就是一个地址(其实Java中没有地址，因为地址不安全)，这个地址指向堆中的Child的类的实例 下面探讨一下如何调用方法及变量？1. 调用static方法、final方法和private方法1234567891011class Father&#123; public static void f1()&#123; System.out.println("Father— f1()"); &#125; &#125;public class StaticCall&#123; public static void main()&#123; Father.f1(); //调用静态方法 &#125;&#125; 上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令： 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: Father; 紧接着JVM会加载、链接和初始化Father类; 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫常量池解析 ，以后再次调用Father.f1()时，将直接找到f1方法的字节码; 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。 通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做静态绑定机制 。 2. 调用实例方法12345678910111213141516171819202122class Father&#123; public void f1()&#123; System.out.println("father-f1()"); &#125; public void f1(int i)&#123; System.out.println("father-f1() para-int "+i); &#125; &#125; //被调用的子类class Son extends Father&#123; public void f1()&#123; //覆盖父类的方法 System.out.println("Son-f1()"); &#125; &#125; //调用方法public class AutoCall&#123; public static void main(String[] args)&#123; Father father=new Son(); father.f1(); &#125;&#125; 对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令： 12345670 new Son [13] //在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈3 dup4 invokespecial #7 [15] 7 astore_1 //弹出操作数栈的Son对象引用压入局部变量1中8 aload_1 //取出局部变量1中的对象引用压入操作数栈9 invokevirtual #15 //调用f1()方法12 return 其中invokevirtual指令的详细调用过程是这样的： invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名:Father。这是因为调用方法f1的类的对象father声明为Father类型。 在Father类型的虚方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项记录到AutoCall类的常量池中第15个常量表中(常量池解析 )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间 上述即为多态的实现机制，即动态绑定。 3. 调用变量1234567891011// Father 父类public class Father&#123; int age = 10;&#125;public class Son extends Father&#123; int age = 20;&#125;// Son 子类Father f = new Son();System.out.println(f.age); // 10 这里主要涉及到 Java里面一个字段隐藏的概念。父类和子类定义了一个同名的字段，不会报错。但对于同一个对象，用父类的引用去取值，会取到父类的字段；用子类的引用去取值会取到子类字段的值。在实际开发中，要尽量避免子类和父类使用相同的字段名，否则很容易引入一些不容易发现的bug。 总结 Java程序用于都分为编译阶段和运行阶段 实例变量：编译和运行都参考左边（静态绑定） 静态变量：编译和运行都参考左边（静态绑定） 静态方法、private方法和final方法：编译和运行都参考左边（静态绑定） 实例方法：编译参考左边，运行参考右边（动态绑定） 对上面的说法举个例子： 12345678910111213141516171819202122class animal&#123; public void eat()&#123; System.out.println("动物吃饭"); &#125;&#125;class dog extends animal&#123; public void eat()&#123; System.out.println("狗吃饭"); &#125; public void study()&#123; System.out.println("狗学习"); &#125;&#125;public class test&#123; public static void main(String[] args)&#123; animal a = new dog(); a.eat(); a.study(); &#125;&#125; 注意 java程序永远分为编译阶段和运行阶段 先分析编译阶段，再分析运行阶段，编译无法通过，根本是无法运行的 编译阶段编译器检查a这个引用的数据类型为animal，由于animal.class字节码当中有eat()方法，所以编译通过了。这个过程为静态绑定，编译阶段绑定。只有静态绑定成功之后才有后续的运行 在程序运行阶段，JVM堆内存当中真实创建的对象是dog对象，那么程序在运行阶段一定会调用dog对象的eat()方法，此时发生了动态绑定，运行阶段确定 无论是dog类有没有重写eat()方法，运行阶段一定调用的是dog对象的eat方法(因为继承了)，因为底层真实对象就是dog对象 父类型引用指向子类型对象这种机制导致程序在编译阶段绑定和运行阶段绑定两种不同的状态，这种机制称为多态语法机制 对于上面的a.eat() 编译时：由于a的类型为animal，所以编译时先去检查animal类的方法区中有没有eat()方法，如果没有则报错。这就是所谓的编译看左边 运行时：直接去dog类方法区中找到eat()方法；如果dog类中没有，再去父类中查找eat()方法。如果一直找到Object类都没有，则报错。这就是所谓的运行看右边 对于a.study() 编译时：由于a的类型时animal，先去animal类的方法区中查找study()方法，结果animal类方法区中没有study()方法，所以就在编译时期就报错 如果想执行study方法，该怎么办？—&gt; 向下转型 12dog d = (dog)a;d.study();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2020%2F03%2F13%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是OOP？ 面向对象编程：Object-Oriented Programming 对现实世界建立计算机模型的一种编程方法 面向过程和面向对象的区别？ 面向过程：主要关注点是实现的具体过程，因果关系 优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低 缺点：采用面向过程的方式很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间的耦合度非常高。只要其中一环出问题，整个系统受到影响。导致最终的软件扩展力低。另外，由于没有独立体的概念，所以无法达到组件复用 面向对象：主要关注对象（独立体）能完成那些功能 优点：耦合度低，扩展力强。更容易解决现实世界中更复杂的业务逻辑，组件复用性强 缺点：前期投入成本较高，需要进行独立体的抽取，存在大量的系统分析与设计 面向对象的三大特性：封装、继承、多态。 采用面向对象的方式开发一个软件，生命周期当中存在： 面向对象分析OOA 面向对象设计OOD 面向对象编程OOP 类和对象的概念​ 类在现实世界中是不存在，是一个模板，是一个概念，是人类大脑思考抽象的结果。类代表了一类事物。在现实世界中，对象A和对象B之间具有共同的特征，进行抽象总结出一个模板，这个模板被称为类 ​ 对象是现实世界实际存在的个体 在Java程序中通过类创建对象 类 ——&gt; (实例化) ——&gt; 对象（对象又被称为实例） 对象 ——&gt;（抽象）——&gt; 类 类描述的是对象的共同特征 一个类主要描述什么信息？ 状态+动作 状态信息：名字、身高、性别等 动作信息：吃、唱歌、学习等 状态 ——&gt; 一个类的属性 动作 ——&gt; 一个类的方法 类{ ​ 属性 // 描述对象的状态信息 ​ 方法 // 描述对象的动作信息 } 现实世界 计算机模型 Java代码 人 类/class class Person{} 小明 实例/ming Person ming = new Preson() 小红 实例/hong Person hong = new Person() 现实世界 计算机模型 Java代码 书 类/class class Book{} Java核心技术 实例/book1 Book book1 = new Book() Java编程思想 实例/book2 Book book2 = new Book() 类/实例（class/instance）class是对象模板 class定义了如何创建实例 class名字就是数据类型 instance是对象实例 instance是根据class创建的实例 可以创建多个instance 各个instance类型相同，但各自属性可能不同 定义class 语法结构： [修饰符列表] class 类名{ } 一个class可以包含多个field（字段），field用来描述一个class的特征 class实现了数据封装 12345678910public class Person&#123; public String name; public int age;&#125;public class Book&#123; public String name; public String author; public String isbn;&#125; 创建实例 new操作符可以创建一个实例，new运算符的作用是创建对象，在JVM堆内存当中开辟新的内存空间 定义一个引用类型变量来指向实例 通过变量来操作实例 通过变量.字段来访问实例字段 12345678public class Person&#123; public String name; public int age;&#125;Person ming = new Person();ming.name = "小明";ming.age = 12; 总结 class和instance是”模板”和”实例”的关系 class是数据类型，instace是数据 class定义了field，每个instance都会拥有各自的field 变量指向instance，并通过变量.字段来访问实例字段 指向instance的变量都是引用变量 数据封装 一个class可以包含多个field 直接将field用public暴露给外部可能破坏了封装 用private修饰field可以拒绝外部访问 当field被设置为private时，可定义public方法间接修改field 123456789101112public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125;&#125;Person ming = new Person();ming.name = "小明"; //编译错误ming.setName("小明"); //正确 方法 外部代码不可访问private字段 外部代码只能通过调用public方法间接设置和获取private字段 public方法封装了数据访问 方法体中不能再定义方法 通过方法访问实例字段更安全 通过变量.方法名()来调用实例方法 定义方法 修饰符列表 返回值类型 返回值类型可以是java中任意一种类型，包括基本数据类型和所有的引用数据类型 方法名称：合法的标识符即可 方法参数列表 形参是局部变量 形参中起决定作用的是形参的数据类型，形参的名字就是局部变量的名字 方法在调用的时候，实际给这个方法传递的真实数据被称为实参 形参列表和实参列表必须满足： 数量和类型对应相同 方法返回值通过return语句实现，如果没有返回值（void）可以省略return。只要带有return关键字的语句执行，return语句所在的方法结束。 当一个方法有返回值时，在调用该方法时可以选择接受也可以选择不接收返回值。但是大部分条件下都是选择接收 12345678910111213141516public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String getName()&#123; return this.name; &#125;&#125; 方法内部可以使用隐式变量this，this指向当前实例，this.field可以表示当前实例的字段 在不引起歧义的情况下，可省略this 123public String getName()&#123; return name; //this.name &#125; 局部变量名优先。当字段名和局部变量名重名时，编译器优先查找局部变量名 123public void setName(String name)&#123; this.name = name; &#125; 调用方法 实例变量.方法名(参数) 可以忽略方法返回值 123Person ming = new Person();ming.setName("小明"); // 没有返回值String s = ming.getName(); //返回值为String 类内部调用方法 1234567891011121314151617181920212223public class hello&#123; public static void main(String[] args)&#123; // 完整调用格式 hello.qq(); // 省略调用格式 qq(); // 编译正确 A.a(); // a(); 编译错误 // 注意同一个类中调用方法可以省略类名，不同的类中调用方法不能省略类名 &#125; public static void qq()&#123; System.out.ptintln("xixi"); &#125;&#125;class A&#123; public static void a()&#123; System.out.ptintln("haha"); &#125;&#125; 方法参数传递 方法参数用于接收传递给方法的变量值 方法参数可为基本类型参数或引用类型参数。可简单理解为基本类型是值传递，引用类型是址传递（但是无论是基本类西行还是引用类型，都是传递的是变量中保存的值，只不过有的是字面值，有的是Java对象在堆内存中的地址，所以才会有值传递和址传递的区别，但本质上都是一样的）。见方法调用时的参数传递问题 private方法 外部代码不可访问private方法 内部代码可以调用自己的private方法 构造方法前面可以看到，初始化实例需要三行代码 1234Person ming = new Person(); // 创建对象实例// 初始化对象实例ming.setName("小明");ming.setAge(12); 能否在创建对象实例时就把内部字段全部初始化为合适的值？如下所示 1Person ming = new Person("小明",12); 答案当然是肯定的！需要引入构造方法（又被称为构造函数/ 构造器，constructor）。构造方法用于创建对象 构造方法的作用 创建对象 创建对象的同时，初始化实例变量的内存空间 成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量 实例变量没有手动赋值的时候，系统默认赋值，那么这个系统默认赋值是在什么时候完成的？是在类加载的时候么？ 不是！因为类加载的时候只加载了代码片段，还没来得及创建对象，所以此时实例变量并没有初始化。 实际上，实例变量的内存空间是在构造方法执行过程中完成开辟、初始化的。系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值 构造方法语法结构 [修饰符列表] 构造方法名（形参列表）{ ​ 构造方法体； } 普通方法语法结构 [修饰符列表] 返回值类型 构造方法名（形参列表）{ ​ 方法体； } 构造方法可以在创建对象实例时初始化对象实例 构造方法名就是类名，必须保持一致 构造方法的参数没有限制 构造方法没有返回值(类型也没有void) ，只要写上返回值类型就是普通方法了（不写返回值类型不代表没有返回值） 必须用new操作符调用构造方法 调用方法：new 构造方法名(实参列表) 构造方法调用后有返回值么？ 每一个构造方法实际上执行结束后都有返回值，但是不需要写，构造方法结束的时候java程序自动返回值，返回的是对象在堆内存中的地址。并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写 12345678910public class Person&#123; private String name; private int age; // 构造方法 public Person(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125; 如果一个类没有定义构造方法，编译器会自动生成一个默认构造方法，这个构造方法被称为缺省构造器： 无参数 无执行语句 123456public class Person&#123; private String name; private int age; public Person()&#123; &#125;&#125; 如果自定义了构造方法，编译器就不再自动创建默认构造方法。建议开发中手动的为当前类提供无参数构造方法，因为无参数构造方法太常用了。所以构造方法支持重载机制，在一个类中编写多个构造方法，这多个构造方法显然已经构成方法重载机制 123456789101112public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; // 如果自己写的构造函数中没有对所有的实例变量赋值，那么那些没有被赋值的实例变量会被系统赋默认值 &#125;&#125;Person ming = new Person(); // 编译错误// 因为此时没有默认构造方法了 可定义多个构造方法，编译器通过构造方法的参数数量、位置和类型区分 1234567891011121314151617181920public class Person&#123; private String name; private int age; // 构造代码: new person("xiaoming",12); public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; // 构造代码: new person("xiaoming"); public Person(String name)&#123; this.name = name; this.age = 18; &#125; // 构造代码: new person(); public Person()&#123; &#125;&#125; 一个构造方法可以调法用其他构造方法，便于代码复用。调用其他构造方法的语法是this(…) 1234567891011121314151617public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public Person(String name)&#123; this(name,18); &#125; public Person()&#123; this("unnamed"); &#125;&#125; 方法重载什么时候考虑方法重载？同一个类中功能相似的时候，尽可能让方法名相同 定义方法重载（Overload）是指： 在同一个类中 多个方法的方法名相同 但各自参数不同 参数个数不同 12public static void m1()&#123;&#125; public static void m1(int a)&#123;&#125; 参数类型不同 12public static void m2(int a)&#123;&#125;public static void m2(double a)&#123;&#125; 参数位置不同 12public static void m3(int a,double b)&#123;&#125;public static void m3(double a,int b)&#123;&#125; 方法重载只和方法名+参数列表有关，与返回值类型无关，与修饰符列表无关 12public static int q()&#123;&#125;public static void q()&#123;&#125; // 编译报错，因为就是同一个方法，没有构成重载 方法重载的目的 相同功能的方法使用统一名字 便于调用 方法递归什么是递归方法自身调用自身 1234public static void doSome()&#123; System.out.println("begin"); doSome();&#125; 递归很耗费栈内存，递归算法可以不用的时候尽量别用。容易发生爆栈错误：java.lang.StackOverflowError。因此递归必须有结束条件，否则肯定会发生爆栈 继承关于继承： 面向对象三大特征（封装、继承和多态）之一 继承基本作用是代码复用。但是继承最重要的作用是，有了继承才有了以后方法的覆盖的多态机制 继承语法格式： [修饰符列表] class 类名 extends 父类名{ ​ 类体; } java语言当中的继承只支持单继承，一个类不能同时继承多个类，C++支持多继承 B类继承A类，其中 A类称为：父类、基类、超类、superclass B类称为：子类、派生类、subclass 虽然java语言当中只支持单继承，但是一个类也可以间接继承其他类。例如 C extends B、B extends A、A extends T C直接继承B，间接继承A、T java语言中假设一个类没有显示的继承任何类，该类默认继承javaSE库当中提供的java.lang.Object类。java语言当中任何一个类中都有Object类的特征 1234567891011public class Person /* extends Object */ &#123; private String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; private int score; public void setScore(int score) &#123;...&#125; public int getScore() &#123;...&#125;&#125; Student可以从Person继承 继承使用关键字extends Student获得了Person所有的功能 Student只需要编写新增的功能 继承树 Object是Java提供的所有类的根类，如果没有写extends，则默认继承自Object类。 Java只允许class继承自一个类 一个类有且仅有一个父类（Object除外） protected Person类定义的private字段无法被子类访问 用protected修饰的字段可以被子类访问 1234567891011public class Person /* extends Object */ &#123; protected String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; public String hello()&#123; return "hello"+this.name; // 编译通过 &#125;&#125; super继承关系中的构造方法 123456789101112public class Person&#123; public Person() &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student()&#123; super(); System.out.println("student"); &#125;&#125; super关键字表示父类(超类) 子类的构造方法的第一行语句必须调用父类的构造方法，调用方式为super() 没有super()时编译器会自动生成super() 如果父类没有默认构造方法，子类就必须显式调用super() 12345678910111213public class Person&#123; public Person(String name) &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student(String name)&#123; //super(); // 这种构造会报错 super(name); //这样才正确 System.out.println("student"); &#125;&#125; 向上转型（upcasting）子类型 —&gt; 父类型，又称为自动类型转换 语法规则：&lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;();即父类引用指向子类对象 1Person p = new Student(); 此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，不是父类的方法。 此时通过父类引用变量无法调用子类特有的方法 向上转型虽然使代码变得简洁，体现了JAVA的抽象编程思想，但是也出现了上面提到的子类无法调用其独有的方法，这要怎么解决呢？所以就有了与之对应的向下转型，弥补了向上转型所带来的缺陷。 向下转型（downcasting）父类型 —&gt; 子类型，又称为强制类型转换，需要加强制类型转换符 什么时候要用向下转型? 当调用的方法或属性是子类型中特有的，在父类型中不存在，必须进行向下转型 向下转型把引用的类型转换成它的某一个子类型（注意：向下转型不一定将引用转换为堆中对象的类型，也可以转换为该堆中对象类型的直接父类、间接父类或者其对应的接口，但是不能是别的类型，因为要存在继承关系（一定要记住！！）。且转换后的引用类型必须是转换前的引用类型的子类型，即存在继承关系） 12Person p = new Student();Student s = (Student)p; // 向下转型 向下转型很可能报错：java.lang.ClassCastException 举例 123//animal是父类，cat和bird继承与animal类animal a = new bird();cat c = (cat)a; 上面的程序编译是没有问题的，因为编译器检查到a的类型是animal，animal和cat存在继承关系，并且animal是父类，cat是子类，父类转换成子类叫做向下转型，语法正确 程序虽然编译通过了，但是程序运行阶段会出现异常，因为JVM堆内存中真实存在的对象是bird类型，因为两种类型之间不存在任何继承关系，cat类型引用不能指向bird类型对象，此时出现了著名异常 java.lang.ClassCastException 类型转换异常，这种异常总是在向下转型的时候会发生 如何避免类型转换异常？ 以上异常只有在向下转型会发生，也就是说向下转型存在安全隐患（编译通过，运行出错）。向上转型只要编译通过，运行一定不会出错 使用instance of运算符可避免出现以上异常 语法格式 引用 instance of 数据类型名（类名） 例：obj instance of class 执行结果是boolean类型，true或false 其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类的对象，或者是其接口的实现类对象，结果result 都返回 true，否则返回false 所以在向下转型前，先判断一下引用指向的对象是否是你要转换的类型。例如 12345if(a instance of cat)&#123; cat c = (cat)a;&#125;else if(a instance of bird)&#123; bird b = (bird)a;&#125; java规范中要求：在进行向下转型前，建议使用instance of进行判断，避免出现java.lang.ClassCastException异常 注意无论是向上转型还是向下转型，两个类之间必须有继承关系，否则编译就将报错。 多态多态的优点提高了代码的扩展性，前期定义的代码可以使用后期的内容 多态的弊端前期定义的内容不能使用（调用）后期子类的特有方法（就是多态调用的只能是父类）。但如果是继承子类覆盖了父类方法，多态调用的仍是子类的方法！ 多态的类型分为以下两种： 编译时多态：指的是 方法重载。编译时多态是在编译时确定调用处选择那个重载方法，所以也叫 静态多态，算不上真正的多态。所以，一般说的多态都是运行时的多态。 运行时多态：由于方法重写，所以想要确定引用变量所调用的方法的入口，必须根据运行时的引用变量所指向的实例对象来确定。从而使得同一个引用变量调用同一个方法，但不同的实例对象表现出不同的行为。 多态的前提条件 子类继承父类 子类覆盖父类的方法 父类引用指向子类对象 多态性的实现： 依靠动态绑定 绑定： 将一个方法调用与方法主体关联起来。 前期绑定： 在程序执行前绑定，由编译器和链接程序完成，C语言的函数调用便是前期绑定。 动态绑定： 也称 后期绑定。在运行时，根据具体的对象类型进行方法调用绑定。除了static方法、final方法（private方法也是final方法）和构造方法，其他方法都是动态绑定； 方法重载、重写与隐藏重载（Overload）方法重载就是在同一个类中，多个方法名称相同但是参数类型或者参数个数不同或者参数顺序不同的方法，与返回值类型和修饰符无关 重写（Override）又被称为方法覆盖 什么时候使用方法重写？ 当父类中的方法已经无法满足子类的业务需求，子类有必要将父类中继承过来的方法进行重新编写，这个重新编写的过程称为方法重写/方法覆盖 子类继承父类时，子类的方法名称、参数类型、参数个数与父类完全相同，则认为子类重写了父类的方法。 方法重写规则： 方法重写发生在具有继承关系的父子类之间 参数列表和原方法完全相同 方法名相同 返回值类型和原方法相同或者为父类返回值类型的子类型 不能比原方法限制更严格的访问级别(举例：父类方法为public，那么子类不能为protected、private) 不能抛出新的异常或比原方法更广泛的异常（父类抛出IOException，重写方法不能抛出Exception只能抛出IOException或者IOException子类异常）。如果父类方法没有抛出异常，那么子类方法也不能抛出任何异常 注意 父类方法被定义为final时，可以被继承，但不能被重写，也不能被隐藏。final方法是防止子类覆写修改，子类继承直接使用是可以的 父类方法被定义为static时，不能被重写，但是可以声明一个相同的方法（参考隐藏） 构造方法不能被继承，所以不能重写，也不能隐藏 private方法虽然可以被继承，但是无法访问，所以如果定义一个一模一样的private方法，它们其实是两个相互独立的方法，而不是重写，也不是隐藏。（这里压根就没有重写或隐藏的概念，因为在子类中压根就对父类的private方法不可见，虽然可以继承） 覆盖只针对部分实例方法（除构造方法、final方法和private方法），不针对属性 方法重写的条件 重写的方法是子类从父类继承下来的实例方法（就是相对于静态方法而言的，用对象访问的那些方法），不能是静态方法 子类重写后的方法的 返回类型 必须是 原父类方法的返回类型的可替换类型 子类重写后的方法的访问权限 不能比 原父类方法的访问权限低； 子类重写后的方不能比父类方法抛出更多的异常； 当重写泛型方法时，先进行类型擦除。再按照上面的4个小点，重写类型擦除后的方法; 可替换类型补充： 对于返回类型是基本类型、void，重写方法的返回类型必须是一样； 对于返回类型是引用类型，返回类型可替换成该类型的 子类型; 12345678910111213141516171819class ParentClass&#123;//父类 public int count() &#123;// return 0; &#125; Object method() &#123; return "aa"; &#125;&#125;class ChildClass extends ParentClass&#123;//子类 public int count() &#123;//重写count()方法，由于返回类型是基本类型，不能变，必须是一致 return 0; &#125; public String method() &#123;//重写method()：访问权限增大，返回类型是Object的子类String return "aa"; &#125;&#125; 隐藏隐藏是针对于父类的成员变量和静态方法而言的。子类中声明了和父类相同的变量名或静态方法(方法名相同、参数列表相同、返回类型相同)则实现了对父类成员变量和静态方法的隐藏。从父类继承下来的成员中，除了部分方法是可以重写外，其余成员都是隐藏，如变量、内部类、静态方法等。 注意：final方法既不能被重写，也不能被隐藏；private方法没有重写和隐藏的概念 JAVA中方法和变量在继承时的覆盖和隐藏规则 父类的实例变量和静态变量能被子类的同名变量隐藏 父类的静态方法被子类的同名静态方法隐藏 父类的实例方法被子类的同名实例方法覆盖 换言之，多态是基于重写实现的，针对实例方法。变量、static方法、final方法和private方法不能重写。其中final方法和private方法也不能隐藏。 多态举例123456789101112131415161718192021222324252627282930313233343536public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); //f.play(); 编译错误 System.out.println("年龄："+f.age ); &#125;&#125; 结论：当满足Java多态的三个条件时，可以发现f.eat()调用的实际上是子类的eat，但f.age调用的还是父类的age，而f.play()则不会通过编译。(多态实现机制可看另一篇文章：从JVM角度看Java多态)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命令行参数]]></title>
    <url>%2F2020%2F03%2F12%2FJava%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命令行参数定义刚学习Java时，我们都会接触到下面这个简单的程序，我们可以main函数中定义了一个字符串数组参数，这就称为命令行参数，但是我们运行程序时从来没有给这个参数传值，那么我们怎么给这个参数传值呢？ 12345public class hello&#123; public static void main(String[] args)&#123; System.out.println("hello world"); &#125;&#125; 这个args数组的长度为0。这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为String[] args数组 如何传入命令行参数？可以在Eclipse中想main函数传递命令行参数，也可以在dos窗口运行java程序时传入命令行参数。下面分别介绍 在Eclipse中想main函数传递命令行参数 新建Java程序，输入命令行参数 123456public class helloworld&#123; public static void main(String[] args)&#123; for(String arg:args) System.out.println(arg); &#125;&#125; 从窗口中直接设置传入的值，选择”运行”-&gt;”调试配置”。如图所示 选择java应用程序-&gt;自变量，填入命令行参数，并点击运行 运行结果 在dos窗口运行Java程序时传入命令行参数 在cmd中编译上述helloworld.java文件 编译结束后会产生.class字节码文件 在命令行中运行helloworld.class文件，并传入命令行参数，以下是运行结果 注意：如果命令行参数含有空格，要加双引号]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列的属性]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[回顾一下建表语句： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 表中的每个列都可以有一些属性，至于这些属性是什么以及怎么在创建表的时候把它们定义出来就是本章接下来的内容哈。 默认值我们在书写INSERT语句插入记录的时候可以只指定部分的列，那些没有被显式指定的列的值将被设置为NULL，换一种说法就是列的默认值为NULL，NULL的含义是这个列的值还没有被设置。如果我们不想让默认值为NULL，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个DEFAULT属性，就像这样： 1列名 列的类型 DEFAULT 默认值 比如我们把first_table的second_column列的默认值指定为’abc’，创建一下这个表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) DEFAULT &apos;abc&apos; -&gt; );Query OK, 0 rows affected (0.02 sec) 如果我们不设置默认值，其实就相当于指定的默认值为NULL，比如first_table表并没有设置first_column列的默认值，那它的默认值就是NULL，也就是说上边的表定义语句和下边这个是等价的： 1234CREATE TABLE first_table ( first_column INT DEFAULT NULL, second_column VARCHAR(100) DEFAULT &apos;abc&apos;); NOT NULL 属性有时候我们需要要求表中的某些列中必须有值，不能存放NULL，那么可以用这样的语法来定义这个列： 1列名 列的类型 NOT NULL 如果将first_column设置为NOT NULL属性，这样的话，我们就不能再往这个字段里插入NULL值了，比如这样： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(NULL, &apos;aaa&apos;);ERROR 1048 (23000): Column &apos;first_column&apos; cannot be null 看到报了个错，提示first_column列不能存储NUL。 另外，一旦对某个列定义了NOT NULL属性，那这个列的默认值就不为NULL了。上边first_colum并没有指定默认值，意味着我们在使用INSERT插入行时必须显式的指定这个列的值，而不能省略它，比如这样就会报错的： 12mysql&gt; INSERT INTO first_table(second_column) VALUES(&apos;aaa&apos;);ERROR 1364 (HY000): Field &apos;first_column&apos; doesn&apos;t have a default value 主键有时候在我们的表里可以通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为候选键。比如在学生信息表student_info中，只要我们知道某个学生的学号，就可以确定一个唯一的学生信息，也就是一条记录。当然，我们也可以通过身份证号来确定唯一的一条学生信息记录，所以学号和身份证号都可以作为学生信息表的候选键。在学生成绩表student_score中，我们可以通过学号和科目这两个列的组合来确定唯一的一条成绩记录，所以（学号、科目）这两个列的组合可以作为学生成绩表的候选键。 一个表可能有多个候选键，我们可以选择一个候选键作为表的主键。一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键： 如果主键只是单个列的话，可直接在该列后面声明PRIMARY KEY，比如可以把学生信息表student_info的学号列声明为主键： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM(&apos;男&apos;, &apos;女&apos;), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 也可把主键的声明单独提取出来，用这样的形式声明： 123456789101112PRIMARY KEY (列名1, 列名2, ...)// 示例如下CREATE TABLE student_info ( number INT, name VARCHAR(5), sex ENUM(&apos;男&apos;, &apos;女&apos;), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, PRIMARY KEY (number)); 值得注意的是，对于多个列的组合作为主键的情况，必须使用这种单独声明的形式，比如student_score表里的（学号,科目）的列组合作为主键，可以这么写： 123456CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject)); 在我们创建表的时候就声明了主键的话，MySQL会对我们插入的记录做校验，如果新插入记录的主键值已经在表中存在了，那就会报错。 另外，主键列默认是有NOT NULL属性，也就是必填的，如果填入NULL值会报错。所以大家在插入数据的时候至少别忘了给主键列赋值哈～ 如果表已经建好了，如何添加主键？ 1mysql&gt; ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;); 主键有什么作用？ 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键 主键既不能为NULL，也不能重复 一张表的主键约束只能有一个 主键的作用： 主键值是这行记录在这张表中的唯一标识，就像人的身份证号一样 主键的分类： 根据主键字段的字段数量分 单一主键：推荐使用 复合主键（多个字段联合起来添加一个主键约束），不建议使用，因为违背三范式 根据主键性质分 自然主键：推荐使用 业务主键：主键值和系统业务挂钩，例如拿着银行卡的卡号做主键，不推荐使用。最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变，主键值可能也需要随着发生变化，但有的时候没有办法变化因为变化可能会导致重复主键值重复 UNIQUE属性对于不是主键的其他候选键，如果也想让MySQL在我们向表中插入新记录的时候帮助我们校验一下某个列或者列组合的值是否重复，那么我们可以把这个列或列组合添加一个UNIQUE属性，表明该列或者列组合的值是不允许重复的。与我们在建表语句中声明主键的方式类似，为某个列声明UNIQUE属性的方式也有两种： 如果我们想为单个列声明UNIQUE属性，可以直接在该列后填写UNIQUE或者UNIQUE KEY，比如在学生信息表student_info中，我们不允许两条学生基本信息记录中的身份证号是一样的，那我们可以为id_number列添加UNIQUE属性： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM(&apos;男&apos;, &apos;女&apos;), id_number CHAR(18) UNIQUE, department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 我们也可以把UNIQUE属性的声明单独提取出来，用下面的形式声明。值得注意的是，对于多个列的组合具有UNIQUE属性的情况，必须使用这种单独声明的形式。 123UNIQUE [约束名称] (列名1, 列名2, ...)// 或者UNIQUE KEY [约束名称] (列名1, 列名2, ...) 注意：多个列加unique约束，代表这个多列组合具有唯一性，不能重复 在字段后面加unique，被称为列级约束 在最后单独提出来加unique，被称为表级约束 not null只有列级约束，没有表级约束 其实每当我们为某个列添加了一个UNIQUE属性，就像是在孙悟空头上带了个紧箍咒一样，从此我们插入的记录的该列的值就不能重复，所以为某个列添加一个UNIQUE属性也可以认为是为这个表添加了一个约束，我们就称之为UNIQUE约束。每个约束都可以有一个名字，像主键也算是一个约束，它的名字就是默认的PRIMARY。不过一个表中可以为不同的列添加多个UNIQUE属性，也就是添加多个UNIQUE约束，每添加一个UNIQUE约束，我们就可以给它起个名，这也是上边的约束名称的含义。不过约束名称是被中括号[]扩起来的，意味着我们写不写都可以，如果不写的话MySQL自己会帮我们起名。其实就像是自己生了个孩子，如果自己不起名的话，人家公安局的警察叔叔也得给孩子起个名上户口。 如果表中为某个列或者列组合定义了UNIQUE属性的话，MySQL会对我们插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错！ 主键和UNIQUE约束的区别：主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是： 一张表中只能定义一个主键，却可以定义多个UNIQUE约束！ 规定：主键列不允许存放NULL，而声明了UNIQUE属性的列可以存放NULL，而且NULL可以重复地出现在多条记录中！(即多条记录的UNIQUE约束中的列都设置为NULL时，不会报已存在错误) 外键插入到学生成绩表student_score中的number(学号)列中的值必须能在学生基本信息表student_info中的number列中找到，否则如果一个学号只在成绩表里出现，而在基本信息表里找不到相应的记录的话，就相当于插入了不知道是哪个学生的成绩，这显然是荒谬的。为了防止这样荒谬的情况出现，MySQL给我们提供了外键约束机制。定义外键的语法是这样的： 1CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 其中的外键名称是可选的，一个名字而已，我们不自己命名的话，MySQL自己会帮助我们命令。 上面的语法是在创建表时建立外键的方法。如果表已经建立，怎么添加外键？ 1ALTER TABLE 表名 ADD CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 如果A表中的某个列或者某些列依赖与B表中的某个列或者某些列，那么就称A表为子表，B表为父表。子表和父表可以使用外键来关联起来，上边例子中student_score表的number列依赖于student_info的number列，所以student_info就是一个父表，student_score就是子表。在建立student_score时可定义外键如下： 1234567CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject), CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number)); 这样，在对student_score表插入数据的时候，MySQL都会为我们检查一下插入的学号是否能在student_info表中找到，如果找不到则会报错。 注意：父表中被子表依赖的列或者列组合必须建立索引，且必须是唯一性索引，如果该列或者列组合已经是主键或者有UNIQUE属性，那么它们也就被默认建立了唯一性索引。示例中student_score表依赖于stuent_info表的number列，而number列又是stuent_info的主键，所以在student_score表中创建外键是没问题的。 外键字段引用其他表的某个字段，被引用的字段必须是主键么？ 被引用的字段不一定是主键，但至少具有unique约束，所以主键或unique键都可以 父表和子表之间应该有先后顺序： 建表应该是先父表再子表；删表应该是先删子表，再删父表；删除数据的时候，先删子表中的数据，再删父表中的数据；插入数据时，先插入父表，再插入子表 建立外键后如何删除外键？ 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 如果在建立外键时未指定外键名称，MySQL会自动分配外键名。可通过show create table 表名; 来查看外键名称。 外键值可以为NULL！！即在子表中插入数据的时候，该外键值可以为NULL AUTO_INCREMENT属性AUTO_INCREMENT翻译成中文可以理解为自动增长，简称自增。如果一个表中的某个列的数据类型是整数类型或者浮点数类型，那么这个列可以设置AUTO_INCREMENT属性。当我们把某个列设置了AUTO_INCREMENT属性之后，如果我们在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为NULL或者0，那么新插入的记录在该列上的值就是当前该列的最大值加1后的值。我们可以用这样的语法来定义这个列： 1列名 列的类型 AUTO_INCREMENT; 定义列为AUTO_INCREMENT时需注意以下几点： 如果未指定值，默认从1开始递增 一个表中最多有一个具有AUTO_INCREMENT属性的列 具有AUTO_INCREMENT属性的列必须建立索引。主键和具有UNIQUE属性的列会自动建立索引 拥有AUTO_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值 一般拥有AUTO_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值 提示：Oracle中也提供了一种自增机制，叫做序列（sequence）对象 列的注释可以在建表结尾处添加COMMENT语句为表添加注释，也可以在每个列结尾添加COMMENT为列添加注释。具体语法如下： 12345CREATE TABLE first_table ( id int UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT &apos;自增主键&apos;, first_column INT COMMENT &apos;第一列&apos;, second_column VARCHAR(100) DEFAULT &apos;abc&apos; COMMENT &apos;第二列&apos;) COMMENT &apos;第一个表&apos;; ZEROFILL属性对于INT(M)类型，M为所谓的显示宽度。显示宽度是在是在查询语句显示的结果中，如果声明了 ZEROFILL 属性的整数列的实际值的位数小于显示宽度时，会在实际值的左侧补0，使补0的位数和实际值的位数相加正好等于显示宽度。 1234567891011121314151617mysql&gt; CREATE TABLE zerofill_table ( -&gt; i1 INT(5) UNSIGNED ZEROFILL, -&gt; i2 INT UNSIGNED -&gt; );Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO zerofill_table(i1, i2) VALUES(1, 1);Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM zerofill_table;+-------+------+| i1 | i2 |+-------+------+| 00001 | 1 |+-------+------+// 这里补充了4个0，凑齐五位显示宽度1 row in set (0.00 sec) 使用ZEROFILL属性注意以下几点： 在展示查询结果时，某列数据自动补0的条件有这几个： 该列必须是整数类型的 该列必须有UNSIGNED ZEROFILL的属性 该列的实际值的位数必须小于显示宽度 在创建表的时候，如果声明了ZEROFILL属性的列没有声明UNSIGNED属性，那MySQL会为该列自动生UNSIGNED属性。（MySQL现在只支持对无符号整数进行自动补0操作） 显示宽度并不会影响实际类型的实际存储空间。显示宽度仅仅是在展示查询结果时，如果整数的位数不够显示宽度的情况下起作用 只有列的实际值的位数小于显示宽度时才会补0，实际值的位数大于显示宽度时照原样输出。 对于没有声明ZEROFILL属性的列，显示宽度没有一毛钱卵用。 一个列同时具有多个属性每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了～ 注意：有的属性是冲突的，一个列不能具有两个冲突的属性，。如一个列不能既声明为PRIMARY KEY，又声明为UNIQUE KEY，不能既声明为DEFAULT NULL，又声明为NOT NULL。 查看表结构时的列属性有两种方式： 第一种 123456789101112mysql&gt; SHOW CREATE TABLE student_info;| student_info | CREATE TABLE `student_info` ( `number` int(11) NOT NULL, `name` varchar(5) DEFAULT NULL, `sex` enum(&apos;男&apos;,&apos;女&apos;) DEFAULT NULL, `id_number` char(18) DEFAULT NULL, `department` varchar(30) DEFAULT NULL, `major` varchar(30) DEFAULT NULL, `enrollment_time` date DEFAULT NULL, PRIMARY KEY (`number`), UNIQUE KEY `id_number` (`id_number`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | 第二种： 123456789101112mysql&gt; DESC student_info;+-----------------+-----------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+-----------------+------+-----+---------+-------+| number | int(11) | NO | PRI | NULL | || name | varchar(5) | YES | | NULL | || sex | enum(&apos;男&apos;,&apos;女&apos;) | YES | | NULL | || id_number | char(18) | YES | UNI | NULL | || department | varchar(30) | YES | | NULL | || major | varchar(30) | YES | | NULL | || enrollment_time | date | YES | | NULL | |+-----------------+-----------------+------+-----+---------+-------+ 可以看到： NULL列代表该列是否可以存储NULL，值为NO时，表示不允许存储NULL，值为YES是表示可以存储NULL Key列存储关于所谓的键的信息，当值为PRI时代表主键；当值为UNI时代表UNIQUE属性 Default列代表该列的默认值 Extra代表一些额外的信息。比如说如果某个列具有AUTO_INCREMENT属性就会被展示在这里]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常见问题汇总]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文主要记录在学习和应用MySQL中碰到的各种问题和解决方法，以备查用。 1. 如何查看端口号？一般有两种方法可查看数据库： 查看MySQL配置文件my.ini 123456mysql&gt; show variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3305 |+---------------+-------+ 2. 如何修改端口号？ 停止mysql服务 1net stop mysql80 打开MySQL根目录下my.ini文件，修改文件中的port值，注意两个地方[client]和[mysqld] 注意，如果要修改一定要同步修改为同一个值。服务器的端口号和客户端的端口号一定要保持一致，这样才能保证它两能顺利建立TCP/IP连接 重启mysql服务 1net start mysql80 3. 修改my.ini遇到权限问题由于修改my.ini文件需要管理员权限。如果没有权限会提示没有权限打开该文件。有两种解决方法： 发现没有权限，如果右键有用管理员打开，直接打开然后修改报错即可。 如果右键没有用管理员打开，就window下用管理员打开记事本，然后用记事本打开my.ini，修改然后保存即可。 4. 解决net start mysql启动,提示发生系统错误 5 拒绝访问在cmd下运行net start mysql 不能启动mysql！提示发生系统错误 5；拒绝访问！切换到管理员模式就可以启动了。所以我们要以管理员身份来运行cmd程序来启动mysql。 如果每天都要启动mysql服务，这样不很麻烦？所以： 右键cmd找到它所在的位置：如下图： 右击选择属性，选择快捷方式，再选择高级，在选择以管理员身份运行，再单击确定即可！ 5. 大小写问题SQL语句不区分大小写，比如select和SELECT是一样的，毫无区别。但是表中的数据是区分大小写的，比如表emp中有个人的姓名是’SMITH’。下面SQL语句在Oracle中会报错： 12mysql&gt; select * from emp where name = &apos;smith&apos;; // 报错mysql&gt; select * from emp where name = &apos;SMITH&apos;; // 正确 但是上面那种方法，用小写的’smith’在MySQL中也能查出来数据，因为MySQL相对于Oracle是比较语法松散的]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置文件my.ini介绍]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6my-ini%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[my.ini是什么？my.ini是MySQL数据库中使用的配置文件，修改这个文件可以达到更新配置的目的。 my.ini存放在哪里？my.ini存放在MySql安装的根目录，如图所示： my.ini具体内容介绍12345678910111213141516# CLIENT SECTION# ----------------------------------------------------------------------## The following options will be read by MySQL client applications.# Note that only client applications shipped by MySQL are guaranteed# to read this section. If you want your own MySQL client program to# honor these values, you need to specify it as an option during the# MySQL client library initialization.#[client]port=3306[mysql]default-character-set=gb2312 上面显示的是客户端的参数，[client]和[mysql]都是客户端，下面是参数简介： 1.port参数表示的是MySQL数据库的端口，默认的端口是3306，如果你需要更改端口号的话，就可以通过在这里修改。 2.default-character-set参数是客户端默认的字符集，如果你希望它支持中文，可以设置成gbk或者utf8。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# SERVER SECTION# ----------------------------------------------------------------------## The following options will be read by the MySQL Server. Make sure that# you have installed the server correctly (see above) so it reads this # file.#[mysqld]# The TCP/IP Port the MySQL Server will listen onport=3306#Path to installation directory. All paths are usually resolved relative to this.basedir="E:/Java/Mysql/"#Path to the database rootdatadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"# The default character set that will be used when a new schema or table is# created and no character set is definedcharacter-set-server=gb2312# The default storage engine that will be used when create new tables whendefault-storage-engine=INNODB# Set the SQL mode to strictsql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"# The maximum amount of concurrent sessions the MySQL server will# allow. One of these connections will be reserved for a user with# SUPER privileges to allow the administrator to login even if the# connection limit has been reached.max_connections=100# Query cache is used to cache SELECT results and later return them# without actual executing the same query once again. Having the query# cache enabled may result in significant speed improvements, if your# have a lot of identical queries and rarely changing tables. See the# "Qcache_lowmem_prunes" status variable to check if the current value# is high enough for your load.# Note: In case your tables change very often or if your queries are# textually different every time, the query cache may result in a# slowdown instead of a performance improvement.query_cache_size=0# The number of open tables for all threads. Increasing this value# increases the number of file descriptors that mysqld requires.# Therefore you have to make sure to set the amount of open files# allowed to at least 4096 in the variable "open-files-limit" in# section [mysqld_safe]table_cache=256# Maximum size for internal (in-memory) temporary tables. If a table# grows larger than this value, it is automatically converted to disk# based table This limitation is for a single table. There can be many# of them.tmp_table_size=35M# How many threads we should keep in a cache for reuse. When a client# disconnects, the client's threads are put in the cache if there aren't# more than thread_cache_size threads from before. This greatly reduces# the amount of thread creations needed if you have a lot of new# connections. (Normally this doesn't give a notable performance# improvement if you have a good thread implementation.)thread_cache_size=8#*** MyISAM Specific options# The maximum size of the temporary file MySQL is allowed to use while# recreating the index (during REPAIR, ALTER TABLE or LOAD DATA INFILE.# If the file-size would be bigger than this, the index will be created# through the key cache (which is slower).myisam_max_sort_file_size=100G# If the temporary file used for fast index creation would be bigger# than using the key cache by the amount specified here, then prefer the# key cache method. This is mainly used to force long character keys in# large tables to use the slower key cache method to create the index.myisam_sort_buffer_size=69M# Size of the Key Buffer, used to cache index blocks for MyISAM tables.# Do not set it larger than 30% of your available memory, as some memory# is also required by the OS to cache rows. Even if you're not using# MyISAM tables, you should still set it to 8-64M as it will also be# used for internal temporary disk tables.key_buffer_size=55M# Size of the buffer used for doing full table scans of MyISAM tables.# Allocated per thread, if a full scan is needed.read_buffer_size=64Kread_rnd_buffer_size=256K# This buffer is allocated when MySQL needs to rebuild the index in# REPAIR, OPTIMZE, ALTER table statements as well as in LOAD DATA INFILE# into an empty table. It is allocated per thread so be careful with# large settings.sort_buffer_size=256K 上面是服务器断参数，以下是参数的简介： 1.port参数也是表示数据库的端口，默认3306。 2.basedir参数表示MySQL的安装路径。 3.datadir参数表示MySQL数据文件的存储位置，也是数据库表的存放位置。 4.default-character-set参数表示默认的字符集，这个字符集是服务器端的。 5.default-storage-engine参数默认的存储引擎。 6.sql-mode参数表示SQL模式的参数，通过这个参数可以设置检验SQL语句的严格程度。 7.max_connections参数表示允许同时访问MySQL服务器的最大连接数，其中一个连接是保留的，留给管理员专用的。 8.query_cache_size参数表示查询时的缓存大小，缓存中可以存储以前通过select语句查询过的信息，再次查询时就可以直接从缓存中拿出信息。 9.table_cache参数表示所有进程打开表的总数。 10.tmp_table_size参数表示内存中临时表的总数。 11.thread_cache_size参数表示保留客户端线程的缓存。 12.myisam_max_sort_file_size参数表示MySQL重建索引时所允许的最大临时文件的大小。 13.myisam_sort_buffer_size参数表示重建索引时的缓存大小。 14.key_buffer_size参数表示关键词的缓存大小。 15.read_buffer_size参数表示MyISAM表全表扫描的缓存大小。 16.read_rnd_buffer_size参数表示将排序好的数据存入该缓存中。 17.sort_buffer_size参数表示用于排序的缓存大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#*** INNODB Specific options ***# Use this option if you have a MySQL server with InnoDB support enabled# but you do not plan to use it. This will save memory and disk space# and speed up some things.#skip-innodb# Additional memory pool that is used by InnoDB to store metadata# information. If InnoDB requires more memory for this purpose it will# start to allocate it from the OS. As this is fast enough on most# recent operating systems, you normally do not need to change this# value. SHOW INNODB STATUS will display the current amount used.innodb_additional_mem_pool_size=3M# If set to 1, InnoDB will flush (fsync) the transaction logs to the# disk at each commit, which offers full ACID behavior. If you are# willing to compromise this safety, and you are running small# transactions, you may set this to 0 or 2 to reduce disk I/O to the# logs. Value 0 means that the log is only written to the log file and# the log file flushed to disk approximately once per second. Value 2# means the log is written to the log file at each commit, but the log# file is only flushed to disk approximately once per second.innodb_flush_log_at_trx_commit=1# The size of the buffer InnoDB uses for buffering log data. As soon as# it is full, InnoDB will have to flush it to disk. As it is flushed# once per second anyway, it does not make sense to have it very large# (even with long transactions).innodb_log_buffer_size=2M# InnoDB, unlike MyISAM, uses a buffer pool to cache both indexes and# row data. The bigger you set this the less disk I/O is needed to# access data in tables. On a dedicated database server you may set this# parameter up to 80% of the machine physical memory size. Do not set it# too large, though, because competition of the physical memory may# cause paging in the operating system. Note that on 32bit systems you# might be limited to 2-3.5G of user level memory per process, so do not# set it too high.innodb_buffer_pool_size=107M# Size of each log file in a log group. You should set the combined size# of log files to about 25%-100% of your buffer pool size to avoid# unneeded buffer pool flush activity on log file overwrite. However,# note that a larger logfile size will increase the time needed for the# recovery process.innodb_log_file_size=54M# Number of threads allowed inside the InnoDB kernel. The optimal value# depends highly on the application, hardware as well as the OS# scheduler properties. A too high value may lead to thread thrashing.innodb_thread_concurrency=18 上面是InnoDB存储引擎使用的参数，一下是参数的简介： 1.innodb_additional_mem_pool_size参数表示附加的内存池，用来存储InnoDB表的内容。 2.innodb_flush_log_at_trx_commit参数是设置提交日志的时机，若设置为1，InnoDB会在每次提交后将事务日志写到磁盘上。 3.innodb_log_buffer_size参数表示用来存储日志数据的缓存区的大小。 4.innodb_buffer_pool_size参数表示缓存的大小，InnoDB使用一个缓冲池类保存索引和原始数据。 5.innodb_log_file_size参数表示日志文件的大小。 6.innodb_thread_concurrency参数表示在InnoDB存储引擎允许的线程最大数。 注意：每次修改参数后，必须重新启动MySQL服务才会有效。操作如下： 12net stop mysql80net start mysql80]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL客户端与服务器连接过程]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 我们现在已经知道如何启动MySQL的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！ ​ TCP/IP是客户端和服务器之间最常用的通信方式。真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。MySQL采用TCP作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程有需要采用TCP协议进行网络通信方面的需求，可以向操作系统申请一个端口号，这是一个整数值，它的取值范围是0~65535。这样在网络中的其他进程就可以通过IP地址 + 端口号的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。 ​ MySQL服务器启动的时候会默认申请3306端口号，之后就在这个端口上等待客户端进程进行连接。用书面一点的话来说，MySQL服务器会默认监听3306端口。 ​ 如果3306端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加-P参数来明确指定一下端口号，比如这样： 1mysqld -P3307 如果采用windows服务打开MySQL服务器，则需要修改配置文件my.ini中的默认端口号。这样MySQL服务器在启动时就会去监听我们指定的端口号3307。这里要注意，服务器的端口号和客户端的端口号一定要保持一致，这样才能保证它两能顺利建立TCP/IP连接 ​ 如果客户端进程想要使用TCP/IP网络来连接到服务器进程，比如我们在使用mysql来启动客户端程序时，在-h参数后必须跟随IP地址来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用127.0.0.1来代表本机的IP地址。另外，如果服务器进程监听的端口号不是默认的3306，我们也可以在使用mysql启动客户端程序时使用-P参数（大写的P，小写的p是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写： 1mysql -h127.0.0.1 -uroot -P3307 -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站导航]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%85%A8%E7%AB%99%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到本学习交流网站，为了便于自己日后复习查看，特此设置置顶全站导航 MySQLMySQL基础知识 MySQL概述 MySQL客户端与服务器连接过程 数据库基本操作 SQL数据的导入导出 MySQL表的基本操作 关于MySQL中的单引号、双引号和反引号 MySQL数据类型 列的属性 MySQL之查询、去重、限制条数、排序 MySQL之带条件的查询 MySQL之使用通配符进行模糊查询 隐式类型转换 表达式与函数 各种运算对于NULL值的处理 SQL查询语句的定义顺序和执行顺序 分组查询 连接查询 子查询 union关键字 MySQL存储引擎 事务 MySQL索引 视图 数据库设计三范式 MySQL配置问题 MySQL初始化与启动 MySQL配置文件my.ini介绍 MySQL注意事项与问题 MySQL密码错误如何修改 MySQL语句使用注意事项 MySQL常见问题汇总 算法机器学习算法 决策树 JavaJava基础知识 Java入门（含Java基本介绍、数据类型、流程控制和数组操作） JDK和JRE间的那些事儿 Java环境变量那些事儿 彻底弄懂Unicode编码那些事儿 源文件名和类名的关系 Java的加载与执行 Java命令行参数 Java面向对象编程（类、继承、多态、抽象类、接口） 对象的创建与使用-内存分析 类加载那些事儿 Java类初始化顺序 方法执行内存分析 面向对象封装性 方法调用时的参数传递问题 this关键字 static关键字 类继承实现的底层原理 super关键字 final关键字 关于Java的package和import Java如何查找Class 关于访问控制权限 抽象类和接口 Object类 内部类 数组 String类 包装类 异常 集合 如何理解Java采用Unicode编码 IO流 多线程 反射机制 注解 IntelliJ IDEA中各种文件夹的标记 JVM相关 从JVM角度看Java多态 class文件反汇编 JDBC JDBC概述 注册驱动与获取连接 模拟用户登录功能(MySQL+JDBC) JDBC事务机制 JDBC工具类封装 前端HTML 系统架构 HTML概述 HTML基本标签 HTML实体符号 HTML表格 背景颜色和背景图片 HTML图片img标签 HTML超链接 HTML列表 HTML表单 HTML文档中元素的ID属性 div和span在网页中的应用 CSS CSS概述 HTML引入CSS样式的三种方式 JavaScript JavaScript概述 ECMAScript HTML嵌入JS代码 JS变量 JS函数 JS数据类型 DOM 设置和获取文本框的value innerHTML和innerText操作div和span 正则表达式 去除字符串的前后空白-trim 表单验证 复选框的全选和取消全选 获取下拉列表选中项的value 周期函数setInterval 内置支持类Array-数组 BOM window的open和close 弹出确认框 将当前窗口设置为顶级窗口 history和location对象 JSON JSON在开发中的使用 MyBatis框架 MyBatis框架概述 Hexo 利用Hexo搭建个人博客 Hexo博客如何迁移至其它电脑]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java入门（含Java基本介绍、数据类型、流程控制和数组操作）]]></title>
    <url>%2F2020%2F02%2F06%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E5%90%ABJava%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Java介绍​ Java是目前全球Top 1的程序开发语言，是SUN公司James Gosling为手持设备开发的嵌入式编程语言，原名Oak，1995年改名为Java正式推出，有最大的开发社区；目前广泛应用于企业和互联网后端开发、Android开发和大数据开发。 1.1 Java的特点 一种面向对象的跨平台编程语言，语法比C++简单 以字节码的形式运行在虚拟机上 自带功能齐全的类库 有非常活跃的开源社区支持 1.2 Java的优缺点优点： 简单(语法比C++简单)、健壮(垃圾收集器让内存管理更容易)、安全(字节码运行在虚拟机上，无法操作硬件，因此安全) 跨平台，一次编写，到处运行 高度优化的虚拟机 缺点： 语法比较繁琐 无法直接操作硬件(不适用于底层操作系统的开发) GUI效果不佳(不适用于桌面应用程序的开发) 1.3 Java语言特性(开源、免费、纯面向对象、跨平台) 简单性 相对而言的，例如Java中不再支持多继承，C++是支持多继承的，多继承比较复杂。C++中有指针，Java中屏蔽了指针的概念。Java语言底层是C++实现的，不是C语言。 面向对象 可移植性（跨平台） 一次编译，到处运行 多线程 健壮性 和自动垃圾回收机制有关，自动垃圾回收机制简称GC机制。Java语言运行产生的垃圾是自动回收的，不需要程序员惯性 安全性 1.4 Java的版本 Java SE: Standard Edition(标准版) Java EE: Enterprise Edition(企业版) Java ME: Micro Edition(移动版) 1.5 Java的规范什么是规范？ ​ 比如USB就是一个规范，它规定了电源的正负极、信号线等等 ​ Java的规范是Java Specification Request，简称JSR。有个组织Java Community Process(JCP)，它负责维护JSR规范。 1.6 Java平台​ Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。 Java平台实际上就是运行在各种操作系统上的JVM(虚拟机) JDK和JRE的区别 JRE（Java Runtime Environment）是Java运行时环境。它是运行编译后的Java程序所需的一切包，包括Java虚拟机JVM、Java核心类库（都是class文件，在lib目录下打包成了jar）、Java命令和其它基础设施。但是，它不能用于创建新程序。总而言之是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的，而不是面向开发者的。 JDK（Java Development Kit）顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。它拥有JRE所拥有的一切，但同时也有编译器（javac）和工具类库tools.jar（如javadoc和jdb）等。有了JDK，不仅可以开发Java程序，也同时拥有了运行Java程序的平台 举个例子：程序员在本地开发时需要安装JDK。但将开发好的程序部署到客户端时，只需要在客户端安装JRE即可，无需再安装JDK。 1.7 Java为什么可以跨平台运行？Windows操作系统内核和Linux操作系统内核肯定不同，它们执行指令的方式也不同。因此Java程序不能直接和操作系统打交道，因为Java程序只有一份，操作系统执行原理却不同。 Sun团队让Java程序运行在一台虚拟机上，简称JVM（可认为是Java程序和操作系统之间的介质，屏蔽操作系统的差异）。JVM再和底层的操作系统打交道。 ​ ​ 1.首先开发好的java文件经过编译器Compiler的编译变为.class文件（字节码文件，非二进制文件），然而这个.class文件并不是真正的本地可以执行的指令 我们可以把这个.class文件称之为“中间码” ​ 2.不同的计算机操作系统有着相应的JVM 比如win32位的、win64位的、linux系统的，.class文件经过Interpreter（解释器，也就是JVM）的解释（或者称之为翻译），变为真正的本地可执行指令（“00101001001…”） 总结：“一处编译，到处运行”是因为程序的中间码.class文件是标准的，一致的，在各个系统对应的JVM上都可以被识别解释然后运行，所以可以实现跨平台 1.8 Java安装 上官网下载对应版本的JDK 官网网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 不更改安装路径，直接安装在C盘 配置JDK环境变量，将C:\ProgramFiles\Java\jdk\bin添加到系统path变量中。打开cmd，输入“javac -version”，如果出现版本号，即代表配置完成 2. Java程序基础2.1 Java程序基本结构标识符：在java源程序中凡是程序员有权利自己命名的单词都是标识符。标识符可以标识：类名、方法名、变量名、接口名、常量名等，且严格区分大小写，不能用关键字 标识符必须是英文字母、数字、下划线和美元符号$的组合；且不能以数字开头； 标识符命名规范（驼峰）： 类名、接口名：首字母大写，后面每个单词首字母大写 变量名、方法名：首字母小写，后面每个单词首字母大写 常量名：全部大写 Java的基本程序结构如下： 123456789101112/** * 可用来自动创建文档注释 */public class Hello &#123; public static void main(String[] args)&#123; //程序入口 System.out.pringln("Hello world"); /* 多行注释 注释内容 注释结束 */ &#125;&#125; //class定义结束 ​ ​ Java有三种注释（注释是解释说明作用，增加可读性，不会被编译到字节码文件中）： 单行注释：以双斜线//开头，到当前行尾 多行注释：以/ … /表示，中间所有内容都被视为注释 javadoc注释：写在类和方法定义处，可用于自动创建文档。 1234/*** javadoc注释**/ javadoc注释可以被javadoc.exe提取解析生成帮助文档 2.2 变量什么是变量？ 变量本质上是内存中的一块空间，这块空间有数据类型、名字和字面值（数据）。变量是内存中存储数据的最基本的单元。 数据类型的作用？ 不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间。数据类型是知道程序在运行阶段应该分配多大的内存空间 有了变量的概念后，内存空间得到了重复使用 12345678// 下面两个100是不同的内存空间System.out.println(100);System.out.println(100);// 引入变量，可访问同一块内存空间int i = 100;System.out.println(i);System.out.println(i); 123456public class Hello &#123; public static void main(String[] args)&#123; int n = 100; //基本类型 String s = "Hello,world"; //对象 &#125;&#125; 变量可以持有某个基本类型的数值，或者指向某个对象 定义变量 1变量类型 变量名; 变量可被重新赋值 在同一个作用域中，变量名不能重名（但不同作用域下可以重名，比如局部变量和成员变量，且局部变量屏蔽成员变量），但可以重新赋值 Java用一对大括号作为语句块的范围，称为作用域，作为在作用域里定义的一个变量，它只有在哪个作用域结束之前才可使用。 变量必须被定义赋值才能访问，两种方式赋值： 变量名 = 字面值； 变量类型 变量名 = 字面值; （初始化） 123456public class hello&#123; public static void main(String[] args)&#123; int i; System.out.println(i); //报错，因为没有赋值 &#125;&#125; 变量的分类： 根据变量声明的位置类分类 局部变量：在方法体当中声明的变量叫局部变量 成员变量：在方法体外（类体内）声明的变量叫成员变量 成员变量没有手动赋值，系统会默认赋值。而局部变量不会，如果没有赋值就访问，会报错。八种数据类型默认值： byte、short、int、long：0 float、double：0.0 boolean：false char：‘\u0000’ 引用数据类型：null 2.3 数据类型数据类型的作用 程序当中有很多数据，每一个数据都是有相关类型的，不同数据类型的数据占用空间大小不同。数据类型的作用是指导JVM在运行程序时给该数据分配多大的内存空间 Java数据类型分两种： 基本数据类型（4大类8小种） 引用数据类型 2.4 基本数据类型 整数类型：long、int、short、byte 浮点类型：double、float 布尔类型：boolean 字符类型：char 计算机内存的最小存储单元是字节（byte），一个字节时8位二进制数：00000000 ~ 11111111（0 ~ 255）。内存单元从0开始编号，称为内存地址。 2.4.1 整形 byte：8位，1字节 short：16位，2字节 int：32位，4字节 long：64位，8字节 Java语言当中的”整数型字面值”默认是int型，要让这个字面值被当做是long型，需要在后面加L Java语言中的整数型字面值有三种表示方式 十进制，是一种缺省 默认的方式 1int a = 10; 八进制，需要以0开始 1int b = 010; // 8 十六进制，需要以0x开始 1int c = 0x10; // 16 123456789byte b = 127; //byte范围：-128 ~ 127short s = 32767; //short范围：-32768 ~ 32767int i = 2147483647;int i2 = -2147483648;int i3 = 2_000_000_000; //加下划线更容易识别int i4 = 0xff0000; //16进制表示的16711680int i5 = 0b1000000000; //2进制表示的512// 同一个数的不同进制表示完全相同long l = 9000000000000000000L; //由于java默认类型为int，因此需要在结尾加L 有个小问题，java默认整数都是int型。按理说int型是不能赋值给short、byte、char类型的，但是下面却可以编译通过。这是为什么？在java中10这个常量到底是怎么存放的呢？ 123short a = 10;byte b = 10;char c = 10; 因为在Java中规定所有整数默认是int型。但是只要在byte，short、char它们的取值范围内赋值都是可以的，比如byte=127 就是可以的，但是你给byte=128 就不行了，因为就超出byte 127 的最大范围了。char=数字并不代表那是一个数字，char赋值整数代表的是它背后的字符，因为每一个字符给它硬性对应一个整数值 2.4.2 浮点类型 float：32位，4字节 double：64位，8字节 在java语言当中，所有浮点型字面值默认被当做double类型来处理。要想该字面值被当做float类型来处理，需在字面值后面添加F/f。 1234float f1 = 3.14f; // Java浮点数默认为double类型，float类型需在结尾加ffloat f2 = 3.14e38f; // 科学计数法表示的3.14*10^38double d = 1.79e308;double d1 = 4.9e-324; // 4.9*10^(-324) double的精度太低（相对来说），不适合做财务软件。财务涉及到钱的问题，要求精度较高。所以SUN公司在基础SE类库中为程序员准备了精度更高的类型，只不过这种类型是一种引用数据类型，不属于基本数据类型，它是java.math.BigDecimal（定点数） 2.4.3 布尔类型只有true和false两个值，通常是计算结果，占用1个字节 不可以0或非 0 的整数替代false和true，这点和C语言不同 1boolean flag = 1; // 编译错误，不兼容的类型 boolean类型不可以转换为其它的数据类型 2.4.4 字符类型char：保存一个字符，用单引号表示，占用2个字节，取值范围是 0 ~ 65535。如果输入多个字符编译器将会报错。注意区分字符类型和字符串类型的区别。 123char c1 = 'A';// 或 char c1 = '\u0041';char c2 = '中'; short和char所表示的种类总数是一样的，只不过char可以表示更大的正整数，因为char没有负数 char类型表示的是现实世界中的文字，文字和计算机二进制之间默认情况下不存在转换关系。为了让计算机可以表示现实世界中的文字，我们需要人为干涉，需要人提前制定好文字和二进制之间的对照关系，这种对照关系被称为：字符编码。计算机最初只支持英文，最先出现的字符编码是ASCII码： ‘a’ —&gt; 97 ‘A’ —&gt; 65 ‘0’ —&gt; 48 ASCII码共定义了128个字符，因此用一个字节即可完全表示 编码和解码采用同一套编码集，不会出现乱码。否则会出现乱码 随着计算机的发展，后来出现了一种编码方式，是国际化标准组织ISO制定的，这种编码方式支持西欧语言，向上兼容ASCII码，仍然不支持中文。这种编码方式是：ISO-8859-1，又被称为latin-1 随着计算机向亚洲发展，计算机开始支持中文、日文、韩文等，其中支持简体中文的编码方式：GB2312、GBK、GB18030（容量从小到大，即支持的中文字符数量从小到大） 支持繁体中文：大五码（big5） 后来出现了一种编码方式统一了全球所有的文字，容量较大，这种编码方式叫做unicode编码。unicode编码方式有多种具体的实现：UTF-8、UTF-16、UTF-32等 Java语言源代码采用unicode编码方式，所以标识符可以写中文 Java中用两个字节表示char，在char中存储的是字符的Unicode码点，char只能表示 BMP子符（BMP的定义见另一篇文章：彻底弄懂Unicode编码那些事儿）。 这里我也疑惑很久Java是如何表示单个的补充码字符（即SMP中的字符），后来明白Java给出的方式就是 “表示不了” ，这样也很合理，65536个字符几乎已经涵盖世界主流语言用到的所有字符了，没必要为了极少出现的字符而构建一个复杂的char类型。 Java中的char本质上是UTF-16编码。而UTF-16实际上也是一个变长编码（2字节或4字节）。如果一个抽象的字符在UTF-16编码下占4字节，显然它是不能放到char中的。换言之，char中只能放UTF-16编码下只占2字节的那些字符，即BMP中的字符。 转义字符反斜杠 \ 在 Java语言中具有转义功能，转义字符出现在特殊字符前，会将特殊字符转义成普通字符 \n：换行符 \t：制表符（Table键，与空格不同） \\：反斜杠字符（’\\’这种会报错，因为\有转义功能，会与后面的单引号配对成转义字符，因此前面的单引号没人与它配对） \’：单引号字符（’’’会报错，原因类似上面，后面两个单引号会配对） \”：双引号字符。这里需要注意一点 \u####：代表后面的一串是一个字符的Unicode编码 12345System.out.println("\"Helloworld\""); //输出:"Helloworld"//System.out.println(""Helloworld""); //报错// 因此在字符串中表示双引号需要加反斜杠char c = '"'; // 代表双引号，无需加反斜杠，因为没人跟他配对，这里需要多注意 2.5 数据类型转换关于基本数据类型之间的互相转换，转换规则如下： 8种基本数据类型当中除boolean类型外，剩下的7种类型之间都可以互相转换 小容量可直接向大容量转换，称为自动类型转换。容量从小到大排序： byte &lt; short/char &lt; int &lt; long &lt; float &lt; double 注意：任何浮点类型不管占用多少字节，都比整数类型容量大。char和short容量相同。 123int a = 100;long b = a;long c = 10; 大容量不能直接转换为小容量，需要加强制类型转换符，称为强制类型转换。但是在运行阶段可能会损失精度，所以谨慎使用。强转原理：将左边的二进制位砍掉 123long a = 100L;// int b = a; // 编译错误int b = (int)a; //编译正确 当整数字面值没有超过byte、short、char的取值范围，可以直接赋值给byte、short和char类型的变量。但整型变量不能直接赋值给short、byte和char变量，也需要强制类型转换符 1234567// byte a = 1000; // 错误，因为1000超出了byte的范围byte a = 20; // 正确，因为20没有超出byte范围/*int r = 20;short t = r; // 编译错误short t = (short)r; // 编译正确*/ byte、short和char类型混合运算的时候，各自先转换成int类型再做运算 1234byte i = 5;short j = 10;//short k = i + j; //编译错误，short和byte运算，首先会转换成int再运算，所以i+j运算结果为int，int赋值给short就会出错short k = (short)(i+j); // 编译正确 多种数据类型混合运算时，先转换成容量最大的那种类型再做运算 当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。 2.6 常量常量就是用final修饰的变量： 常量初始化后不可再次赋值 常量名通常全部大写 常量用来避免意外赋值 常量用来替代Magic Number：魔数导致代码可读性差，修改不方便的问题。 12345678// 常量的好处就是如果需要更改常量的值，只需在定义处修改final double PI = 3.14;double r = 4.0;double area = PI*r*r;//magic number:增加可读性，后续能看懂final double tax_rate = 0.2;double pay = 1-tax_rate; 2.7 基本类型和引用类型Java提供了两种变量类型：基本类型和引用类型。 基本类型：byte、short、int、long、float、double、char、boolean 引用类型：String、类、接口类型、数组类型、枚举类型、注解类型 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。 基本类型的变量是”持有”某个数值，引用类型的变量是”指向“某个对象 注意：栈存放的是基本数据类型(基本数据类型包括：int、short、double、long、float、boolean、char、byte；注意没有String)以及对象的引用。栈还有一个很大的特点就是栈中的数据可以共享。比如定义两个int类型的变量：int a = 3; int b = 3;这里a和b是一个指向int型的引用，指向”3”这个字面值。编译器先处理int a = 3;这句语句的时候，先在栈中创建一个变量为a的引用，然后查找有没字面值为3的地址，如果没有就开辟出一个存储3的地址，然后将a指向这个3对应的地址。接着处理int b = 3;，也是先创建一个变量b的引用，由于栈中已经有字面量3了，于是就把b也指向3对应的这个地址，所以a和b都指向了一个地址。当我们执行 b = 4;的时候，首先还是去栈中查找有没字面量值为4对应的地址，如果没有就开辟个，然后将b指向这个新开辟的地址。如果已经有了就直接将b指向这个地址，此时a还是指向3，但b指向4了，而且他俩不再指向同一个地址了。当声明基本类型变量时，变量名和字面值（变量名和字面值是两个概念）均放在栈中，变量名指向字面值。 2.8 引用类型Java的引用与C++的指针在原理上是相类似的，但Java没有指针，只有引用。 简单的说，引用其实就像是一个对象的名字或者别名 (alias)，一个对象在内存中会请求一块空间来保存数据，根据对象的大小，它可能需要占用的空间大小也不等。访问对象的时候，我们不会直接是访问对象在内存中的数据，而是通过引用去访问。引用也是一种数据类型，我们可以把它想象为类似 C++ 语言中指针的东西，它指示了对象在内存中的地址——只不过我们不能够观察到这个地址究竟是什么。 如果我们定义了不止一个引用指向同一个对象，那么这些引用是不相同的，因为引用也是一种数据类型，需要一定的内存空间（stack，栈空间）来保存。但是它们的值是相同的，都指示同一个对象在内存（heap，堆空间）的中位置。 123String a = "hello";String b = a;//表示a和b是两个不同的引用，但它们的值是一样的，都指向同一个对象"hello" 总结： 引用是一种数据类型（保存在stack中），保存了对象在内存（heap，堆空间）中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)； 不同的引用可能指向同一个对象，换句话说，一个对象可以有多个引用，即该类类型的变量。 2.9 整数运算计算机数字运算均是基于补码的。 运算规则： 基本四则运算法则 除法结果为整数 除数为0时，运行将报错 ++运算和—运算 123int s = 100;System.out.println(s++); // 100System.out.println(s); // 101 +=运算、-=运算、*=运算、/=运算、%=运算 先执行等号右边的表达式，将执行结果赋值给左边的变量 1234567byte b = 10;// b = b+5; // 编译错误，因为b+5将转为int变量b += 5; // 编译正确，等同于 b = (byte)(b+5);byte i =0;i += 128; // 最终i的结果是-128，因为进行强制类型转换 所以这5种赋值运算符默认会进行强制类型转换，不改变运算结果类型。假设最初这个变量的类型时byte类型，无论怎么进行追加或追减，最终该变量的数据类型还是byte类型 取余运算% 注意：运算符有优先级，不确定的加小括号()，优先级得到提升 Java源码中经常会使用移位运算来代替乘除运算，因为移位运算的性能比乘除运算的高（PS：对于计算机而言，移位运算只是移了个位置），所以了解移位运算的计算过程对于我们阅读源码会有一定的帮助。 原码：第一位表示符号, 其余位表示值 反码：正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。通常上述这种解释谁也看不懂，下面介绍一种别的说法。举一个生活中的例子来说明这个问题： 如果说现在时针现在停在10点钟，那么什么时候时针会停在八点钟呢？简单，过去隔两个小时的时候，是八点钟。未来过十个小时的时候也是八点钟。也就是说时间正拨10小时，或是倒拨2小时都是八点钟。也就是10-2=8，而10+10=8（10+10=10+2+8=12+8=8）这个时候满12说明时针在走第二圈了，又走了8小时，所以时针正好又停在八点钟。也就是说， 10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。既然是等效的，那在时钟运算中，减去一个数，其实就相当于加上另外一个数（这个数与减数相加正好等于12）。这里12被称为模，本质上是将溢出的部分舍去而不改变结果。易得，单字节(8位)运算的模为256=2^8。故可以得到以下结论： 负数的补码为模减去该数的绝对值的二进制。 如-5的补码为： -5=256-5=251=1111 1011(二进制，此时不考虑符号位，单纯二进制表示) 同样的，临界值-128也可以表示出来： -128=256-128=128=1000 0000(二进制) 计算负数补码当然可以用上面的方法，也可以用下面我们介绍的小技巧，口算就能算出负数补码 计算负数补码的小技巧：首先记住该数的数据类型字节大小对应的负数补码原点。例如对于4位，-8是补码远点；对于8位，负数补码原点是-128；十六位可以把-32768当补码原点。负数补码原点总是最高位是1，其他位是0 如果我们把-8当成负数的原点。那么-5的补码是多少呢？ -5 = -8 + 3 1000（-8） +0011（3）=1011(-5) 所以可口算出-5的补码是1011 移位运算（3种）： 左移&lt;&lt;：丢弃左边指定位数，右边补0 带符号右移&gt;&gt;：丢弃右边指定位数，左边补上符号位 不带符号右移&gt;&gt;&gt;：丢弃右边指定位数，左边补上0 byte和short会先转换为int再进行移位 结论：对于机器而言，java中的移位运算都是对补码执行移位运算的，下面以-1&lt;&lt;1=-2为例进行讲解: -1的原码：10000000 00000000 00000000 00000001 -1的反码：11111111 11111111 11111111 11111110 -1的补码：11111111 11111111 11111111 11111111 执行移位操作 -1移位后的补码：11111111 11111111 11111111 11111110 -1移位后的反码：11111111 11111111 11111111 11111101 -1移位后的原码：10000000 00000000 00000000 00000010 得到最后的原码十进制值为-2 举例如下： 12345int n1 = 5;int n2 = n1&lt;&lt;10; //5120int n3 = n2&gt;&gt;11; //2int n4 = n1&lt;&lt;29; //-1610612736int n5 = n4&gt;&gt;29; //-3 类型自动提升与强制转型 在运算过程中，计算结果为较大类型的整型 12short s = 12;int i = 100+s; //100为int型，计算结果自动转为int型 较大类型的整数不能直接赋值给一个较小类型的整数，相反较小类型的整数能直接赋值给较大类型的整数 12long a = 100L;int b = a; //编译错误 可将结果强制转型 123(类型)变量或数值long a = 100L;int b = (int)a; 强制转型可能会丢失精度，因为int是32位，long是64位，所以如果数值大于32位会损失精度 2.10 浮点数运算浮点数运算的特点： 很多浮点数无法精确表示(详情可见另一篇博客：MySQL数据类型) 计算有误差，因为浮点数无法精确表示 1double b = 1-9.0/10; //0.09999999999999998 计算时如果浮点数和整数进行运算，整型可以自动提升为浮点型 浮点数运算特殊值（三种）： 1double d1 = 0.0/0; //NAN，不报错 1double d2 1.0/0; //Infinity 1double d3 = -1.0/0; //Infinity 强制转型 强制转为整型会直接扔掉小数位 12int n1 = (int)12.3; //12int n2 = (int)12.7; //12 四舍五入的技巧 1int n3 = (int)(12.7+0.5); 超出整型范围自动变为最大值 1int n4 = (int)1.2e20; //2147483647 2.11 布尔运算 关系运算符：&gt; , &gt;= , &lt; , &lt;= , == , != 关系运算符的运算结果一定是boolean类型，true or false 逻辑运算符 &amp;：逻辑与（两边的算子都是true，结果才是true） |：逻辑或（两边的算子只要有一个是true，结果就是true） ^：逻辑异或（两边的算子结果不一样，结果就是true） 逻辑非：！（取反，！false是true，！true是false） 短路与运算：&amp;&amp;（运算结果与&amp;完全相同，只不过这个有短路） 短路或运算：||运算结果与|完全相同，只不过这个有短路） 逻辑运算符要求两边的算子都是boolean类型，并且逻辑运算符的最终结果也是一个boolean类型 短路运算符： 与运算&amp;&amp;：与运算中，如果有任何一个表达式的计算结果为false，则后面的表达式将不再计算 或运算||：或运算中，如果有任何一个表达式的计算结果为true，则后面的表达式将不再计算 三元运算符：b ? x : y 语法规则：布尔表达式 ？ 表示式1 ： 表达式2 根据条件b计算x或y，b为true计算x，b为false计算y x和y只计算其中一个 x和y类型必须相同 2.12 字符和字符串 字符类型是基本数据类型，保存一个字符。Java使用Unicode编码，因此可将字符类型直接赋值给一个int类型。还可直接用Unicode编码表示字符类型： 12// '\u####',4位16进制char c = '\u0041'; //'A' 字符串类型不是一个基本类型，是引用类型。String保存一个字符串。 1String s = "ABC"; 字符串连接用+，可以连接字符串和其它数据类型 12String s = "hello" + "world";String a = "age is" + 12; 因为字符串类型是引用类型，所以字符串不可变，只能改变其引用指向的对象。 所有的引用类型可以指向空值null，表示不指向任何对象。空值null和空字符串””是不一样的，注意区分。 1String s = null; 2.13 数组类型当有一组类型相同的变量时，可以用数组表示： 数组类型是：类型[] 数组初始化用new int[数组长度] 数组所有元素初始化为默认值 数组创建后大小不可改变 数组索引从0开始 12345678910public class hello&#123; public static void main(String[] args)&#123; int[] ns = new int[5]; ns[0] = 1; ns[1] = 2; ns[2] = 3; ns[3] = 4; ns[4] = 5; &#125;&#125; 用数组变量.length获取数组大小 12int[] ns = new int[5];System.out.println(ns.length); 数组变量是引用类型 可以指定初始化的元素，由编译器自动推算数组大小 123int[] ns = new int[] &#123;1,2,3,4,5&#125;;//可进一步简写int[] ns = &#123;1,2,3,4,5&#125;; 数组变量是引用类型，数组大小不可变，可指向不同的数组对象 数组元素是值类型（如int[]）或引用类型（如String[]） 2.14 Java对日期的处理12345678910import java.util.Date;public class Time &#123; public static void main(String[] args) &#123; // 获取系统当前时间 Date noWTime = new Date(); // Date类重写了toString方法 // Fri May 08 15:45:48 GMT+08:00 2020 System.out.println(nowTime); &#125;&#125; 日期可以格式化么？将日期类型Date，按照指定的格式进行转换：Date —&gt; 转换成具有一定格式的日期字符串 SimpleDateFormat是java.text包下的，专门负责日期格式化 12345678910111213import java.util.Date;import java.text.SimpleDateFormat;public class Array &#123; public static void main(String[] args) &#123; Date t = new Date(); //Fri May 08 15:51:55 GMT+08:00 2020 System.out.println(t); SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS"); String tStr = s.format(t); //2020-05-08 15:51:55 319 System.out.println(tStr); &#125;&#125; 假设有一个日期字符串String，怎么转换成Date类型？ 12345678910111213import java.util.Date;import java.text.SimpleDateFormat;public class Array &#123; public static void main(String[] args) throws Exception&#123; String time = "2008-08-08 08:08:08 888"; // 格式要和time的格式相同 SimpleDateFormat s2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS"); // 注意抛出异常，否则会报错 Date dateTime = s2.parse(time); System.out.println(dateTime); &#125;&#125; 获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数 123456public class Array &#123; public static void main(String[] args)&#123; long n = System.currentTimeMillis(); System.out.println(n); //1588924995077 &#125;&#125; 这个功能可以用来计算方法执行时间 1234567891011121314public class Array &#123; public static void main(String[] args)&#123; long a = System.currentTimeMillis(); print(); long b = System.currentTimeMillis(); System.out.println("耗费时长"+(b-a)+"毫秒"); &#125; public static void print()&#123; for(int i=0;i&lt;1000;i++)&#123; System.out.println(i); &#125; &#125;&#125; 通过毫秒构建Date对象 上面介绍了Date类的无参构造函数；这里还有一个有参的构造函数 12345678910111213// Date(long date):date指自格林威治1970年1月1日 00:00:00以来的毫秒数import java.util.Date;import java.text.SimpleDateFormat;public class Array &#123; public static void main(String[] args)&#123; Date s = new Date(1); SimpleDateFormat date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS"); String dateStr = date.format(s); //1970-01-01 08:00:00 001(北京是东八区) System.out.println(dateStr); &#125;&#125; 2.15 数字格式化：代表任意数字，：代表千分位 .：代表小数点 0：不够时补0 123456789101112import java.text.DecimalFormat;public class Array &#123; public static void main(String[] args)&#123; //保留两位小数，加入千分位 DecimalFormat df = new DecimalFormat("###,###.##"); String s = df.format(1234.456); System.out.println(s); //1,234.46 DecimalFormat df2 = new DecimalFormat("###,###.0000"); String s2 = df2.format(1234.45); System.out.println(s2); //1,234.4500 &#125; 2.16 BigDecimalBigDecimal属于大数据类型，精度极高，不属于基本数据类型，属于引用数据类型 常用于财务软件当中，财务软件当中double 的精度是不够的 1234567891011import java.math.BigDecimal;public class Array &#123; public static void main(String[] args)&#123; // 不是普通的100，是精度极高的100 BigDecimal a = new BigDecimal(100); BigDecimal b = new BigDecimal(200); // 不能直接使用+号进行相加 BigDecimal c = a.add(b); System.out.println(c); // 300 &#125;&#125; 2.17 随机数12345678910111213import java.util.Random;public class Array &#123; public static void main(String[] args)&#123; Random random = new Random(); //随机产生一个int范围类型的随机数 int num = random.nextInt(); System.out.println(num); // 产生[0,100]之间的随机数，不能产生101 int x = random.nextInt(100); System.out.println(x); &#125;&#125; 生成5个不重复的随机数 1234567891011121314151617181920import java.util.Random;import java.util.Arrays;public class Array &#123; public static void main(String[] args)&#123; Random random = new Random(); int[] elements = new int[5]; elements[0] = random.nextInt(100); int index = 1; while(index&lt;=4)&#123; int tmp = random.nextInt(100); for(int i=0;i&lt;index;i++)&#123; if(elements[i]==tmp) break; if(i==index-1 &amp;&amp; elements[i]!=tmp) elements[index++] = tmp; &#125; &#125; System.out.println(Arrays.toString(elements)); &#125;&#125; 2.18 枚举类型枚举：一枚一枚可以列举出来的，才建议使用枚举类型 枚举编译后也是生成class文件 枚举是一种引用数据类型 枚举中的每一个值可以看做是常量 方法中的计算结果只有两种情况的，建议使用boolean；结果超过两种并且可列举，使用枚举类型 123456789101112131415161718192021public class Array &#123; public static void main(String[] args)&#123; Result r = divide(10,0); System.out.println(r==Result.SUCCESS ? "计算成功" : "计算失败"); // 计算失败 &#125; public static Result divide(int a,int b)&#123; try&#123; int c = a/b; return Result.SUCCESS; &#125;catch(Exception e)&#123; return Result.FAIL; &#125; &#125;&#125;enum Result&#123; // SUCCESS是枚举类型中的一个值 // FAIL是枚举类型中的一个值 SUCCESS,FAIL&#125; 3. 流程控制3.1 输入和输出输出： 输出并换行 1System.out.println() 输出但不换行 1System.out.print() 输入: 导入java.util.Scanner 创建Scanner并传入System.in 使用scanner.nextLine()读字符串 使用scanner.nextInt()读Int整数 使用scanner.nextDouble()读长整型 …… 1234567891011import java.util.Scanner;public class hello&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("Input your name:"); String name = scanner.nextLine(); System.out.println("Input your age:"); int age = scanner.nextInt(); &#125;&#125; 格式化输出： 格式化输出使用System.out.printf() 使用占位符%### 1System.out.printf("%s is %d years old\n","Bob",12); 常用占位符： 占位符 含义 %d 整数 %x 十六进制整数 %f 浮点数 %s 字符串 %% 百分号字符本身 %e 科学计数法表示浮点数 %c 字符 %b 布尔值 12345678public class hello&#123; public static void main(String[] args)&#123; double d = 3.1415926; System.out.println(d); System.out.printf("PI = %.2f\n",d); System.out.printf("PI = %7.2f\n",d); &#125;&#125; 运行结果如下： 1233.1415926PI = 3.14PI = 3.14 //3前面补充了三个空格 格式标识符解释 %7.2f： 7为域宽度.输出的浮点数条目宽度至少为7,包括小数点和小数点后两位数字.这样,给小数点前分配了4位数字.如果该条目小数点前的位数小于4,就在数字前面加空格.如果该条目小数点前的位数大于4,则自动增加宽度. 2为精度().即想要输出的小数点的长度. f为转换码 指定宽度和精度的例子 举例 输出 %5c 输出字符并在这个字符条目前面加4个空格 %6b 输出字符并在这个字符条目前面加4个空格 %5d 输出整个条目,宽度至少为5.如果该条目的数字位数小于5,就在数字前面加空格.如果该条目的位数大于5,则自动增加宽度 %10.2f 输出的浮点条目宽度至少为10,包括小数点、和小数点后两位数字.这样,给小数点前分配了7位数字. 如果该条目小数点前的位数小于7,就在数字前面加空格. 如果该条目小数点前的位数大于7,则自动增加宽度. %10.2e 输出的浮点条目的宽度至少为10,包括小数点、小数点后面两位数字和指数部分(包括e、正负号和指数数字).如果按科学计数法显示的数字位数小于10,就给数字前加空格 %12s 输出的字符串至少为12个字符.如果该字符串条目小于12个字符,就在该字符串前加空格.如果该字符串条目多余12个字符,则自动增加宽度 注意的问题： 默认情况下,输出是右对齐的（即如果宽度不够，在左边补齐空格）.可以在格式标识符中放一个符号(-),表明该条目在特定区域中的输出是左对齐的. 123456System.out.printf("%8.4f",1.12);System.out.printf("%-8.4f",1.12);// 输出 1.12001.1200 使用符号%来标记格式标识符,要在格式字符串里输出直接量%,需要使用%% 如果在补齐时不希望以空格进行补齐，而希望以0进行补齐，如下所示： 1234System.out.printf("PI = %08d\n",1234);// 输出00001234 如果想显示符号位，如下所示： 1234System.out.printf("PI = %+8d\n",1234);// 无论正负都可以用上述形式显示符号位// 输出 +1234 //符号也占一位 如何控制输出顺序 1234567// #$表示第几个变量System.out.printf("%2$d, %1$d",13,14);System.out.printf("%2$s, %1$s","a","b");// 输出14, 13b, a 3.2 引用类型判断是否相等 判断两个引用是否指向堆中的同一个实例，用”==” 123String a = "hello";String b = "world";Sytsem.out.println(a==b); 判断两个引用指向的实例是否相等，用equals。如果变量为null，调用equals()会报错，利用短路运算符&amp;&amp;解决。 1234String a = "hello";String b = "world";if(a!=null &amp;&amp; a.equals(b)) System.out.println("yes"); 3.3 if语句语法结构：四种编写方式 if(布尔表达式){java语句} if(布尔表达式){java语句} else{java语句} if(布尔表达式){java语句} elseif(布尔表达式){java语句} else if{java语句} … if(布尔表达式){java语句} elseif(布尔表达式){java语句} else if{java语句} else{java语句} if语句最多只能执行一个分支（0个或1个） 以上的第二种和第四种方式都带有else分支，这两种方式可以保证会有一条分支执行。第一种和第三种可能一个分支也不执行 可以嵌套使用 if语句分支中只有一条java语句，大括号可以省略，不推荐 3.4 Switch语句1234567891011121314int opt = 2;switch(opt)&#123; case 1: System.out.println("1"); break; case 2: System.out.println("2"); break; case 3: System.out.println("3"); break; default: System.out.println("none");&#125; switch后面的括号里只能写int或string类型的字面值或变量 注意case语句没有{} case语句具有”穿透性“，如果不加break会导致意想不到的结果。当opt=2，如果不写break导致case2、case3和default顺序执行（case3和default不用管是否匹配） 如果都没有匹配，则执行default switch和case后面的计算结果必须是整形、字符串（字符串比较内容相等）。从JDK7开始，byte、short和char也可以，因为可以自动类型转换 case可以合并 12345int i = 1;switch(i)&#123; case 1: case2: case3: // i=1、2、3都可以执行下述语句 System.out.println("Test");&#125; 如何避免漏写break和default？ 打开eclipse中的窗口-&gt;首选项 Java-&gt;编译器-&gt;错误/警告-&gt;可能的编程问题，将”switch缺少default语句”和”switch case跳转”修改为警告： 这样以后如果忘了写break或default时会有警告 3.5 While循环 while循环首先判断条件 条件满足时循环 条件不满足时退出 可能一次都不循环 注意逻辑，避免无限死循环 123456int sum = 0;int n = 1;while(n&lt;10)&#123; sum = sum+n; n++;&#125; 3.6 do-while循环 do-while先执行循环，再判断条件 条件满足时继续循环 条件不满足时退出 至少循环一次 123456int sum = 0;int n = 1;do&#123; sum += n; n++;&#125; while(n&lt;10); 3.7 for循环for循环分别设置： 计数器初始值 循环前检测条件 每次循环后如何更新计数器 1234int[] ns = &#123;1,2,3,4,5&#125;;for(int i=0;i&lt;ns.length;i++)&#123; System.out.println(ns[i]);&#125; for里面的三个语句可以都没有 当嵌套for循环时，内层循环和外层循环的变量不能重名 初始化计数器总是被执行 可能循环0次 for each循环 JDK5.0之后的新特性：增强for循环 1234int[] ns = &#123;1,2,3,4,5&#125;;for(int n:ns)&#123; System.out.println(n);&#125; for each循环可以更简单的遍历数组 for each循环能够遍历数组和”可迭代”数据类型，包括List、Map等 for each循环无法指定遍历顺序，只能从前往后单向循环 for each循环无法获取数组索引，因此无法同时遍历多个数组。只能通过for循环 12345int[] ns1 = &#123;1,2,3,4,5&#125;;int[] ns2 = &#123;6,7,8,9,10&#125;;for(int i=0;i&lt;ns1.length;i++)&#123; ns2[i] = ns1[i]*ns1[i];&#125; 3.8 break和continue在循环中，可以使用break语句和continue语句。 break跳出循环 循环过程中，可以使用break语句跳出循环 如果有多层循环嵌套，break语句总是跳出最近的一层循环。 break通常配合if，在满足条件时提前结束循环 continue提前结束当前循环 continue可提前结束本轮循环，直接继续下次循环 continue通常配合if，在满足条件时提前结束本轮循环 数组操作遍历数组 for循环可以遍历数组 for(;;)循环通过下标遍历数组 for each循环直接遍历数组元素 直接打印数组变量，得到的是数组在JVM中的引用地址。for each循环打印也很麻烦。Arrays.toString()可以快速打印数组内容 1234import java.util.Arrays;int[] ns = &#123;1,1,2,3,5,8&#125;;System.out.println(Arrays.toString(ns)); 数组排序有两种方法： 自己写排序算法，比如冒泡排序、快排等 使用JDK的Arrays.sort()排序。 12345import java.util.Arrays;int[] ns = &#123;28,12,89,73,65&#125;;Arrays.sort(ns);System.out.println(Arrays.toString(ns)); // Arrays重写了toString方法，输出数组 对数组排序修改了数组本身 多维数组二维数组 二维数组就是数组的数组 12345int[][] ns = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 二维数组的内存空间分配如图所示： 数组变量分配在栈内存中，其指向一个三维数组，该三维分配在堆内存上。每一维数组元素由指向一个一维数组，同样分配在堆内存上。 访问二维数组元素使用array[rows] [cols] 二维数组每个数组元素长度不要求相同 三维数组与二维数组类似，内存分配如图所示 123456789101112131415int[][][] ns = &#123; &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;, &#123; &#123;10,11&#125;, &#123;12,13&#125; &#125;, &#123; &#123;14,15,16&#125;, &#123;17,18&#125; &#125;&#125;; 其余多维数组类似]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表的基本操作]]></title>
    <url>%2F2019%2F11%2F13%2FMySQL%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ 创建表的时候首先需要描述清楚这个表是什么样的，它有哪些列，这些列都是用来存什么类型的数据等等。表中的一行叫做一条记录，一列就做一个字段。 展示当前数据库的表​ 下面的语句用于展示当前数据库中有哪些表： 1mysql&gt; SHOW TABLES; 创建表1、基本语法创建一个表时至少需要完成下列事情： （1）给表起个名 （2）给表定义一些列，并且给这些列都起个名 （3）每个列都需要定义一种数据类型 （4）如果有需要的话，可以给这些列定义一些列的属性，比如不许存储NULL，设置默认值等，具体列可以设置哪些属性可以在后面再详细说一下 创建表的基本语法如下： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 注意事项： 表名在数据库当中一般建议以：t_ 或者tbl_ 开始 在CREATE TABLE后写清楚我们要创建的表的名称 在小括号 () 中定义这个表各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性(列的属性用中括号 [] 包起来的意思是这部分是可选的) 列名、数据类型、列属性之间用空白字符分开就好，然后各个列的信息之间用逗号分隔开 下面我们建个表为例展示一下： 1234CREATE TABLE first_table( first_column INT, second_column VARCHAR(100)); 执行结果如下： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; );Query OK, 0 rows affected (0.02 sec) 如何查看已建立的表的列属性信息？ 12345678910// 第一种方式,这种方式可以查看表的创建语句mysql&gt; show create table first_table;// 结果如下CREATE TABLE `first_table` ( `first_column` int(11) DEFAULT NULL, `second_column` varchar(100) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4// 第二种方式，这种方式可以查看已创建的表的结构，但看不到创建语句mysql&gt; desc first_table; 2、为建表语句添加注释​ 我们可以在创建表时将该表的用处以注释的形式添加到语句中，只要在建表语句最后加上COMMIT语句即可： 123CREATE TABLE 表名 ( 各个列的信息 ...) COMMENT &apos;表的注释信息&apos;; 比如我们可以这样写first_table的建表语句： 1234CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100)) COMMENT &apos;第一个表&apos;; 注释没必要太长，言简意赅即可，毕竟是给人看的，让人看明白是个啥意思就好了。为了我们自己的方便，也为了阅读你创建的人的方便，请遵守一下职业道德，写个注释吧～ 3、IF NOT EXISTS​ 和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，我们来试试重复创建一下first_table表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; ) COMMENT &apos;第一个表&apos;;ERROR 1050 (42S01): Table &apos;first_table&apos; already exists 如果想要避免这种错误发生，可以在创建表的时候使用这种形式： 123CREATE TABLE IF NOT EXISTS 表名( 各个列的信息 ...); 4、简单的查询和插入语句简单的查询语句 如果我们想查看某个表里已经存储了哪些数据，可以用下边这个语句： 1SELECT * FROM 表名; 比如我们想看看前边创建的first_table表中有哪些数据，可以这么写： 12mysql&gt; SELECT * FROM first_table;Empty set (0.01 sec) 很遗憾，我们从来没有向表中插入过数据，所以查询结果显示的是Empty set，表示什么都没查出来～ 简单的插入语句 MySQL插入数据的时候是以行为单位的，语法格式如下： 1INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...); 也就是说我们可以在表名后边的括号中指定要插入数据的列，然后在VALUES后边的括号中按指定的列顺序填入对应的值（只要前后对的上就行，不一定非要遵循建表时的列的顺序）。注意：如果我们在插入的时候把表名后面的列省略，那么values中的值的类型和顺序必须和建表时候一模一样。 我们来为first_table表插入第一行数据： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(1, &apos;aaa&apos;);Query OK, 1 row affected (0.00 sec) 这个语句的意思就是我们要向first_table表中插入一行数据，first_column列的值是1，second_colum列的值是’aaa’。看一下现在表中的数据： 1234567mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa |+--------------+---------------+1 row in set (0.00 sec) 我们也可以只指定部分的列，没有显式指定的列的值将被设置为NULL（因为默认是default NULL，如果我们在建表的时候可以自己default给定默认值，此时insert语句成功后没有显示指定的列的值将被设置为我们自己设置的默认值），NULL的意思就是此列的值尚不确定。比如这样写： 12345mysql&gt; INSERT INTO first_table(first_column) VALUES(2);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO first_table(second_column) VALUES(&apos;ccc&apos;);Query OK, 1 row affected (0.00 sec) 这两条语句的意思就是： 第一条插入语句我们只指定了first_column列的值是2，而没有指定second_column的值，所以second_colum的值就是NULL。 第二条插入语句我们只指定了second_column的值是’ccc’，而没有指定first_column的值，所以first_column的值就是NULL。 执行完这两条语句后，再看一下现在表中的数据： 123456789mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc |+--------------+---------------+3 rows in set (0.00 sec) 批量插入 每插入一行数据写一条语句也不是不行，但是对人来说太烦了，而且每插入一行数据就向服务器提交一个请求远没有一次把所有插入的数据提交给服务器效率高，所以MySQL为我们提供了批量插入记录的语句： 1INSERT INTO 表名(列1,列2, ...) VAULES(列1的值，列2的值, ...), (列1的值，列2的值, ...), (列1的值，列2的值, ...), ...; 也就是在原来的单条插入语句后边多写几条记录的内容，用逗号分隔开就好了，举个例子： 12345678910111213141516mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(4, &apos;ddd&apos;), (5, &apos;eee&apos;), (6, &apos;fff&apos;);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc || 4 | ddd || 5 | eee || 6 | fff |+--------------+---------------+6 rows in set (0.01 sec) INSERT IGNORE 对于一些是主键或者具有UNIQUE约束的列或者列组合来说，它们不允许重复值的出现，比如我们把t1的m1列添加一个UNIQUE约束： 123mysql&gt; alter table t1 modify m1 int(11) unique;Query OK, 0 rows affected (0.12 sec)Records: 0 Duplicates: 0 Warnings: 0 因为m1列有了UNIQUE约束，所以如果待插入记录的t1列值与已有的值重复的话就会报错，比如这样： 12mysql&gt; insert into t1 values(1,&apos;xixi&apos;);ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;m1&apos; 所以，对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中没有与待插入记录在这些列或者列组合上重复的值，那么就把待插入记录插到表中，否则忽略此次插入操作。如下所示： 12mysql&gt; insert ignore into t1 values(1,&apos;xixi&apos;);Query OK, 0 rows affected, 1 warning (0.06 sec) 对于批量插入的情况，INSERT IGNORE同样适用，比如这样： 12345678910111213mysql&gt; insert ignore into t1 values(1,&apos;xixi&apos;),(9,&apos;haha&apos;);Query OK, 1 row affected, 1 warning (0.03 sec)Records: 2 Duplicates: 1 Warnings: 1mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 9 | haha |+------+------+3 rows in set (0.00 sec) 这个批量插入的语句中我们想插入(1, &#39;xixi&#39;)和(9, &#39;haha&#39;)这两条记录，因为m1列值为1的记录已经在表中存在，所以这个记录会被忽略，而(9, &#39;haha&#39;)这条记录被插入成功 insert on duplicate key update 对于主键或者有唯一性约束的列或列组合来说，新插入的记录如果和表中已存在的记录重复的话，我们可以选择的策略不仅仅是忽略该条记录的插入，也可以选择更新这条重复的旧记录。比如我们想在first_table表中插入一条记录，内容是(1, &#39;哇哈哈&#39;)，我们想要的效果是：对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中没有与待插入记录在这些列或者列组合上重复的值，那么就把待插入记录插到表中，否则按照规定去更新那条重复的记录中某些列的值。设计MySQL的大叔给我们提供了INSERT ... ON DUPLICATE KEY UPDATE ...的语法来实现这个功能： 123456789101112mysql&gt; insert into t1 values(1,&apos;xixi&apos;) on duplicate key update n1 = &apos;jack&apos;;Query OK, 2 rows affected (0.09 sec)mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | jack || 2 | b || 9 | haha |+------+------+3 rows in set (0.00 sec) 这个语句的意思就是，对于要插入的数据(1, &#39;xixi&#39;)来说，如果t1表中已经存在m1的列值为1的记录（因为m1列具有UNIQUE约束），那么就把该记录的n1列更新为&#39;jack&#39; 对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中有与待插入记录在这些列或者列组合上重复的值，我们可以使用VALUES(列名)的形式来引用待插入记录中对应列的值，比方说下边这个INSERT语句： 123456789101112mysql&gt; insert into t1 values(1,&apos;rose&apos;) on duplicate key update n1 = values(n1);Query OK, 2 rows affected (0.10 sec)mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | rose || 2 | b || 9 | haha |+------+------+3 rows in set (0.00 sec) 其中的VALUES(n1)就代表着待插入记录中n1的值，本例中就是&#39;rose&#39;。有人就疑惑了，为什么不直接写成update n1 = ‘rose’？是的，没有任何问题，但是在批量插入大量记录的时候该咋办呢？此时VALUES(n1)就 派上了大用场： 12345678910111213mysql&gt; insert into t1 values(1,&apos;可乐&apos;),(2,&apos;红牛&apos;),(9,&apos;雪碧&apos;) on duplicate key update n1 = values(n1);Query OK, 6 rows affected (0.04 sec)Records: 3 Duplicates: 3 Warnings: 0mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | 可乐 || 2 | 红牛 || 9 | 雪碧 |+------+------+3 rows in set (0.00 sec) 删除表1mysql&gt; drop table if exists 表名; 这里的if exists可以不要 表的复制将查询结果当做表创建出来 语法： 1mysql&gt; create table 表名 as select语句 123456789101112131415161718192021mysql&gt; create table emp1 as select * from emp;mysql&gt; select * from emp1;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+14 rows in set (0.00 sec) 也可以只复制部分列 123456789101112131415161718192021mysql&gt; create table emp2 as select ename,job from emp;mysql&gt; select * from emp2;+--------+-----------+| ename | job |+--------+-----------+| SMITH | CLERK || ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || SCOTT | ANALYST || KING | PRESIDENT || TURNER | SALESMAN || ADAMS | CLERK || JAMES | CLERK || FORD | ANALYST || MILLER | CLERK |+--------+-----------+14 rows in set (0.00 sec) 也可以将查询结果插入到一张表中：(表结构要求：表的列数要和查询结果中的字段数相同) 1234567891011121314151617181920212223242526mysql&gt; create table dept1 as select * from dept;mysql&gt; select * from dept1;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+4 rows in set (0.00 sec)mysql&gt; insert into dept1 select * from dept;mysql&gt; select * from dept1;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON || 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+8 rows in set (0.00 sec) 如果只想插入部分字段怎么办？ 1234567891011121314151617181920212223242526272829303132333435mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | c |+------+------+3 rows in set (0.00 sec)mysql&gt; select * from t2;+------+------+| m2 | n2 |+------+------+| 2 | b || 3 | c || 4 | d || 2 | r |+------+------+4 rows in set (0.00 sec)mysql&gt; insert into t1(m1) select m2 from t2;mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | c || 2 | NULL || 3 | NULL || 4 | NULL || 2 | NULL |+------+------+7 rows in set (0.00 sec) 注意和全部字段的区别，没有插入的字段按照默认值插入处理。 修改数据语法格式： 1mysql&gt; update 表名 set 字段名1=值1,字段名2=值2... where 条件; 注意：没有where条件，整张表数据将全部更新 1234567891011121314151617mysql&gt; update dept1 set loc=&apos;beijing&apos; where deptno=10;Query OK, 2 rows affected (0.02 sec)mysql&gt; select * from dept1;+--------+------------+---------+| DEPTNO | DNAME | LOC |+--------+------------+---------+| 10 | ACCOUNTING | beijing || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON || 10 | ACCOUNTING | beijing || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+---------+8 rows in set (0.00 sec) 我们也可以使用LIMIT子句来限制想要更新的记录数量，使用ORDER BY子句来指定符合条件的记录的更新顺序，比如： 12345678910111213mysql&gt; update t1 set n1 = &apos;abc&apos; order by m1 desc limit 1;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b || 3 | abc |+------+------+3 rows in set (0.00 sec) 上述语句就是想删更新m1列值最大的那条记录 删除数据语法格式： 1mysql&gt; delete from 表名 where 条件; 注意：没有条件将全部删除 删除编号为10的部门数据 123456789101112131415mysql&gt; delete from dept1 where deptno=10;Query OK, 2 rows affected (0.10 sec)mysql&gt; select * from dept1;+--------+------------+---------+| DEPTNO | DNAME | LOC |+--------+------------+---------+| 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+---------+6 rows in set (0.00 sec) 我们也可以使用LIMIT子句来限制想要删除掉的记录数量，使用ORDER BY子句来指定符合条件的记录的删除顺序，比方说这样： 1234567891011mysql&gt; delete from t1 order by m1 desc limit 1;Query OK, 1 row affected (0.09 sec)mysql&gt; select * from t1;+------+------+| m1 | n1 |+------+------+| 1 | a || 2 | b |+------+------+2 rows in set (0.00 sec) 重点：怎么删除大表？如果数据量很大，delete语句删除动则就几个小时，效率很低。 为什么delete效率低呢？ 因为它在删除的时候，没有删除存储空间，就等于是那些存储数据的格子还在，回滚的时候数据还能回来。所以用delete删除后是可以后悔的~ 删除大表语法： 1mysql&gt; truncate table 表名; 该语法表示，下面的那些存储数据的格子连同数据一起被截断删除，不可回滚，永久丢失。但是表的定义还在，还可以往里面添加数据。删除后发现该表还在，即show tables找得到该表，只不过表中的数据没有了 还有一种删除表的方式： 1mysql&gt; drop table 表名; 删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。删除后发现表没有了，即show tables找不到该表 表结构修改实际开发中，一旦设计好表结构就很少修改了，很少很少用到，可以直接用Navicat工具修改即可。如果非要写SQL语句，就简单说一下语法： 添加字段 1mysql&gt; alter table 表名 add 字段名 数据类型 [约束条件] [FIRST|AFTER 已存在的字段名] FIRST 为可选参数，其作用是将新添加的字段设置为表的第一个字段；AFTER 为可选参数，其作用是将新添加的字段添加到指定的已存在的字段名的后面。 修改字段数据类型 1mysql&gt; alter table 表名 modify 字段名 数据类型 [约束条件]; 其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。不写约束条件就默认删除了已有的约束条件，如果想添加新的约束条件可在后面直接写即可，不会影响已经存在的约束条件 修改字段名称 1mysql&gt; alter table 表名 change 旧字段名 新字段名 新数据类型 [约束条件]; 其中，旧字段名指修改前的字段名；新字段名指修改后的字段名；新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 删除字段 1mysql&gt; alter table 表名 drop 字段名; 其中，字段名指需要从表中删除的字段的名称。 修改表名 1mysql&gt; alter table 旧表名 rename [to] 新表名 其中，TO 为可选参数，使用与否均不影响结果。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库层面基本操作]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ MySQL中把一些标的集合成为一个数据库，MySQL服务器管理着若干个数据库，每个数据库下都可以有若干个表，即 展示数据库​ 在刚安装好MySQL的时候，它内建了许多数据库和表了，我们可以使用下述命令来看一下都有哪些数据库： 1mysql&gt; SHOW DATABASES; 创建数据库1mysql&gt; CREATE DATABASE 数据库名; ​ 注意如果一个数据库已经存在的情况下再使用CREATE DATABASE去创建这个数据库会产生错误！如果我们并不清楚数据库是否存在，可以使用下边的语句来创建数据库： 1mysql&gt; CREATE DATABASE IF NOT EXISTS 数据库名; 上述命令的意思是如果指定数据库不存在的话就创建它，否则什么都不做。 切换当前数据库​ 对于每一个连接到MySQL服务器的客户端，都有一个当前数据库的概念（也可以称之为默认数据库），我们创建的表默认都会被放到当前数据库中，切换当前数据库的命令也贼简单： 1USE 数据库名称; ​ 如果显示了Databases changed，说明当前数据库已经切换成功了。需要注意的是，在退出当前客户端之后，也就是你输入了exit或者quit命令之后或者直接把当前的黑框框页面关掉，当你再次打开MySQL时，相当于重新开启了一个客户端，需要重新调用USE 数据库名称的语句来选择一下当前数据库。 ​ 其实我们在新客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，只要把数据库名称写在启动客户端的命令后面就好，如下： 1mysql -hlocalhost -uroot -p 数据库名称; 删除数据库​ 如果我们觉得某个数据库没用了，可以把它删除掉，语法如下： 1DROP DATABASE 数据库名; ​ 在真实的工作环境里，在删除数据库之前你需要先拿体温计量量是不是发高烧了，然后再找至少两个人核实一下自己是不是发烧了，然后你才敢执行删除数据库的命令。删除数据库意味着里边的表就都被删除了，也就意味着你的数据都没了，所以是个极其危险的操作，使用时需要极其谨慎。 ​ ​ 如果某个数据库并不存在，我们仍旧调用DROP DATABASE语句去删除它，会报错。 ​ 如果想要避免这种报错，可以使用这种形式的语句来删除数据库： 1DROP DATABASE IF EXISTS 数据库名; 查看当前使用的数据库123456mysql&gt; select database();+------------+| database() |+------------+| run |+------------+ 查看MySQL版本号123456mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.12 |+-----------+]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F10%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL支持所有的SQL数据类型，主要分为以下四类： 数值类型 字符串类型 时间日期类型 二进制类型 一、数值类型​ MySQL数值类型有9种，其中整数类型有5种（INTEGER、TINYINT、SMALLINT、MEDIUMINT和BIGINT）、浮点类型2种（float(M,D)、double(M,D)）、定点数1种（decimal(M,D)）和bit(M)类型1种。 整数类型 ​ 使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间。根据表示一个数占用字节数的不同，MySQL把整数划分成如下所示的类型： 类型 占用的存储空间（单位：字节） 无符号数取值范围 有符号数取值范围 含义 TINYINT 1 0~255 -128~127 非常小的整数 SMALLINT 2 0~65535 -32768~32767 小的整数 MEDIUMINT 3 0~16777215 -8388608~8388607 中等大小的整数 INT(INTEGER) 4 0~4294967 295 -2147483648~2147483647 标准的整数 BIGINT 8 0~2^64^-1 -2^63^~2^63^-1 大整数 以TINYINT为例，用1个字节，也就是8位表示有符号数的话，就是既可以表示正数，也可以表示负数的话，需要有一个比特位表示正负号。但是如果表示无符号数的话，也就是只表示非负数的话，就不需要表示正负号，这就是有符号数和无符号数的区别。 注意，对于INT(M)类型，M值不代表可以存储的数字长度，代表的是数据在显示时显式的最小长度。在 INT(M) 中，M 的值跟 INT(M) 所占多少存储空间并无任何关系。 INT(3)、INT(4)、INT(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，INT(M) 跟 INT 数据类型是相同的。当数据长度超过M时，相当于啥也没发生，正常显示。如果数据长度小于M，需要指定某个字符来填充。要查看出不同效果记得在创建类型的时候加 zerofill（见”列的属性”一节）这个值，表示用0填充，否则看不出效果的 浮点数类型 ​ 浮点数是用来表示小数的，平时用的十进制小数也可以转换成二进制后被计算机存储。比如9.875，这个小数可以被表示成这样： 19.875 = 8 + 1 + 0.5 + 0.25 + 0.125 = 1 × 2³ + 1 × 2⁰ + 1 × 2⁻¹ + 1 × 2⁻² + 1 × 2⁻³ 即，如果十进制小数9.875转换成二进制小数的话就是：1001.111。为了在计算机中存储这种二进制小数，统一把它们表示成 a*2^n 的科学计数法的形式，其中1&lt;=|a|&lt;2，比如1001.111可以表示为1.001111*2^3，我们把小数点后的001111成为尾数，把3称为指数，然后只需要在计算机中的比特位中表示出尾数和指数就行了。另外，小数也有正负之分，我们还需要单独的部分来表示小数的正负号。综上所述，表示一个浮点数需要下边几个部分： 符号部分：占用1个比特位即可 指数部分：视具体浮点数格式而定 尾数部分：视具体浮点数格式而定 ​ 很显然，表示一个浮点数使用的字节数越多，表示尾数和指数的范围就越大，也就是说可以表示的小数范围就越大。MySQL根据表示一个小数需要的不同字节数定义了如下的两种浮点数类型： 类型 占用的存储空间（单位：字节） 绝对值最小非零值 绝对值最大非零值 含义 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 MySQL中，FLOAT占4字节（1位符号位，8位表示指数，23位表示尾数），DOUBLE占8字节（1位符号位，11位表示指数，52位表示尾数）。这里以单精度浮点数类型FLOAT为例，它占用的4个字节的各个组成部分如下图所示： 另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的（即可能存在精度损失的问题）。 ​ 这里我们补充一下浮点数类型在内存中的存储方式： ​ 先来卡一下浮点数二进制表达的三个组成部分： ​ 三个主要部分是： 符号：表示浮点数是正数还是负数，0表示正数，1表示负数 指数部分：类似于科学计数法中的M*10^N^中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中以2^7^-1即127，也即01111111代表指数部分为0，转换时需要根据127作偏移调整。 为什么要以127作为偏移量呢？计算机表示单精度浮点数时，是用8位去存储指数部分，在数值上面，表示0 ~ 255，但是我们同样需要有负指数，正负指数的位数量为了均等，各自一半，-127 ~ 128，0是特殊点，特殊处理。储存时候会加上127，这样就刚刚好是0~255，就能很好的储存了，不然，不移量的话需要判断符号位来判断数值的正负。 尾数部分：浮点数中具体数值的实际表示。 ​ 下面展示实际转换过程： step 1：改写整数部分 ​ 以数值5.2为例。先不考虑小数部分，我们先单纯的将十进制数改写成二进制。即5转换为101 step 2：改写小数部分 ​ 把十进制的小数部分乘以2，取整数部分作为作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。 ​ 例如0.2可以转换为： ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ 0.6*2 = 1.2 1 ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ …… ​ 即最后转换结果为：.0011001……（它是一个无限循环的二进制数，明白为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况了吗） step 3：规格化 ​ 现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。 step 4：填充 ​ 指数部分（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。 ​ 尾数部分：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分1在填充时被舍去了。因为规格化后的数值整部部分总是为1。那省略整数部分后岂不是1.010011和0.010011就混淆了么？其实并不会，如果仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。（那么如何表示指数为-2的形式呢？即127-2=125，二进制表示为01111101） 举两个例子吧，比较直观一些（浮点数二进制转换工具） 1、9.875 其中打钩代表对应的二进制位为1，否则为0 2、0.3 ​ 设置最大位数和小数位数 ​ 在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，即 12FLOAT(M,D)DOUBLE(M,D) ​ 对我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M,D)或DOUBLE(M,D)来限制可以存储到本列中的小数范围。其中： M表示该小数最多需要的十进制有效数字个数 注意是有效数字个数，比如对于2.3，有效数字个数是2，对于0.9来说有效数字个数就是1 D表示该小数的小数点后的十进制数字个数 小数点后有几个十进制数字，D的值就是什么 举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化： 类型 取值范围 FLOAT(4,1) -999.9~999.9 FLOAT(5,1) -9999.9~9999.9 FLOAT(4,0) -9999~9999 FLOAT(4,2) -99.99~99.99 M取值范围为0~255。FLOAT只保证7位有效数字的准确性，所以FLOAT(M,D)中，M&lt;=7时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 D取值范围为0~30，同时必须&lt;=M。double只保证16位有效数字的准确性，所以DOUBLE(M,D)中，M&lt;=16时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 FLOAT和DOUBLE中，若M的定义分别超出7和16，则多出的有效数字部分，取值是不定的，通常数值上会发生错误。因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。 定点数类型 ​ 因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了定点数类型，它也是存储小数的一种方式： 类型 占用的存储空间（单位：字节） 取值范围 DECIMAL(M,D) 取决于M和D 取决于M和D ​ M和D的含义与浮点数中M和D的含义一样。但单精度浮点数类型FLOAT(M,D)占用的字节一直都是4字节，双精度浮点数类型DOUBLE(M,D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动。但对于定点数类型DECIMAL(M,D)来说，它占用的存储空间大小就和M、D的取值有关。 ​ 定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。如何才能保证精确存储呢？只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么。比如对于十进制小数9.85来说，我们可以把小数点左右的两个整数，也就是9和85分别保存起来，那么不就相当于保存了一个精确的小数。 ​ ​ 下面详细说一下DECIMAL(M,D)的存储方式，以DECIMAL(16,4)为例： 1、首先确定小数左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图： 2、从小数点位置出发，每个整数每隔9个十进制位划分为一组，如图： 从上图可以看出，如果不足9个十进制位，也会被划分为一组 3、针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表： 组中包含的十进制位数 占用的存储空间大小（单位：字节） 1或2 1 3或4 2 5或6 3 7或8或9 4 所以DECIMAL(16,4)共需要占用8个字节的存储空间大小，这8个字节由下边三个部分组成： 第一组包含3个十进制位，需要2个字节 第二组包含9个十进制位，需要4个字节 第三组包含4个十进制位，需要2个字节 4、 将转换完成的比特位序列的最高位设置为1 举个例子吧，要不这咋可能弄得懂嘛，哼！ 比如用DECIMAL(M,D)存储十进制小数1234567890.1234，这个小数会被分为三部分： 11 234567890 1234 然后将每一组中的十进制数字转换成对应的二进制数字 第一组占用2个字节，即对应的二进制数为： 100000000 00000001(0x0001) 第二组占用4个字节，整数234567890对应的十六进制数为 10x0DFB38D2 第三组占用2个字节，整数1234对应的十六进制数为 10x04D2 所以将这些十六进制数字连起来之后就是： 10x00010DFB38D204D2 ​ 最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(M,D)存储时共占用8个字节，具体为： 10x80010DFB38D204D2 ​ 如果用定点数类型DECIMAL(16,4)存储一个负数怎么办？比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就行，即 10x7FFEF204C72DFB2D ​ 对于定点数类型，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。 ​ 对于定点数类型DECIMAL(M,D)来说，M和D都是可选的，默认的M的值是10，默认的D的值为0，即 12DECIMAL = DECIMAL(10) = DECIMAL(10,0)DECIMAL(n) = DECIMAL(n,0) M的范围是1-65，D的范围是0-30，且D的值不能超过M。 ​ 注意：比如DECIMAL(5,2)，取值范围为-999.99~999.99 如果存储时，整数部分超出了范围（如1000.01）,MySQL就会报错，不允许存这样的值。 如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。 如：999.994实际被保存为999.99。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如999.995和-999.995都会报错。 无符号数值类型 ​ unsigned是MySQL自定义的类型，主要有以下用途： 起到约束数值的作用，即非负数（如果插入的数据是负数则会报错： Out of range value for column） 增加数值范围 unsigned可以用于整数、浮点数和定点数。MySQL提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词unsigned 1数值类型 unsigned 注意：在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。 二、日期时间类型​ MySQL提供了多种关于时间和日期的类型，各种类型能表示的范围如下： 类型 存储空间要求（单位：字节） 取值范围 含义 YEAR 1 1901~2155 年份值 DATE 3 ‘1000-01-01’ ~ ‘9999-12-31’ 日期值 TIME 3 ‘-838:59:59’ ~ ‘838:59:59’ 时间值 DATETIME 8 ‘1000-01-01 00:00:00’ ～ ‘9999-12-31 23:59:59’ 日期加时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ ～ ‘2038-01-19 03:14:07’ 时间戳 ​ 在MySQL5.6.4这个版本后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持，称为小数秒。MySQL最多支持6为小数秒的支持，各个位代表的意思如下： 如果想让TIME、DATETIME、TIMESTAMP支持小数秒，可以这样写： 12类型(小数秒位数)其中的小数秒位数可以在0,1,2,3,4,5,6中选择 比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果多了小数秒，就需要额外的存储空间： 保留的小数秒位数 额外需要的存储空间（单位：字节） 0 0 1或2 1 3或4 2 5或6 3 注意，要特别注意下DATETIME和TIMESTAMP的区别 占用空间不同，datetime占8字节，timestamp占用4字节 表示范围不同，timestamp表示当前时间到Unix元年（1970 年 1 月 1 日 0 时 0 分 0 秒）的秒数。 时区。timestamp以UTC的格式存储，它会自动检索当前时区并进行转换，datetime不会进行时区的检索。也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。比如 1set time_zone = "+9:00";(时区设为东九区) 此时就相当于是改变了时区。 如果存进去的是NULL，timestamp会自动存储当前时间，而datetime会储存NULL 在定义timestamp类型时，加入了default current_timestamp。则无需显示的插入时间数据，在插入数据时会默认插入系统时间 timestamp类型可以在修改时自动更新，列定义如下： 1uptime timestamp default current_timestamp on update current_timestamp 上述定义后，如果更新某一列的数据时，会默认更新该列的为当前系统时间 三、字符串类型​ 字符是面向人的概念，如果想在计算机中表示字符，那就需要将该字符与一个特定的二进制序列对应起来，这个映射过程称为编码。但这种映射关系不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种： 固定长度的编码方案 表示不同的字符所需要的字节数量是相同的。比方说ASCII编码方案采用1个字节来编码一个字符，usc2采用2个字节来编码一个字符。 变长的编码方案 表示不同的字符所需要的字节数量是不同的。比如utf8编码方案采用1-3个字节来编码一个字符，gb2312采用1-2个字节来编码一个字符。 注意：正儿八经的UTF-8编码占用1~ 4个字节，这里的utf8占用1~3个字节是阉割版的。如果我们之后有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集。 MySQL的字符串类型 ​ 下表表示MySQL中提供的字符串类型，其中M代表该数据类型最多能存储的字符数量，L代表实际向该类型中存储的字符串在特定字符集下所占的字节数，W代表该特定字符集下，编码一个字符最多需要的字节数： 类型 最大程度 存储空间要求 含义 CHAR(M) M个字符 M*W个字节 固定长度字符串 VARCHAR(M) M个字符 L+1或L+2个字节 可变长度字符串 TINYTEXT 2^8^-1个字节 L+1个字节 非常小型的字符串 TEXT 2^18^-1个字节 L+2个字节 小型的字符串 MEDIUMTEXT 2^24^-1个字节 L+3个字节 中等大小的字符串 LONGTEXT 2^32^-1个字节 L+4个字节 大型的字符串 CHAR(M) ​ M是该类型最多可以存储的字符数量（非字节数量），M的取值范围是0-255。如果省略掉M的值，那它的默认值就是1，也就是说CHAR和CHAR(1)是一个意思。CHAR(0)是一种特别的类型，它只能存储空字符串或者NULL值。 ​ CHAR(M)在不同的字符集下需要的存储空间也是不一样的，我们假设某个字符集编码一个字符最多需要W个字节，那么类型CHAR(M)占用的存储空间大小就是M×W个字符。比方说： 对于采用ASCII字符集的CHAR(5)类型来说，ASCII字符集编码一个字符最多需要1个字节，也就是M=5，W=1，所以占用的内存空间大小是5*1=5个字节。 对于采用gbk字符集的CHAR(5)类型来说，gbk字符集编码一个字符最多需要2个字节，也就是M=5，W=2，所以占用的内存空间大小是5*2=10个字节。 对于采用utf8字符集的CHAR(5)类型来说，utf8字符集编码一个字符最多需要3个字节，也就是M=5，W=3，所以占用的内存空间大小是5*3=15个字节。 ​ 如果我们实际存储的字符串在特定字符集编码下占用的字节数不足M*W，那么剩余的那些存储空间用空格字符补齐。即一旦确定了CHAR(M)类型的M，如果M的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费。 VARCHAR(M) ​ 如果某个列存储的字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，因此可以使用VARCHAR(M)。 ​ VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是0-65535。但是，MySQL中有一个规定，表中某一行包含的所有列中存储的数据大小总共不能超过65535个字节，也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。 ​ VARCHAR(M)类型表示的数据由以下两部分组成： 1、真正的字符串内容 ​ 假设真正的字符串在特定字符集编码后占用的字节数为L 2、占用字节数 ​ 假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么： 当M*W&lt;256时，只需要一个字节来表示占用的字节数 当M*W&gt;=256且M*W&lt;65536时，需要两个字节来表示占用的字节数 （因为一个字节能表示的最大无符号数是255，两个字节能表示的最大无符号数十65535） 各种TEXT类型 ​ 虽然VARCHAR(M)已经可以存储很长的字符串了，可有时候还是不够怎么办？对于很长的字符串，可以用TEXT存储大型字符串，它们都是变长类型。 ​ MySQL有个规定，某一行包含的所有列中存储的数据大小总和不得超过65535个字节。这个规定对于这些TEXT类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了。 ENUM类型和SET类型 ENUM类型称为枚举类型，它表示在给定的字符串列表里选择一个。比如性别，只能在’男’和’女’里面选一个，相当于一个单选框 1ENUM('str1','str2','str3',...) SET类型表示可以在给定的字符串列表里选择多个。比如兴趣列表，相当于一个多选框 1SET('str1','str2','str3',...) SET类型怎么insert？ 123456789101112131415mysql&gt; create table enum_set_table( -&gt; id int auto_increment primary key, -&gt; gender enum('M','F'), -&gt; hobby set('music','movie','swimming','footbal') -&gt; );Query OK, 0 rows affected (0.01 sec)/* 一个enum值，一个set值，二者均使用选项的字符串格式 */mysql&gt; insert into enum_set_table(id,gender,hobby) values(null,'M','music');Query OK, 1 row affected (0.01 sec)/* 一个enum值，多个set值，二者均使用选项的字符串格式 */// 这种同时输入多个set值的方法要注意mysql&gt; insert into enum_set_table(id,gender,hobby) values(null,'F','music,movie,footbal');Query OK, 1 row affected (0.00 sec) 综上所述，ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。 四、二进制类型 BIT类型 ​ 有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型： 类型 字节数 含义 BIT(M) 近似为(M+7)/8 存储M个比特位的值 M默认为1，M的取值范围为1~64，M可以省略，即BIT和BIT(1)一样。 BINARY(M)和VARBINARY(M) ​ 前者是固定长度的类型，后者是可变长度的类型，其中M代表该类型最多能存放的字节数量。BINARY(M)和VARBINARY(M)对应于我们前边提到的CHAR(M)和VARCHAR(M)，都是前者是固定长度的类型，后者是可变长度的类型，只不过BINARY(M)和VARBINARY(M)是用来存放字节的，其中的M代表该类型最多能存放的字节数量，而CHAR(M)和VARCHAR(M)是用来存储字符的，其中的M代表该类型最多能存放的字符数量。它们M的取值范围一样，对于CHAR 和BINARY是0 ~ 255；对于VARCHAR和VARBINARY是0 ~ 65535。 其它的二进制类型 ​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB是针对数据量很大的二进制数据提出的，比如图片、音乐、压缩文件啥的。BLOB和TEXT一样也是变长的，有相同的最大长度和存储需求。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句使用注意事项]]></title>
    <url>%2F2019%2F10%2F25%2FMySQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[​ MySQL的基本运行过程是：通过客户端发送命令给服务器程序，服务器程序按照接收的命令去操作实际的数据。在我们使用黑框框启动了MySQL客户端程序之后，界面上会一直显示一行字儿：mysql&gt;，这是一个提示符，你可以在它后边输入我们的命令然后按下回车键就把命令从客户端程序发送到了服务器程序，在书写命令的时候需要注意下边这几点： 1、命令结束符号 ​ 在书写完一个命令后需要以下面几个符号之一结尾： ； \g \G 其中；和\g的效果一样，如下所示： 123456789101112131415161718192021mysql&gt; show tables;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+mysql&gt; show tables\g+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 其中\G有一点特殊，它并不以表格的形式返回查询结果，而是以垂直的形式将每个列都展示在单独的一行中： 1234567891011mysql&gt; show tables\G*************************** 1. row ***************************Tables_in_run: student_info*************************** 2. row ***************************Tables_in_run: student_score*************************** 3. row ***************************Tables_in_run: t1*************************** 4. row ***************************Tables_in_run: t1_view*************************** 5. row ***************************Tables_in_run: t2 如果查询结果的列数非常多的话，使用\G可以让我们看清结果。 注意：使用Navicat第三方工具是不支持\g和\G的，只能在cmd界面中使用。 2、命令可以随意换行 ​ 并不是按了回车键就提交命令了，只要按回车键的时候输入的语句里没有；、\g或\G这些语句结束符号，该语句就算是没有结束。比如上面的语句可以写成： 123456789101112mysql&gt; show -&gt; tables -&gt;;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 3、可以一次提交多个命令 ​ 我们可以在一条语句里面写多个命令（命令之间用上面说的结束符间隔，但记住在写完前不要回车），只要没按回车键，就不会提交命令，如： 1234567891011121314151617181920212223mysql&gt; SELECT NOW(); SELECT NOW(); SELECT NOW();+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)mysql&gt; 4、使用 \c 放弃本次操作 ​ 如果你想放弃本次编写的命令，可以在输入的命令后边加上\c，比如 12mysql&gt; SELECT NOW()\cmysql&gt; 如果不使用\c，那客户端会以为这是一个多行命令，还在一直傻傻的等你输入命令。 注意：\c在Navicat第三方软件中不能用，只能用于cmd窗口中。 5、大小写 ​ MySQL默认对命令的大小写并没有限制。但是如果是表、列的名称就会对大小写敏感了。 6、退出MySQL 12mysql&gt; exitBye]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL密码错误如何修改？]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[​ 前两天我在用MySQL的时候，出现了一个小问题：就是我在注册完windows服务后，然后用net start MySQL80登录到数据库服务器，却无法使得客户端连接到服务器，即在输入完mysql -uroot -p后，会报如下的错误： (这种问题一般是由于密码错误引起的) ​ 于是我就查了一个解决方法，特此记录一下： 1、首先打开一个cmd窗口A： 首先关闭MySQL服务器 1net stop MySQL80 无密码启动MySQL服务 1mysqld --console --skip-grant-tables --shared-memory 2、再开一个cmd窗口B： 无密码登录（密码处直接enter） 12mysql -uroot -p//注意下面出现密码时，直接enter即可连接至MySQL 免密码登录设置空密码 ​ 设置空密码 1UPDATE mysql.user SET authentication_string=&apos;&apos; WHERE user=&apos;root&apos; and host=&apos;localhost&apos;; ​ 刷新 1flush privileges; 设置加密的密码 ​ 以caching_sha2_password加密密码并设置 1ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;; ​ 刷新 1flush privileges; 关闭上面打开的两个cmd窗口。然后再打开一个cmd窗口，启动mysql服务：net start mysql80。然后再正常的用刚才重新设置的密码登录即可。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初始化与启动那些事]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL采用客户端/服务端架构，即它是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可以有多种形式，比如手机APP，电脑软件或者网页版微信。每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器程序，我们平时操作微信其实都是用客户端来和这个服务器来打交道。 ​ MySQL的使用过程大概为：它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器程序就响应这些请求，从而操作它维护的数据。日常使用MySQL的场景一般是这样的： 启动MySQL服务器程序 启动MySQL客户端程序并连接到服务器程序 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。 MySQL默认安装位置：C:\Program Files\MySQL\MySQL Server 8.0\，也可以自定义安装路径，为了方便就按照默认路径来安装吧~ 如何启动MySQL服务器程序？​ 这里以windows系统为例介绍。在windows系统下提供了手动启动和以服务的形式启动两种启动方式。 以服务的形式启动 ​ 什么是windows服务呢？如果需要长时间的运行某个程序，而且需要在计算机启动的时候启动它，一般我们都会把它注册为一个windows服务，操作系统会帮助我们管理它。 在MySQL根目录下(C:\Program Files\MySQL\MySQL Server 8.0)手动创建一个data文件夹 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld install MySQL80 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld --initialize-insecure --user=mysql80 打开MySQL服务器程序： 12net start MySQL80 //打开net stop MySQL80 //关闭 手动启动 ​ MySQL安装目录下的bin目录下的mysqld可执行文件代表着服务器程序，我们运行这个可执行文件就会启动MySQL服务器。 ​ MySQL服务器运行过程中严重依赖一个称之为数据目录的路径，不过我们安装MySQL时使用的MySQL Installer把这个数据目录的路径设置为了： 1C:\ProgramData\MySQL\MySQL Server 8.0\data 当然不同版本的MySQL Installer可能将数据目录的路径设置为不同的值。 ​ 在使用mysqld可执行文件启动MySQL服务器程序时，它默认并不会将上述路径设置为数据目录的路径，此时需要我们在启动MySQL服务器时显式地指定一个称之为datadir的参数，该参数就代表着数据目录的路径，所以使用下面的命令启动MySQL服务器： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; 特别要注意的是，当我们按下回车键后，cmd命令窗似乎卡住不动了，这就意味着MySQL服务器启动了，如果此时我们把这个cmd命令窗关掉，或者按下Ctrl+C键，就会停止MySQL服务器程序的运行。因此，还是推荐使用windows服务的方式来启动或停止MySQL服务器程序。 ​ 如果想查看使用mysqld启动MySQL服务器的过程中输出的日志信息，可以在上述命令后边加上—console： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; --console 如何启动MySQL客户端程序？​ 在服务器程序启动之后（不管是使用mysqld可执行文件启动的还是使用Windows服务的方式启动的），就可以接着启动客户端程序来连接到这个服务器喽。bin目录下有许多客户端程序，比方说mysqladmin、mysqldump、mysqlcheck等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件mysql.exe，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求以及接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下： 1mysql -h主机名 -u用户名 -p密码 参数意义： 参数名 含义 -h 表示启动服务器程序的计算机的域名或者IP地址，如果服务器程序就运行在本机的话，可以省略这个参数，也可以填localhost或127.0.0.1。也可以写成—host=主机名 -u 表示用户名，作为超级管理员的我们的用户名是root。也可以写成—user=root -p 表示密码。也可以写成—password=密码 连接注意事项 最好不要再一行命令中输入密码 这样容易导致密码泄露，可以这样写 1mysql -hlocalhost -uroot -p 如果非要显示的把密码写出来，那密码值和-p之间不能有空格，其他参数之间可以有空格。且各个参数的摆放顺序没有硬性规定。 如果你的服务器和客户端安装在同一台机器上，-h参数可以忽略，就像这样 1mysql -uroot -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客如何迁移至其它电脑]]></title>
    <url>%2F2019%2F07%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[​ 当你在一台电脑上写博客写的蛮爽的，但突然有一天你的电脑坏了或者被偷了咋办？你那些本地的博客可咋整！一想到这种有可能发生的危险，我就夜不能寐呀。于是我就开始疯狂地查找资料，但网上的资料良莠不齐。于是本人就自己慢慢的摸索嘛，这是一个程序员最基本的素质(其实还是自己太菜了)。下面我就把我的总结写一下，希望能对以后的自己和大家有帮助。 1、在新电脑上安装NodeJs和Git​ 这一步很简单，具体怎么安装，可以参见我的上一篇博文：利用hexo框架搭建个人博客(手把手教学) 2、GitHub新建分支​ 在pringce.github.io仓库下： 这里的分支名可以任意设置。 3、设置分支为默认仓库当前仓库-&gt;Settings-&gt;Branches-&gt;Default Branch 4、clone至本地​ 将该分支克隆至本地 1git clone https://github.com/pringce/pringce.github.io.git ​ cd进入 clone 下来的pringce.github.io文件夹，在此文件夹目录下执行git branch命令，应该是新建的分支名 。 5、新电脑生成ssh key并添加至GitHub​ 依次按照下述步骤生成本机ssh key： 1git config --global user.email "GitHub注册并验证时的邮箱" 1git config --global user.name "GitHub用户名" 1ssh-keygen // 一直按enter就行 在本机目录“C:\Users\10530\.ssh”会生成两个文件：id_rsa(私钥)和id_rsa.pub(公钥)。打开id_rsa.pub，复制里面的内容到GitHub: Settings -&gt; SSH and GPG keys -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key 测试是否成功： 1ssh -T git@github.com 输出 You’ve successfully authenticated 表示添加key 成功。 6、安装hexo1npm install hexo-cli -g 7、将原博客文件拷贝至pringce.github.io文件夹​ 将原博客文件夹下的文件拷贝至pringce.github.io，需要拷贝6个：_config.yml（站点配置文件）、themes\（主题）、source\（博客源文件）、scaffolds\（文章的模板）、package.json、.gitignore。 此时，我们不需要再用hexo init来生成博客了，因为需要的文件我们已经拷贝过来了。 8、提交本地至new分支​ 进入pringce.github.io文件夹，依次执行 1git add . 1git commit -m &quot;新电脑&quot; 1git push 这样，master分支用于保存博客静态资源，提供博客页面供人访问；new分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突。 9、安装hexo依赖的包1npm install ​ 所依赖的包都在上一步中的package.json备份文件里，所以直接这一个命令就可以了，就可以把你以前配置的那些包都安装上了。 10、更新博客现在，在GitHub上的仓库就有两个分支，一个new分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 现在我们既可以在旧电脑上更新博客，也可以在新电脑上更新博客了。 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 首先git pull下拉，更新合并本地内容 本地修改编辑博客 依次执行git add .、git commit -m “…”、git push指令将改动推送到GitHub（此时当前分支应为new）； 然后才执行hexo g -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 具体步骤如下所示： 1git pull 1hexo new &quot;name&quot; 1hexo clean 1hexo g 1hexo s(测试时候在localhost看一下) 1hexo d(部署) 1git add . 1git commit -m &quot;新电脑&quot; 1git push //保证new分支版本为最新 本地资料丢失后的流程 如果此时你的电脑全坏了，并且你的本地博客资料全部丢失了，那么该怎么办呢？ 获得新电脑的ssh key，然后添加到GitHub 将new分支clone至本地： 1git clone https://github.com/pringce/pringce.github.io.git 在本地新拷贝的pringce.github.io文件夹下通过Git bash依次执行下列指令，安装hexo依赖的包（如果是整个电脑丢失了，还需要提前安装好NodeJS、Git和hexo） 1npm install 所依赖的包都在新拷贝的package.json文件里，所以直接这一个命令就可以了，就可以把你以前配置的那些包都安装上了 然后就可以根据上述步骤10里面的流程更新博客了 好啦，心理的最大隐患解除了，可以安心睡觉啦。大家晚安！！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树全解析]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言​ 其实大家都说决策树简单，但个人觉得如果想学好这个算法其实还是需要下一些功夫的。决策树是一种基本的分类与回归方法(不要觉得决策树只能分类哦，它也可以做回归的)。 ​ 为了方便下面的讨论，我们先做一下说明： ​ 假设有一组训练数据 D=(x1,y1),(x2,y2),\cdots,(xn,yn)​ 表示有n个样本，样本共分为K类情况下，yi的取值来自K个类别值 (C1,C2,\cdots,Ck) ​ 另外，无论是ID3树、C4.5树还是CART树都是差不多的，都由特征选择(分裂特征选择算法)、树的生成和剪枝组成。它们之间的区别主要是特征选择和剪枝算法不同，这些我们后面会详细讨论，这里先留个伏笔。 ID3树​ 在介绍ID3决策树之前，我想先说一个概念：信息增益。 ​ 一个离散型随机变量x的概率分布为 P(x=x_i)=p_i​ ，则x的信息熵定义为 H(x)=-\sum_{i=1}^{n}{p_i}​ 数据集的熵表征其类别的不确定程度，而数据集关于某个特征的条件熵则表征着给定某个特征后，其类别的不确定程度： 数据集的熵—条件熵 = 该特征使数据集不确定性减小程度 设数据集D的熵为H(D)，关于特征Am的条件熵为H(D|Am)，因此可以获得信息增益为 g(D|A_m)=H(D)-H(D|A_m)其中， H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|}}log_2\frac{|C_k|}{|D_k|} H(D|A_m)=\sum_{i=1}^{K}{\frac{|D_i|}{|D|}}H(D_i)​ Di 表示训练样本中特征A取值为 ai 的样本点集合(比如说特征A有三个可能的取值，则K为3)。 ID3决策树构建​ 自根节点开始，选择信息增益最大的特征作为节点的分类特征，并根据该特征的可能取值将训练数据分配到不同的子节点(对子节点进行同样的操作)。 ​ 若子节点的所有样本属于同一类别或该子节点处所有特征的信息增益均小于给定阈值或无可供选择的特征，此时我们判定该子节点为一个叶节点，将该叶节点的样本数量最多的类别作为该叶节点的类别。 ​ 算法步骤如下： 若D中样本特征为空，那么树T为一棵单节点树，将样本数量最大的类别作为节点类别，返回T。否则转到第二步； 计算D关于所有特征的信息增益，若信息增益均小于某一阈值，则T为单节点树。否则转到第三步； 选择信息增益最大的特征作为分裂特征，依据该分裂特征的所有可能取值建立相应子节点。若子节点样本全为同一类别，则子节点为叶节点。若均为叶节点，返回T。否则转到第四步； 对非叶节点 i，以 Di 为训练集，将特征集减去刚才的分裂特征(这里特别需要注意一点，如果该特征是类别特征，则在分裂完成后删除该特征；如果为连续特征，则不删除该特征)，以得到新的特征集，然后递归调用第一步至第三步。 总结 ID3树在选取分裂特征时采用信息增益原则(其实个人理解，无论是ID3、C4.5还是CART树，在选取分裂特征时，基于的总原则都是使分裂前后的数据复杂度减少程度最多，因为选取该特征才能使得这样构建出来的决策树分类或回归效果最好)。 ID3树后剪枝的策略是PEP(悲观误差剪枝)，这里后面再介绍，这里先占个坑哈哈哈。 C4.5树​ 上述ID3树采用的是信息增益来进行节点分裂特征的选取。信息增益原则对于每个分支节点，都会乘以其权重，也就是说，由于权重之和为1，所以分支节点分的越多，即每个节点数据越少，纯度可能越高。这样会导致信息增益准则偏爱那些取值数目较多的属性。 ​ 为了解决该问题，引入了信息增益率，这个也就是C4.5树的分裂准则。C4.5树的基本构建流程与ID3树类似，唯一的区别就是C4.5树采用信息增益率进行特征选择，而ID3树采用信息增益进行特征选择。 ​ 信息增益率的定义如下： G_{ratio}=\frac{g(D|A_m)}{H_{A_m}(D)}​ 其中， H_{A_m}(D)=-\sum_{i=1}^{K}\frac{|D_i|}{|D|}log2{\frac{|D_i|}{|D|}}​ 需要注意的是，信息增益率原则可能对取值数目较少的属性更加偏爱。因此，C4.5并不是直接选择增益最大的候选划分属性。为了解决这个问题，C4.5采用了一种启发式算法，可以先从候选划分属性中找出信息增益在平均值以上的属性，再从中选择信息增益率最高的。 CART树​ 这里先强调一点，CART树是二叉树。与ID3和C4.5的决策树所不同的是，ID3和C4.5生成的决策树可以是多叉的，每个节点下的叉树由该节点特征的取值种类而定，比如特征年龄分为(青年，中年，老年)，那么该节点下可分为3叉。而CART决策树为二叉树，内部节点特征取值为“是”和“否”。左分支取值为“是”，右分支取值为“否”。因此在搜索分裂特征时，是递归地二分每一个特征。个人理解为不仅要遍历每一个特征，还要遍历每一个特征的二分取值，等于是做了一次双层遍历。相比于ID3和C4.5要更加复杂一些。 ​ 另外，我们还需要注意一点，ID3和C4.5只能用于分类，而CART树既可以用于分类，也能用于回归。 ​ CART树的基本构建流程与ID3树和C4.5树类似。唯一的区别就在于特征选择准则不同，另外CART树不仅要选择最优特征，还要选择最优二值切分点。别的都一样哈哈哈！！ ​ CART分类树特征选择​ CART分类树通过基尼指数选择最优特征，同时决定该特征的最优二值切分点，而ID3和C4.5直接选择最有特征，不用划分二值点。 ​ 这里先介绍一下基尼指数，我个人的理解是基尼指数和前面的信息熵的概念是一样的，都是表征数据集的不纯度，因此我们如何选择最优特征和最优二值切分点呢？也就是分裂后如何使基尼指数下降最大！ ​ 分类问题，假设有数据集D有K个类，样本点属于第k个类的概率为 pk，则基尼指数定义为 Gini(D)=1-\sum_{k=1}^{K}p_k^2​ 在特征A下，集合D的基尼指数定义为 Gini_A(D)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)​ 那么如何选择最优特征和最优二值切分点呢？就是使切分前后的不确定性下降最大！即切分前的基尼指数和在特征A下切分后的基尼指数之间的差越大，越应该为最优特征和最优二值切分点。同理也可以得到，在特征A下切分后的基尼指数越小，越应该为最优特征和最优二值切分点。 CART回归树特征选择​ 跟CART分类树大致相同，区别主要在以下几点： ​ 分裂准则：选择特征A以及对应的属性值s将当前节点分到两个区域 R1 和 R2 中， R_1={(x|x_is)}​ 如何选择呢？就是使上述两个区域的均方误差和最小！ ​ 最终预测值：最终节点值为该节点下所有数据的平均值。 剪枝​ 剪枝很好理解，它的目的就是防止过拟合。它主要分为预剪枝和后剪枝。 预剪枝 通过提前停止树的构建而对树剪枝。一旦停止，节点就是叶节点。 停止决策树生长最简单的方法有： 定义一个高度，当决策树达到该高度时就停止决策树的生长； 当节点实例个数小于某一阈值； 当分裂增益小于某一阈值。 后剪枝 ​ 它首先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的结点子树用叶子结点来代替，该叶子的类标号用该结点子树中最频繁的类标记。相比于先剪枝，这种方法更常用，正是因为在先剪枝方法中精确地估计何时停止树增长很困难。 ​ 后剪枝方法主要有以下几个方法： ​ Reduced-Error Pruning(REP，错误率降低剪枝） ​ Pessimistic-Error Pruning(PEP，悲观错误剪枝） ​ Cost-Complexity Pruning（CCP，代价复杂度剪枝) REP REP方法是一种最简单的后剪枝方法，对每个非叶子节点，从下往上遍历，尝试将该子树从叶子节点代替。然后利用验证集进行验证，看精度是否提升。若提升，则剪枝。这种方法一般不采用。 PEP PEP的策略主要用于ID3和C4.5树。悲观错误剪枝法是根据剪枝前后的错误率来判定子树的修剪。 把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代的话，在训练集上的误判率肯定是上升的，但是在新数据上不一定。于是我们需要把子树的误判计算加上一个经验性的惩罚因子。 对一个叶子节点，有n个样本，其中e个错误，则该叶子节点错误率为 (e+0.5)/n其中，0.5为惩罚因子 对一棵子树，有L个叶子节点，则该子树的错误率为 err\_ratio=\frac{(\sum_{i=1}^{L}e_i)+0.5L}{\sum_{i=1}^{L}n_i}这样的话，我们可以看到一颗子树虽然具有多个子节点，但由于加上了惩罚因子，所以子树的误判率计算未必占到便宜。 我们可以得到子树的错误次数均值和标准差 err\_mean=err\_ratio*\sum_{i=1}^{L}n_i err\_std=\sqrt{err\_ratio*\sum_{i=1}^{L}n_i*(1-err\_ratio)}当把子树替换成叶子节点后，该叶子节点的错误率和错误次数均值为 err\_ratio^{'}=\frac{(\sum_{i=1}^{L}e_i)+0.5}{\sum_{i=1}^{L}n_i} err\_mean^{'}=err\_ratio^{'}*\sum_{i=1}^{L}n_i剪枝条件为： err\_mean+err\_std>=err\_mean^{'}PEP的缺点： PEP算法采用的是自上而下的剪枝策略，这种剪枝会导致和预剪枝同样的问题，即剪枝过度。 CCP CCP的策略主要用于CART树。 代价指在剪枝过程中因子树 Tt 叶节点替代而增加的错分样本，复杂度表示剪枝后子树 Tt 减少的叶结点数，则定义每个非叶节点剪枝后树的复杂度降低程度与代价间的关系： α(t)=\frac{C(t)-C(T_t)}{|T_t|-1}其中， C(t) = r(t) * p(t)代表剪枝后叶子节点的误差代价 对于分类树，r(t) 为该节点的错误率；对于回归树，代表该节点的均方误差。 p(t) 为该节点数据占总数据的比例。 C(T_t)=\sum_{i=1}^{m}r_i(t)p_i(t)代表剪枝前的子树误差代价 对于分类树，ri(t) 为该子树某叶子节点的错误率；对于回归树，代表该子树某叶子节点的均方误差。 pi(t) 为该子树某叶子节点占总数据的比例。 CCP剪枝算法分为两个步骤： 对于完全决策树 T 自下而上的计算每个非叶结点的 α 值，然后自上而下的循环(注意，每剪枝一次，就重新计算表面误差增益率，再循环第一步)剪掉具有最小 α 值的子树(自上而下代表若有多个非叶子节点的表面误差率增益值相同小，则选择非叶子节点中子节点数最多的非叶子节点进行剪枝)，直到剩下根节点。在该步可得到一系列的剪枝树序列｛T0，T1，T2……Tn｝,其中 T0 为原有的完全决策树，Tn为根结点，Ti+1为对 Ti 进行剪枝的结果； 从子树序列中，根据真实的验证集误差选择最佳剪枝后决策树。 例. 下图是一棵子树，设决策树的总数据量为40 C(t)=\frac{8}{18}*\frac{18}{40}=\frac{1}{5} C(T_t)=\frac{1}{3}*\frac{3}{40}+\frac{4}{9}*\frac{9}{40}+\frac{1}{6}*\frac{6}{40}=\frac{6}{40} α(t)=\frac{\frac{1}{5}-\frac{6}{40}}{3-1}=\frac{1}{40}​ 好啦，到了这里，基本就把所有的决策树知识说完啦！希望能对大家有帮助。]]></content>
      <categories>
        <category>机器学习算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo框架搭建个人博客]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%88%A9%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言​ 本文是在Windows 10环境下搭建个人博客，对于Linux和Mac环境，搭建工作基本类似，区别无非在于个别命令行指令的区别，读者只需作相应的调整即可。 1. 安装NodeJs​ hexo是基于NodeJs环境的静态博客，里面的npm工具很有用（个人感觉类似于python里面的pip或者anaconda里面的conda，是一个包管理工具），所以说NodeJs是搭建个人博客的第一步。 下载地址：https://nodejs.org/en/ 下载下图的10.16.0 LTS即可。 然后点击下载的安装包，无脑点yes安装即可。至此NodeJs已经全部安装完成。 2. 安装Git Bash​ 由于本人使用的是Windows环境，cmd指令过于难用（也难怪众多开发者投入了Linux的怀抱）。所以本人下载了Git Bash（其实也就是下载了Git工具）。在网上搜索Git可以下载一个下面这个应用程序： ​ 然后依旧无脑点yes，安装完成后，在左面点击鼠标右键，如果出现了Git Bash和Git GUI即代表Git安装成功。 ​ 然后打开Git Bash可以查看NodeJs和npm的版本： NodeJs版本 1$ node -v npm版本 1$ npm -v 3. 安装hexo​ 我们是需要借助npm来安装hexo框架的。但是由于墙的原因，国内使用npm的下载速度很慢。因此我们需要更换源（使用淘宝的那个源），利用npm来安装一个cnpm。安装完成后，后面完全可以用cnpm全面取代npm。 ​ 如何安装cnpm？ 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 安装完成后，可以查看一下cnpm的版本 1$ cnpm -v ​ 随后，开始正式安装hexo框架 1$ cnpm install -g hexo-cli ​ 如何判断hexo是否安装成功，我们只需要查看hexo的版本，如果出现版本信息，则代表hexo安装成功 1$ hexo -v 4. 开始正式搭建博客​ 首先我们需要先建立一个空的目录，存储我们的博客信息。这样的好处就是，一旦这个博客出错了或者你不想要了，直接把这个文件夹删除即可，不会影响其他的文件，保持独立性。 12$ mkdir blog$ cd blog ​ 随后在blog目录下利用hexo生成博客，很简单 1$ hexo init ​ 可以看到，生成完成后会出现下面这些文件 ​ 随后启动博客 1$ hexo s ​ 可以看到，博客可以在本地的4000端口进行访问 ​ 我们利用浏览器打开该端口，即可访问到我们最初始的博客。该博客默认有一篇hello word的博文 ​ 随后我们可以新建一篇文章，里面写上我们想要的内容即可。如何新建一篇文章？ 1$ hexo new &quot;我的第一篇文章&quot; ​ 生成完成后，便可以在blog/source/_post目录下找到我们生成的这篇文章，文件名为”我的第一篇文章.md”。随后便可以用Typora来写该博客了（markdown语法）。 ​ 因为我们现在新建了一篇文章，如何把它上传呢？（即在浏览器中也可以看到改文章）。这里就要用到hexo中著名的“素质三连”指令了 123$ hexo clean (清理)$ hexo g (生成)$ hexo s (启动) ​ 随后便可以在本地4000端口看见我们刚才新建的那篇文章了。 一切都是这么简单，一切都是这么优雅！ 5. 远端部署​ 我们写个人博客的目的不是为了只自己访问，也希望别人能看见，因此需要部署到远端服务器。这里有一种免费的部署方式，即把我们的博客部署到github上公开使用。 5.1 新建仓库 ​ 一定要注意仓库的命名方式，仓库的名称一定要和你的github昵称保持一致，否则将无法访问。例如我的github昵称为pringce，那么仓库的名称一定要命名为pringce.github.io。如下图 5.2 安装Git部署插件1$ cnpm install hexo-deployer-git --save 5.3 配置config文件​ 在我们的blog目录下，找到_config.yml这个文件，然后到文件的最底部，写入如下配置 5.4 部署到远端1$ hexo d ​ 随后输入”https://pringce.github.io&quot;，即可访问我们部署到远端服务器上的博客了。至此任何人都可以访问你的博客了，博客的部署工作完成。 一切都是这么简单，一切都是这么优雅！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
