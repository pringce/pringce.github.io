<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[class文件反汇编]]></title>
    <url>%2F2020%2F03%2F16%2Fclass%E6%96%87%E4%BB%B6%E5%8F%8D%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[jdk自带的很多命令都很有用，今天就来简单介绍下jdk的javap命令，javap是jdk自带的反汇编器，使用此命令， 可以将 Java文件编译后的class文件反汇编进而看到 Java编译器给我们生成的字节码，以便我们能更好的分析代码 的执行过程和运行流程。 使用方法： 先写好一个demo.java文件 在cmd中进入到该java文件的目录下，然后使用javac demo.java将其编译，这时你会在当前目录看到一个demo.class文件 之后再cmd中输入javap -c demo命令，将其字节码文件进行反汇编。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从JVM角度看Java多态]]></title>
    <url>%2F2020%2F03%2F15%2F%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E7%9C%8BJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态举例如下： 12345678910111213141516171819202122232425262728293031public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); // 调用子类eat() //f.play(); 编译错误 System.out.println("年龄："+f.age ); // 父类age &#125;&#125; 下面从JVM的角度解释上面这种现象，从下面这句代码切入 1Father f = new Child(); 这句代码首先会执行new Child()，在堆中分配一个对象。当然在分类Child类的实例时，先要通过JVM的类加载器将Child类对应的class文件加载到JVM中，然后JVM根据class文件中的字节流产生一个表示class文件的类型信息结构体。 这个表示class文件的类型信息结构体大概由以下几部分构成： 常量池（较为复杂，存放该类型所用到的常量的有序集合，包括直接常量（字符串、整数、浮点数）和对其他类的字段、方法的符号引用） 类变量（静态变量，只包含本类所定义的，不包含继承自父类的，下面字段信息、方法信息类似） 字段信息 方法信息 类型信息 指向类加载器的引用 指向class实例的引用 方法表 之后，JVM会根据上面这个结构体生成一个叫做虚方法表(vtable)的东西。这个方法表是实现Java多态的一个关键。方法表中欧冠包含的是实例方法（就是相对于静态方法而言的，用对象访问的那些方法，即不包含static、final和private修饰的方法）的直接饮用，也就是说通过这个方法表就能够访问到该类的实例方法。 而且，这些实例方法不仅包括本类的方法，还包括其父类的实例方法，以及父类的父类的实例方法（就是一直到Object）。 方法表中的这些直接应用会指向到JVM中表示类型信息的那个结构体（就是上面那个结构体）的相应的方法信息（就是上面结构体中第4块的某个位置），当然这只是本类的方法，方法表中还有父类的方法，相应地指向父类类型信息结构体的具体位置。如图所示 上面提到过，方法表中不仅包括本类的方法，还包括父类的方法，方法表值这样产生的，以Child类的方法表为例： 首先方法表中，会产生指向继承自Object类的方法的引用，这些包括指向toString的和指向equals的，当然Object中还包括很多方法，这里就不写了 然后方法表中产生指向继承自Parent类的方法的引用，这包括eat， 最后产生指向本类的方法的引用。 这里需要注意的一点是，当Child类的方法表产生指向Parent类中的方法的引用时，会有一个指向eat方法的引用，最后产生指向本类的方法的引用时，也有一个指向eat的引用，这时候，新的数据会覆盖原有的数据，也就是说原来指向Parent.eat的那个引用会被替换成指向Child.eat的引用（占据原来表中的位置）。所以我们看到在Child类的方法表中指向的是Child.eat而Parent类的方法表中指向的是Parent.eat。子类的方法表中就没有指向Parent.eat的引用了。(重写的底层实现) 而且还要注意一个特点就是，Parent和Child的方法表中，指向eat的引用在表中的偏移量是一样的，都是第三个位置。（这是因为子类eat方法覆盖掉了父类eat方法，占据了原来父类eat方法的引用在表中的位置） 这里再多说一句，表示类型信息的结构体（非方法表）中的方法信息，只包含本类特有的，或者是重写的方法信息，没有父类的方法信息。 这里介绍一下方法表的两个特点： 方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。 方法表满足两个性质： 子类方法表中包含父类方法表中的所有方法 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。（即如果子类方法表和父类方法表中同时含有一个函数，那么该函数在各自方法表中的索引值相同） 了解了方法区的结构后，再来看堆中对象的结构 从图中可以看出，堆中的实例对象不仅包含本类实例变量，也包含父类实例变量，分配不同的内存，不存在冲突。本类实例变量分配在本类实例变量区，父类实例变量分配在父类实例变量区。子类实例变量区和父类实例变量区不冲突不重合，都存在于该实例对象堆内存空间中。 由于类的实例变量属于类对象实例，所以分配在堆内存中。静态变量属于类，不属于类实例，所以分配在方法区中。 接下来是栈区，产生Father类型的引用，这个引用指向堆区中的Child类的实例。 这里需要解释一下Father f的含义，我们知道f表示一个引用，这个引用指向堆中的Child类的实例，说白了就是一个地址(其实Java中没有地址，因为地址不安全)，这个地址指向堆中的Child的类的实例 下面探讨一下如何调用方法及变量？1. 调用static方法、final方法和private方法1234567891011class Father&#123; public static void f1()&#123; System.out.println("Father— f1()"); &#125; &#125;public class StaticCall&#123; public static void main()&#123; Father.f1(); //调用静态方法 &#125;&#125; 上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令： 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: Father; 紧接着JVM会加载、链接和初始化Father类; 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫常量池解析 ，以后再次调用Father.f1()时，将直接找到f1方法的字节码; 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。 通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做静态绑定机制 。 除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。 2. 调用实例方法12345678910111213141516171819202122class Father&#123; public void f1()&#123; System.out.println("father-f1()"); &#125; public void f1(int i)&#123; System.out.println("father-f1() para-int "+i); &#125; &#125; //被调用的子类class Son extends Father&#123; public void f1()&#123; //覆盖父类的方法 System.out.println("Son-f1()"); &#125; &#125; //调用方法public class AutoCall&#123; public static void main(String[] args)&#123; Father father=new Son(); father.f1(); &#125;&#125; 对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令： 12345670 new Son [13] //在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈3 dup4 invokespecial #7 [15] // 调用初始化方法来初始化堆中的Son对象7 astore_1 //弹出操作数栈的Son对象引用压入局部变量1中8 aload_1 //取出局部变量1中的对象引用压入操作数栈9 invokevirtual #15 //调用f1()方法12 return 其中invokevirtual指令的详细调用过程是这样的： invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名:Father。这是因为调用方法f1的类的对象father声明为Father类型。 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项记录到AutoCall类的常量池中第15个常量表中(常量池解析 )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间 上述即为多态的实现机制，即动态绑定。 3. 调用变量1234567891011// Father 父类public class Father&#123; int age = 10;&#125;public class Son extends Father&#123; int age = 20;&#125;// Son 子类Father f = new Son();System.out.println(f.age); // 10 这里主要涉及到 Java里面一个字段隐藏的概念。父类和子类定义了一个同名的字段，不会报错。但对于同一个对象，用父类的引用去取值，会取到父类的字段；用子类的引用去取值会取到子类字段的值。在实际开发中，要尽量避免子类和父类使用相同的字段名，否则很容易引入一些不容易发现的bug。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2020%2F03%2F13%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是OOP？ 面向对象编程：Object-Oriented Programming 对现实世界建立计算机模型的一种编程方法 面向对象的三大特性：封装、继承、多态。 对象的概念 现实世界 计算机模型 Java代码 人 类/class class Person{} 小明 实例/ming Person ming = new Preson() 小红 实例/hong Person hong = new Person() 现实世界 计算机模型 Java代码 书 类/class class Book{} Java核心技术 实例/book1 Book book1 = new Book() Java编程思想 实例/book2 Book book2 = new Book() 对象/实例（class/instance）class是对象模板 class定义了如何创建实例 class名字就是数据类型 instance是对象实例 instance是根据class创建的实例 可以创建多个instance 各个instance类型相同，但各自属性可能不同 定义class 一个class可以包含多个field（字段），field用来描述一个class的特征 class实现了数据封装 12345678910public class Person&#123; public String name; public int age;&#125;public class Book&#123; public String name; public String author; public String isbn;&#125; 创建实例 new操作符可以创建一个实例 定义一个引用类型变量来指向实例 通过变量来操作实例 通过变量.字段来访问实例字段 12345678public class Person&#123; public String name; public int age;&#125;Person ming = new Person();ming.name = "小明";ming.age = 12; 总结 class和instance是”模板”和”实例”的关系 class是数据类型，instace是数据 class定义了field，每个instance都会拥有各自的field 变量指向instance，并通过变量.字段来访问实例字段 指向instance的变量都是引用变量 数据封装 一个class可以包含多个field 直接将field用public暴露给外部可能破坏了封装 用private修饰field可以拒绝外部访问 当field被设置为private时，可定义public方法间接修改field 123456789101112public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125;&#125;Person ming = new Person();ming.name = "小明"; //编译错误ming.setName("小明"); //正确 方法 外部代码不可访问private字段 外部代码只能通过调用public方法间接设置和获取private字段 public方法封装了数据访问 通过方法访问实例字段更安全 通过变量.方法名()来调用实例方法 定义方法 public修饰符 方法返回值 方法名称 方法参数列表 方法返回值通过return语句实现，如果没有返回值（void）可以省略return 12345678910111213141516public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String getName()&#123; return this.name; &#125;&#125; 方法内部可以使用隐式变量this，this指向当前实例，this.field可以方法当前实例的字段 在不引起歧义的情况下，可省略this 123public String getName()&#123; return name; //this.name &#125; 局部变量名优先。当字段名和局部变量名重名时，编译器优先查找局部变量名 123public void setName(String name)&#123; this.name = name; &#125; 调用方法 实例变量.方法名(参数) 可以忽略方法返回值 123Person ming = new Person();ming.setName("小明"); // 没有返回值String s = ming.getName(); //返回值为String 方法参数 方法参数用于接收传递给方法的变量值 方法参数可为基本类型参数或引用类型参数。可简单理解诶基本类型是值传递，引用类型是址传递 private方法 外部代码不可访问private方法 内部代码可以调用自己的private方法 构造方法前面可以看到，初始化实例需要三行代码 1234Person ming = new Person(); // 创建对象实例// 初始化对象实例ming.setName("小明");ming.setAge(12); 能否在创建对象实例时就把内部字段全部初始化为合适的值？如下所示 1Person ming = new Person("小明",12); 答案当然是肯定的！需要引入构造方法。构造方法用于初始化实例 构造方法可以在创建对象实例时初始化对象实例 构造方法名就是类名 构造方法的参数没有限制 构造方法没有返回值(也没有void) 必须用new操作符调用构造方法 12345678910public class Person&#123; private String name; private int age; // 构造方法 public Person(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125; 如果一个类没有定义构造方法，编译器会自动生成一个默认构造方法： 无参数 无执行语句 123456public class Person&#123; private String name; private int age; public Person()&#123; &#125;&#125; 如果自定义了构造方法，编译器就不再自动创建默认构造方法 12345678910public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125;Person ming = new Person(); // 编译错误 初始化顺序： 先初始化字段 没有赋值的字段初始化为默认值：基本类型=0，引用类型=null 再执行构造方法的代码 123456789public class Person&#123; private String name = "unnamed"; // 第一顺序 private int age; // =0,第二顺序 public Person(String name, int age)&#123; // 第三顺序 this.name = name; this.age = age; &#125;&#125; 可定义多个构造方法，编译器通过构造方法的参数数量、位置和类型区分 1234567891011121314151617181920public class Person&#123; private String name; private int age; // 构造代码: new person("xiaoming",12); public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; // 构造代码: new person("xiaoming"); public Person(String name)&#123; this.name = name; this.age = 18; &#125; // 构造代码: new person(); public Person()&#123; &#125;&#125; 一个构造方法可以调用其他构造方法，便于代码复用。调用其他构造方法的语法是this(…) 1234567891011121314151617public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public Person(String name)&#123; this(name,18); &#125; public Person()&#123; this("unnamed"); &#125;&#125; 方法重载定义方法重载（Overload）是指： 多个方法的方法名相同 但各自参数不同 参数个数不同 参数类型不同 参数位置不同 方法返回值类型通常是相同的 方法重载的目的 相同功能的方法使用统一名字 便于调用 总结 重载方法应该完成相同的功能，参考String的indexOf() 重载方法主要依靠参数类型和数量区分 不要去交换参数顺序区分 indexOf(String str, int fromIndex) indexOf(int fromIndex, String str) 重载方法返回值类型应该相同 继承1234567891011public class Person /* extends Object */ &#123; private String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; private int score; public void setScore(int score) &#123;...&#125; public int getScore() &#123;...&#125;&#125; Student可以从Person继承 继承使用关键字extends Student获得了Person所有的功能 Student只需要编写新增的功能 Person：超类(super)、父类、基类 Student：子类(subclass)、扩展类 继承树 Object是Java提供的所有类的根类，如果没有写extends，则默认继承自Object类。 Java只允许class继承自一个类 一个类有且仅有一个父类（Object除外） protected Person类定义的private字段无法被子类访问 用protected修饰的字段可以被子类访问 1234567891011public class Person /* extends Object */ &#123; protected String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; public String hello()&#123; return "hello"+this.name; // 编译通过 &#125;&#125; super继承关系中的构造方法 123456789101112public class Person&#123; public Person() &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student()&#123; super(); System.out.println("student"); &#125;&#125; super关键字表示父类(超类) 子类的构造方法的第一行语句必须调用父类的构造方法，调用方式为super() 没有super()时编译器会自动生成super() 如果父类没有默认构造方法，子类就必须显式调用super() 12345678910111213public class Person&#123; public Person(String name) &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student(String name)&#123; //super(); // 这种构造会报错 super(name); //这样才正确 System.out.println("student"); &#125;&#125; 向上转型语法规则：&lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;(); 1Person p = new Student(); 此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，不是父类的方法。 此时通过父类引用变量无法调用子类特有的方法 向上转型虽然使代码变得简洁，体现了JAVA的抽象编程思想，但是也出现了上面提到的子类无法调用其独有的方法，这要怎么解决呢？所以就有了与之对应的向下转型，弥补了向上转型所带来的缺陷。 向下转型 向下转型把抽象的类型变成一个具体的子类型 12Person p = new Student();Student s = (Student)p; // 向下转型 向下转型很可能报错：ClassCastException 在向下转型过程中，分为两种情况： 情况一：如果父类引用的对象是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。 情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 instanceof操作符可以判断对象的类型 1234567Person p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // fasleStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // fasle Java中，instanceof运算符的前一个操作符是一个引用变量，后一个操作数通常是一个类（可以是接口），用于判断前面的引用所指向的对象是否是后面的类，或者其子类、实现类的实例。如果是返回true，否则返回false。 多态多态的优点提高了代码的扩展性，前期定义的代码可以使用后期的内容 多态的弊端前期定义的内容不能使用（调用）后期子类的特有方法（就是多态调用的只能是父类）。但如果是继承子类覆盖了父类方法，多态调用的仍是子类的方法！ 多态的类型分为以下两种： 编译时多态：指的是 方法重载。编译时多态是在编译时确定调用处选择那个重载方法，所以也叫 静态多态，算不上真正的多态。所以，一般说的多态都是运行时的多态。 运行时多态：由于 方法重写，所以想要确定引用变量所调用的方法的入口，必须根据运行时的引用变量所指向的实例对象来确定。从而使得同一个引用变量调用同一个方法，但不同的实例对象表现出不同的行为。 多态的前提条件 子类继承父类 子类覆盖父类的方法 父类引用指向子类对象 多态性的实现： 依靠动态绑定； 绑定： 将一个方法调用与方法主体关联起来。 前期绑定： 在程序执行前绑定，由编译器和链接程序完成，C语言的函数调用便是前期绑定。 动态绑定： 也称 后期绑定。在运行时，根据具体的对象类型进行方法调用绑定。除了static方法、final方法（private方法也是final方法），其他方法都是动态绑定； 方法重载、重写与隐藏重载（Overload）方法重载就是在同一个类中，多个方法名称相同但是参数类型或者参数个数不同的方法，与返回值类型和修饰符无关 重写（Override）子类继承父类时，子类的方法名称、参数类型、参数个数与父类完全相同，则认为子类重写了父类的方法。 方法重写规则： 参数列表和原方法完全相同 返回值类型和原方法相同或者为父类返回值类型的子类型 不能比原方法限制更严格的访问级别(举例：父类方法为public，那么子类不能为protected、private) 父类方法被定义为final时，则不能被重写 父类方法被定义为static时，不能被重写，但是可以重写声明一个相同的方法（参考隐藏） 不能抛出新的异常或比原方法更广泛的异常（父类抛出IOException，重写方法不能抛出Exception只能抛出IOException或者IOException子类异常） 方法重写的条件 重写的方法是子类从父类继承下来的实例方法（就是相对于静态方法而言的，用对象访问的那些方法），不能是静态方法 子类重写后的方法的 返回类型 必须是 原父类方法的返回类型的可替换类型 子类重写后的方法的访问权限 不能比 原父类方法的访问权限低； 子类重写后的方不能比父类方法抛出更多的异常； 当重写泛型方法时，先进行类型擦除。再按照上面的4个小点，重写类型擦除后的方法; 可替换类型补充： 对于返回类型是基本类型、void，重写方法的返回类型必须是一样； 对于返回类型是引用类型，返回类型可替换成该类型的 子类型; 12345678910111213141516171819class ParentClass&#123;//父类 public int count() &#123;// return 0; &#125; Object method() &#123; return "aa"; &#125;&#125;class ChildClass extends ParentClass&#123;//子类 public int count() &#123;//重写count()方法，由于返回类型是基本类型，不能变，必须是一致 return 0; &#125; public String method() &#123;//重写method()：访问权限增大，返回类型是Object的子类String return "aa"; &#125;&#125; 隐藏隐藏是针对于父类的成员变量和静态方法而言的。子类中声明了和父类相同的变量名或静态方法(方法名相同、参数列表相同、返回类型相同)则实现了对父类成员变量和静态方法的隐藏。从父类继承下来的成员中，除了部分方法是可以重写外，其余成员都是隐藏，如变量、内部类、静态方法等。 注意：final方法既不能被重写，也不能被隐藏 JAVA中方法和变量在继承时的覆盖和隐藏规则 父类的实例变量和静态变量能被子类的同名变量隐藏 父类的静态方法被子类的同名静态方法隐藏 父类的实例方法被子类的同名实例方法覆盖 换言之，多态是基于重写实现的，针对实例方法。变量、static方法、final方法和private方法不能重写。其中final方法和private方法不能隐藏。 多态举例123456789101112131415161718192021222324252627282930313233343536public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); //f.play(); 编译错误 System.out.println("年龄："+f.age ); &#125;&#125; 结论：当满足Java多态的三个条件时，可以发现f.eat()调用的实际上是子类的eat，但f.age调用的还是父类的age，而f.play()则不会通过编译。(多态实现机制可看另一篇文章：从JVM角度看Java多态)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命令行参数]]></title>
    <url>%2F2020%2F03%2F12%2FJava%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命令行参数定义刚学习Java时，我们都会接触到下面这个简单的程序，我们可以main函数中定义了一个字符串数组参数，这就称为命令行参数，但是我们运行程序时从来没有给这个参数传值，那么我们怎么给这个参数传值呢？ 12345public class hello&#123; public static void main(String[] args)&#123; System.out.println("hello world"); &#125;&#125; 如何传入命令行参数？可以在Eclipse中想main函数传递命令行参数，也可以在dos窗口运行java程序时传入命令行参数。下面分别介绍 在Eclipse中想main函数传递命令行参数 新建Java程序，输入命令行参数 123456public class helloworld&#123; public static void main(String[] args)&#123; for(String arg:args) System.out.println(arg); &#125;&#125; 从窗口中直接设置传入的值，选择”运行”-&gt;”调试配置”。如图所示 选择java应用程序-&gt;自变量，填入命令行参数，并点击运行 运行结果 在dos窗口运行Java程序时传入命令行参数 在cmd中编译上述helloworld.java文件 编译结束后会产生.class字节码文件 在命令行中运行helloworld.class文件，并传入命令行参数，以下是运行结果 注意：如果命令行参数含有空格，要加双引号]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列的属性]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[回顾一下建表语句： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 表中的每个列都可以有一些属性，至于这些属性是什么以及怎么在创建表的时候把它们定义出来就是本章接下来的内容哈。 默认值我们在书写INSERT语句插入记录的时候可以只指定部分的列，那些没有被显式指定的列的值将被设置为NULL，换一种说法就是列的默认值为NULL，NULL的含义是这个列的值还没有被设置。如果我们不想让默认值为NULL，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个DEFAULT属性，就像这样： 1列名 列的类型 DEFAULT 默认值 比如我们把first_table的second_column列的默认值指定为’abc’，创建一下这个表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) DEFAULT 'abc' -&gt; );Query OK, 0 rows affected (0.02 sec) 如果我们不设置默认值，其实就相当于指定的默认值为NULL，比如first_table表并没有设置first_column列的默认值，那它的默认值就是NULL，也就是说上边的表定义语句和下边这个是等价的： 1234CREATE TABLE first_table ( first_column INT DEFAULT NULL, second_column VARCHAR(100) DEFAULT 'abc'); NOT NULL 属性有时候我们需要要求表中的某些列中必须有值，不能存放NULL，那么可以用这样的语法来定义这个列： 1列名 列的类型 NOT NULL 如果将first_column设置为NOT NULL属性，这样的话，我们就不能再往这个字段里插入NULL值了，比如这样： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(NULL, 'aaa');ERROR 1048 (23000): Column 'first_column' cannot be null 看到报了个错，提示first_column列不能存储NUL。 另外，一旦对某个列定义了NOT NULL属性，那这个列的默认值就不为NULL了。上边first_colum并没有指定默认值，意味着我们在使用INSERT插入行时必须显式的指定这个列的值，而不能省略它，比如这样就会报错的： 12mysql&gt; INSERT INTO first_table(second_column) VALUES('aaa');ERROR 1364 (HY000): Field 'first_column' doesn't have a default value 主键有时候在我们的表里可以通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为候选键。比如在学生信息表student_info中，只要我们知道某个学生的学号，就可以确定一个唯一的学生信息，也就是一条记录。当然，我们也可以通过身份证号来确定唯一的一条学生信息记录，所以学号和身份证号都可以作为学生信息表的候选键。在学生成绩表student_score中，我们可以通过学号和科目这两个列的组合来确定唯一的一条成绩记录，所以（学号、科目）这两个列的组合可以作为学生成绩表的候选键。 一个表可能有多个候选键，我们可以选择一个候选键作为表的主键。一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键： 如果主键只是单个列的话，可直接在该列后面声明PRIMARY KEY，比如可以把学生信息表student_info的学号列声明为主键： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 也可把主键的声明单独提取出来，用这样的形式声明： 123456789101112PRIMARY KEY (列名1, 列名2, ...)// 示例如下CREATE TABLE student_info ( number INT, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, PRIMARY KEY (number)); 值得注意的是，对于多个列的组合作为主键的情况，必须使用这种单独声明的形式，比如student_score表里的（学号,科目）的列组合作为主键，可以这么写： 123456CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject)); 在我们创建表的时候就声明了主键的话，MySQL会对我们插入的记录做校验，如果新插入记录的主键值已经在表中存在了，那就会报错。 另外，主键列默认是有NOT NULL属性，也就是必填的，如果填入NULL值会报错。所以大家在插入数据的时候至少别忘了给主键列赋值哈～ UNIQUE属性对于不是主键的其他候选键，如果也想让MySQL在我们向表中插入新记录的时候帮助我们校验一下某个列或者列组合的值是否重复，那么我们可以把这个列或列组合添加一个UNIQUE属性，表明该列或者列组合的值是不允许重复的。与我们在建表语句中声明主键的方式类似，为某个列声明UNIQUE属性的方式也有两种： 如果我们想为单个列声明UNIQUE属性，可以直接在该列后填写UNIQUE或者UNIQUE KEY，比如在学生信息表student_info中，我们不允许两条学生基本信息记录中的身份证号是一样的，那我们可以为id_number列添加UNIQUE属性： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18) UNIQUE, department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 我们也可以把UNIQUE属性的声明单独提取出来，用下面的形式声明。值得注意的是，对于多个列的组合具有UNIQUE属性的情况，必须使用这种单独声明的形式。 123UNIQUE [约束名称] (列名1, 列名2, ...)// 或者UNIQUE KEY [约束名称] (列名1, 列名2, ...) 其实每当我们为某个列添加了一个UNIQUE属性，就像是在孙悟空头上带了个紧箍咒一样，从此我们插入的记录的该列的值就不能重复，所以为某个列添加一个UNIQUE属性也可以认为是为这个表添加了一个约束，我们就称之为UNIQUE约束。每个约束都可以有一个名字，像主键也算是一个约束，它的名字就是默认的PRIMARY。不过一个表中可以为不同的列添加多个UNIQUE属性，也就是添加多个UNIQUE约束，每添加一个UNIQUE约束，我们就可以给它起个名，这也是上边的约束名称的含义。不过约束名称是被中括号[]扩起来的，意味着我们写不写都可以，如果不写的话MySQL自己会帮我们起名。其实就像是自己生了个孩子，如果自己不起名的话，人家公安局的警察叔叔也得给孩子起个名上户口。 如果表中为某个列或者列组合定义了UNIQUE属性的话，MySQ会对我们插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错！ 主键和UNIQUE约束的区别：主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是： 一张表中只能定义一个主键，却可以定义多个UNIQUE约束！ 规定：主键列不允许存放NULL，而声明了UNIQUE属性的列可以存放NULL，而且NULL可以重复地出现在多条记录中！(即多条记录的UNIQUE约束中的列都设置为NULL时，不会报已存在错误) 外键插入到学生成绩表student_score中的number(学号)列中的值必须能在学生基本信息表student_info中的number列中找到，否则如果一个学号只在成绩表里出现，而在基本信息表里找不到相应的记录的话，就相当于插入了不知道是哪个学生的成绩，这显然是荒谬的。为了防止这样荒谬的情况出现，MySQL给我们提供了外键约束机制。定义外键的语法是这样的： 1CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 其中的外键名称是可选的，一个名字而已，我们不自己命名的话，MySQL自己会帮助我们命令。 上面的语法是在创建表时建立外键的方法。如果表已经建立，怎么添加外键？ 1ALTER TABLE 表名 ADD CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 如果A表中的某个列或者某些列依赖与B表中的某个列或者某些列，那么就称A表为子表，B表为父表。子表和父表可以使用外键来关联起来，上边例子中student_score表的number列依赖于student_info的number列，所以student_info就是一个父表，student_score就是子表。在建立student_score时可定义外键如下： 1234567CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject), CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number)); 这样，在对student_score表插入数据的时候，MySQL都会为我们检查一下插入的学号是否能在student_info表中找到，如果找不到则会报错。 注意：父表中被子表依赖的列或者列组合必须建立索引，如果该列或者列组合已经是主键或者有UNIQUE属性，那么它们也就被默认建立了索引。示例中student_score表依赖于stuent_info表的number列，而number列又是stuent_info的主键，所以在student_score表中创建外键是没问题的。 建立外键后如何删除外键？ 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 如果在建立外键时未指定外键名称，MySQL会自动分配外键名。可通过show create table 表名; 来查看外键名称。 AUTO_INCREMENT属性AUTO_INCREMENT翻译成中文可以理解为自动增长，简称自增。如果一个表中的某个列的数据类型是整数类型或者浮点数类型，那么这个列可以设置AUTO_INCREMENT属性。当我们把某个列设置了AUTO_INCREMENT属性之后，如果我们在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为NULL或者0，那么新插入的记录在该列上的值就是当前该列的最大值加1后的值。我们可以用这样的语法来定义这个列： 1列名 列的类型 AUTO_INCREMENT; 定义列为AUTO_INCREMENT时需注意以下几点： 如果未指定值，默认从1开始递增 一个表中最多有一个具有AUTO_INCREMENT属性的列 具有AUTO_INCREMENT属性的列必须建立索引。主键和具有UNIQUE属性的列会自动建立索引 拥有AUTO_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值 一般拥有AUTO_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值 列的注释可以在建表结尾处添加COMMENT语句为表添加注释，也可以在每个列结尾添加COMMENT为列添加注释。具体语法如下： 12345CREATE TABLE first_table ( id int UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '自增主键', first_column INT COMMENT '第一列', second_column VARCHAR(100) DEFAULT 'abc' COMMENT '第二列') COMMENT '第一个表'; ZEROFILL属性对于INT(M)类型，M为所谓的显示宽度。显示宽度是在是在查询语句显示的结果中，如果声明了 ZEROFILL 属性的整数列的实际值的位数小于显示宽度时，会在实际值的左侧补0，使补0的位数和实际值的位数相加正好等于显示宽度。 1234567891011121314151617mysql&gt; CREATE TABLE zerofill_table ( -&gt; i1 INT(5) UNSIGNED ZEROFILL, -&gt; i2 INT UNSIGNED -&gt; );Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO zerofill_table(i1, i2) VALUES(1, 1);Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM zerofill_table;+-------+------+| i1 | i2 |+-------+------+| 00001 | 1 |+-------+------+// 这里补充了4个0，凑齐五位显示宽度1 row in set (0.00 sec) 使用ZEROFILL属性注意以下几点： 在展示查询结果时，某列数据自动补0的条件有这几个： 该列必须是整数类型的 该列必须有UNSIGNED ZEROFILL的属性 该列的实际值的位数必须小于显示宽度 在创建表的时候，如果声明了ZEROFILL属性的列没有声明UNSIGNED属性，那MySQL会为该列自动生UNSIGNED属性。（MySQL现在只支持对无符号整数进行自动补0操作） 显示宽度并不会影响实际类型的实际存储空间。显示宽度仅仅是在展示查询结果时，如果整数的位数不够显示宽度的情况下起作用 只有列的实际值的位数小于显示宽度时才会补0，实际值的位数大于显示宽度时照原样输出。 对于没有声明ZEROFILL属性的列，显示宽度没有一毛钱卵用。 一个列同时具有多个属性每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了～ 注意：有的属性是冲突的，一个列不能具有两个冲突的属性，。如一个列不能既声明为PRIMARY KEY，又声明为UNIQUE KEY，不能既声明为DEFAULT NULL，又声明为NOT NULL。 查看表结构时的列属性有两种方式： 第一种 123456789101112mysql&gt; SHOW CREATE TABLE student_info;| student_info | CREATE TABLE `student_info` ( `number` int(11) NOT NULL, `name` varchar(5) DEFAULT NULL, `sex` enum('男','女') DEFAULT NULL, `id_number` char(18) DEFAULT NULL, `department` varchar(30) DEFAULT NULL, `major` varchar(30) DEFAULT NULL, `enrollment_time` date DEFAULT NULL, PRIMARY KEY (`number`), UNIQUE KEY `id_number` (`id_number`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | 第二种： 123456789101112mysql&gt; DESC student_info;+-----------------+-----------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+-----------------+------+-----+---------+-------+| number | int(11) | NO | PRI | NULL | || name | varchar(5) | YES | | NULL | || sex | enum('男','女') | YES | | NULL | || id_number | char(18) | YES | UNI | NULL | || department | varchar(30) | YES | | NULL | || major | varchar(30) | YES | | NULL | || enrollment_time | date | YES | | NULL | |+-----------------+-----------------+------+-----+---------+-------+ 可以看到： NULL列代表该列是否可以存储NULL，值为NO时，表示不允许存储NULL，值为YES是表示可以存储NULL Key列存储关于所谓的键的信息，当值为PRI时代表主键；当值为UNI时代表UNIQUE属性 Default列代表该列的默认值 Extra代表一些额外的信息。比如说如果某个列具有AUTO_INCREMENT属性就会被展示在这里]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常见问题汇总]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文主要记录在学习和应用MySQL中碰到的各种问题和解决方法，以备查用。 1. 如何查看端口号？一般有两种方法可查看数据库： 查看MySQL配置文件my.ini 123456mysql&gt; show variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3305 |+---------------+-------+ 2. 如何修改端口号？ 停止mysql服务 1net stop mysql80 打开MySQL根目录下my.ini文件，修改文件中的port值，注意两个地方[client]和[mysqld] 重启mysql服务 1net start mysql80 3. 修改my.ini遇到权限问题由于修改my.ini文件需要管理员权限。如果没有权限会提示没有权限打开该文件。有两种解决方法： 发现没有权限，如果右键有用管理员打开，直接打开然后修改报错即可。 如果右键没有用管理员打开，就window下用管理员打开记事本，然后用记事本打开my.ini，修改然后保存即可。 4. 解决net start mysql启动,提示发生系统错误 5 拒绝访问在cmd下运行net start mysql 不能启动mysql！提示发生系统错误 5；拒绝访问！切换到管理员模式就可以启动了。所以我们要以管理员身份来运行cmd程序来启动mysql。 如果每天都要启动mysql服务，这样不很麻烦？所以： 右键cmd找到它所在的位置：如下图： 右击选择属性，选择快捷方式，再选择高级，在选择以管理员身份运行，再单击确定即可！]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置文件my.ini介绍]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6my-ini%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[my.ini是什么？my.ini是MySQL数据库中使用的配置文件，修改这个文件可以达到更新配置的目的。 my.ini存放在哪里？my.ini存放在MySql安装的根目录，如图所示： my.ini具体内容介绍12345678910111213141516# CLIENT SECTION# ----------------------------------------------------------------------## The following options will be read by MySQL client applications.# Note that only client applications shipped by MySQL are guaranteed# to read this section. If you want your own MySQL client program to# honor these values, you need to specify it as an option during the# MySQL client library initialization.#[client]port=3306[mysql]default-character-set=gb2312 上面显示的是客户端的参数，[client]和[mysql]都是客户端，下面是参数简介： 1.port参数表示的是MySQL数据库的端口，默认的端口是3306，如果你需要更改端口号的话，就可以通过在这里修改。 2.default-character-set参数是客户端默认的字符集，如果你希望它支持中文，可以设置成gbk或者utf8。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# SERVER SECTION# ----------------------------------------------------------------------## The following options will be read by the MySQL Server. Make sure that# you have installed the server correctly (see above) so it reads this # file.#[mysqld]# The TCP/IP Port the MySQL Server will listen onport=3306#Path to installation directory. All paths are usually resolved relative to this.basedir="E:/Java/Mysql/"#Path to the database rootdatadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"# The default character set that will be used when a new schema or table is# created and no character set is definedcharacter-set-server=gb2312# The default storage engine that will be used when create new tables whendefault-storage-engine=INNODB# Set the SQL mode to strictsql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"# The maximum amount of concurrent sessions the MySQL server will# allow. One of these connections will be reserved for a user with# SUPER privileges to allow the administrator to login even if the# connection limit has been reached.max_connections=100# Query cache is used to cache SELECT results and later return them# without actual executing the same query once again. Having the query# cache enabled may result in significant speed improvements, if your# have a lot of identical queries and rarely changing tables. See the# "Qcache_lowmem_prunes" status variable to check if the current value# is high enough for your load.# Note: In case your tables change very often or if your queries are# textually different every time, the query cache may result in a# slowdown instead of a performance improvement.query_cache_size=0# The number of open tables for all threads. Increasing this value# increases the number of file descriptors that mysqld requires.# Therefore you have to make sure to set the amount of open files# allowed to at least 4096 in the variable "open-files-limit" in# section [mysqld_safe]table_cache=256# Maximum size for internal (in-memory) temporary tables. If a table# grows larger than this value, it is automatically converted to disk# based table This limitation is for a single table. There can be many# of them.tmp_table_size=35M# How many threads we should keep in a cache for reuse. When a client# disconnects, the client's threads are put in the cache if there aren't# more than thread_cache_size threads from before. This greatly reduces# the amount of thread creations needed if you have a lot of new# connections. (Normally this doesn't give a notable performance# improvement if you have a good thread implementation.)thread_cache_size=8#*** MyISAM Specific options# The maximum size of the temporary file MySQL is allowed to use while# recreating the index (during REPAIR, ALTER TABLE or LOAD DATA INFILE.# If the file-size would be bigger than this, the index will be created# through the key cache (which is slower).myisam_max_sort_file_size=100G# If the temporary file used for fast index creation would be bigger# than using the key cache by the amount specified here, then prefer the# key cache method. This is mainly used to force long character keys in# large tables to use the slower key cache method to create the index.myisam_sort_buffer_size=69M# Size of the Key Buffer, used to cache index blocks for MyISAM tables.# Do not set it larger than 30% of your available memory, as some memory# is also required by the OS to cache rows. Even if you're not using# MyISAM tables, you should still set it to 8-64M as it will also be# used for internal temporary disk tables.key_buffer_size=55M# Size of the buffer used for doing full table scans of MyISAM tables.# Allocated per thread, if a full scan is needed.read_buffer_size=64Kread_rnd_buffer_size=256K# This buffer is allocated when MySQL needs to rebuild the index in# REPAIR, OPTIMZE, ALTER table statements as well as in LOAD DATA INFILE# into an empty table. It is allocated per thread so be careful with# large settings.sort_buffer_size=256K 上面是服务器断参数，以下是参数的简介： 1.port参数也是表示数据库的端口，默认3306。 2.basedir参数表示MySQL的安装路径。 3.datadir参数表示MySQL数据文件的存储位置，也是数据库表的存放位置。 4.default-character-set参数表示默认的字符集，这个字符集是服务器端的。 5.default-storage-engine参数默认的存储引擎。 6.sql-mode参数表示SQL模式的参数，通过这个参数可以设置检验SQL语句的严格程度。 7.max_connections参数表示允许同时访问MySQL服务器的最大连接数，其中一个连接是保留的，留给管理员专用的。 8.query_cache_size参数表示查询时的缓存大小，缓存中可以存储以前通过select语句查询过的信息，再次查询时就可以直接从缓存中拿出信息。 9.table_cache参数表示所有进程打开表的总数。 10.tmp_table_size参数表示内存中临时表的总数。 11.thread_cache_size参数表示保留客户端线程的缓存。 12.myisam_max_sort_file_size参数表示MySQL重建索引时所允许的最大临时文件的大小。 13.myisam_sort_buffer_size参数表示重建索引时的缓存大小。 14.key_buffer_size参数表示关键词的缓存大小。 15.read_buffer_size参数表示MyISAM表全表扫描的缓存大小。 16.read_rnd_buffer_size参数表示将排序好的数据存入该缓存中。 17.sort_buffer_size参数表示用于排序的缓存大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#*** INNODB Specific options ***# Use this option if you have a MySQL server with InnoDB support enabled# but you do not plan to use it. This will save memory and disk space# and speed up some things.#skip-innodb# Additional memory pool that is used by InnoDB to store metadata# information. If InnoDB requires more memory for this purpose it will# start to allocate it from the OS. As this is fast enough on most# recent operating systems, you normally do not need to change this# value. SHOW INNODB STATUS will display the current amount used.innodb_additional_mem_pool_size=3M# If set to 1, InnoDB will flush (fsync) the transaction logs to the# disk at each commit, which offers full ACID behavior. If you are# willing to compromise this safety, and you are running small# transactions, you may set this to 0 or 2 to reduce disk I/O to the# logs. Value 0 means that the log is only written to the log file and# the log file flushed to disk approximately once per second. Value 2# means the log is written to the log file at each commit, but the log# file is only flushed to disk approximately once per second.innodb_flush_log_at_trx_commit=1# The size of the buffer InnoDB uses for buffering log data. As soon as# it is full, InnoDB will have to flush it to disk. As it is flushed# once per second anyway, it does not make sense to have it very large# (even with long transactions).innodb_log_buffer_size=2M# InnoDB, unlike MyISAM, uses a buffer pool to cache both indexes and# row data. The bigger you set this the less disk I/O is needed to# access data in tables. On a dedicated database server you may set this# parameter up to 80% of the machine physical memory size. Do not set it# too large, though, because competition of the physical memory may# cause paging in the operating system. Note that on 32bit systems you# might be limited to 2-3.5G of user level memory per process, so do not# set it too high.innodb_buffer_pool_size=107M# Size of each log file in a log group. You should set the combined size# of log files to about 25%-100% of your buffer pool size to avoid# unneeded buffer pool flush activity on log file overwrite. However,# note that a larger logfile size will increase the time needed for the# recovery process.innodb_log_file_size=54M# Number of threads allowed inside the InnoDB kernel. The optimal value# depends highly on the application, hardware as well as the OS# scheduler properties. A too high value may lead to thread thrashing.innodb_thread_concurrency=18 上面是InnoDB存储引擎使用的参数，一下是参数的简介： 1.innodb_additional_mem_pool_size参数表示附加的内存池，用来存储InnoDB表的内容。 2.innodb_flush_log_at_trx_commit参数是设置提交日志的时机，若设置为1，InnoDB会在每次提交后将事务日志写到磁盘上。 3.innodb_log_buffer_size参数表示用来存储日志数据的缓存区的大小。 4.innodb_buffer_pool_size参数表示缓存的大小，InnoDB使用一个缓冲池类保存索引和原始数据。 5.innodb_log_file_size参数表示日志文件的大小。 6.innodb_thread_concurrency参数表示在InnoDB存储引擎允许的线程最大数。 注意：每次修改参数后，必须重新启动MySQL服务才会有效。操作如下： 12net stop mysql80net start mysql80]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL客户端与服务器连接过程]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 我们现在已经知道如何启动MySQL的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！ ​ TCP/IP是客户端和服务器之间最常用的通信方式。真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。MySQL采用TCP作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程有需要采用TCP协议进行网络通信方面的需求，可以向操作系统申请一个端口号，这是一个整数值，它的取值范围是0~65535。这样在网络中的其他进程就可以通过IP地址 + 端口号的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。 ​ MySQL服务器启动的时候会默认申请3306端口号，之后就在这个端口上等待客户端进程进行连接。用书面一点的话来说，MySQL服务器会默认监听3306端口。 ​ 如果3306端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加-P参数来明确指定一下端口号，比如这样： 1mysqld -P3307 如果采用windows服务打开MySQL服务器，则需要修改配置文件my.ini中的默认端口号。这样MySQL服务器在启动时就会去监听我们指定的端口号3307 ​ 如果客户端进程想要使用TCP/IP网络来连接到服务器进程，比如我们在使用mysql来启动客户端程序时，在-h参数后必须跟随IP地址来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用127.0.0.1来代表本机的IP地址。另外，如果服务器进程监听的端口号不是默认的3306，我们也可以在使用mysql启动客户端程序时使用-P参数（大写的P，小写的p是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写： 1mysql -h127.0.0.1 -uroot -P3307 -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站导航]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%85%A8%E7%AB%99%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到本学习交流网站，为了便于自己日后复习查看，特此设置全站导航。 MySQL一、MySQL基础知识 MySQL客户端与服务器连接过程 数据库基本操作 MySQL表的基本操作 MySQL数据类型 列的属性 二、MySQL配置问题 MySQL初始化与启动 MySQL配置文件my.ini介绍 三、MySQL注意事项与问题 MySQL密码错误如何修改 MySQL语句使用注意事项 MySQL常见问题汇总 算法机器学习算法 决策树 Java一、Java基础知识 Java入门（含Java基本介绍、数据类型、流程控制和数组操作） Java命令行参数 Java面向对象编程（类、继承、多态、抽象类、接口） 二、 JVM相关 从JVM角度看Java多态 class文件反汇编 Hexo 利用Hexo搭建个人博客 Hexo博客如何迁移至其它电脑]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java入门（含Java基本介绍、数据类型、流程控制和数组操作）]]></title>
    <url>%2F2020%2F02%2F06%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E5%90%ABJava%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Java介绍​ Java是目前全球Top 1的程序开发语言，是SUN公司James Gosling为手持设备开发的嵌入式编程语言，原名Oak，1995年改名为Java正式推出，有最大的开发社区；目前广泛应用于企业和互联网后端开发、Android开发和大数据开发。 1.1 Java的特点 一种面向对象的跨平台编程语言，语法比C++简单 以字节码的形式运行在虚拟机上 自带功能齐全的类库 有非常活跃的开源社区支持 1.2 Java的优缺点优点： 简单(语法比C++简单)、健壮(垃圾收集器让内存管理更容易)、安全(字节码运行在虚拟机上，无法操作硬件，因此安全) 跨平台，一次编写，到处运行 高度优化的虚拟机 缺点： 语法比较繁琐 无法直接操作硬件(不适用于底层操作系统的开发) GUI效果不佳(不适用于桌面应用程序的开发) 1.3 Java的版本 Java SE: Standard Edition(标准版) Java EE: Enterprise Edition(企业版) Java ME: Micro Edition(移动版) 1.4 Java的规范什么是规范？ ​ 比如USB就是一个规范，它规定了电源的正负极、信号线等等 ​ Java的规范是Java Specification Request，简称JSR。有个组织Java Community Process(JCP)，它负责维护JSR规范。 1.5 Java平台​ Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。 Java平台实际上就是运行在各种操作系统上的JVM(虚拟机) 1.6 Java为什么可以跨平台运行？​ 1.首先开发好的java文件经过编译器Compiler的编译变为.class文件，然而这个.class文件并不是真正的本地可以执行的指令 我们可以把这个.class文件称之为“中间码” ​ 2.不同的计算机操作系统有着相应的JVM 比如win32位的、win64位的、linux系统的，.class文件经过Interpreter（解释器，也就是JVM）的解释（或者称之为翻译），变为真正的本地可执行指令（“00101001001…”） 总结：“一处编译，到处运行”是因为程序的中间码.class文件是标准的，一致的，在各个系统对应的JVM上都可以被识别解释然后运行，所以可以实现跨平台 1.7 Java安装 上官网下载对应版本的JDK 官网网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 不更改安装路径，直接安装在C盘 配置JDK环境变量，将C:\ProgramFiles\Java\jdk\bin添加到系统path变量中。打开cmd，输入“javac -version”，如果出现版本号，即代表配置完成 2. Java程序基础2.1 Java程序基本结构Java的基本程序结构如下： 123456789101112/** * 可用来自动创建文档注释 */public class Hello &#123; public static void main(String[] args)&#123; System.out.pringln("Hello world"); /* 多行注释 注释内容 注释结束 */ &#125;&#125; //class定义结束 ​ 类名必须是英文字母、数字和下划线的组合；类名必须以英文字母开头。 ​ Java有三种注释： 单行注释：以双斜线//开头，到当前行尾 多行注释：以/ … /表示，中间所有内容都被视为注释 特殊的多行注释：以/* … /表示，写在类和方法定义处，可用于自动创建文档。 2.2 变量123456public class Hello &#123; public static void main(String[] args)&#123; int n = 100; //基本类型 String s = "Hello,world"; //对象 &#125;&#125; 变量可以持有某个基本类型的数值，或者指向某个对象 变量必须先定义后使用 定义变量 1变量类型 变量名 = 初始值; 变量可被重新赋值 2.3 基本数据类型 整数类型：long、int、short、byte 浮点类型：double、float 布尔类型：boolean 字符类型：char 计算机内存的最小存储单元是字节（byte），一个字节时8位二进制数：00000000 ~ 11111111（0 ~ 255）。内存单元从0开始编号，称为内存地址。 2.3.1 整形 byte：8位，1字节 short：16位，2字节 int：32位，4字节 long：64位，8字节 123456789byte b = 127; //byte范围：-128 ~ 127short s = 32767; //-32768 ~ 32767int i = 2147483647;int i2 = -2147483648;int i3 = 2_000_000_000; //加下划线更容易识别int i4 = 0xff0000; //16进制表示的16711680int i5 = 0b1000000000; //2进制表示的512// 同一个数的不同进制表示完全相同long l = 9000000000000000000L; //由于java默认类型为int，因此需要在结尾加L 2.3.2 浮点类型 float：32位，4字节 double：64位，8字节 1234float f1 = 3.14f; // Java浮点数默认为double类型，float类型需在结尾加ffloat f2 = 3.14e38f; // 科学计数法表示的3.14*10^38double d = 1.79e308;double d1 = 4.9e-324; // 4.9*10^(-324) 2.3.3 布尔类型只有true和false两个值，通常是计算结果 2.3.4 字符类型char：保存一个字符，用单引号表示，如果输入多个字符编译器将会报错。注意区分字符类型和字符串类型的区别。 12char c1 = 'A';char c2 = '中'; 2.4 常量常量就是用final修饰的变量： 常量初始化后不可再次赋值 常量名通常全部大写 常量用来避免意外赋值 常量用来替代Magic Number：魔数导致代码可读性差，修改不方便的问题。 12345678// 常量的好处就是如果需要更改常量的值，只需在定义处修改final double PI = 3.14;double r = 4.0;double area = PI*r*r;//magic number:增加可读性，后续能看懂final double tax_rate = 0.2;double pay = 1-tax_rate; 2.5 基本类型和引用类型Java提供了两种变量类型：基本类型和引用类型。 基本类型：byte、short、int、long、float、double、char、boolean 引用类型：String、类、接口类型、数组类型、枚举类型、注解类型 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。 基本类型的变量是”持有”某个数值，引用类型的变量是”指向“某个对象 2.6 引用类型Java的引用与C++的指针在原理上是相类似的，但Java没有指针，只有引用。 简单的说，引用其实就像是一个对象的名字或者别名 (alias)，一个对象在内存中会请求一块空间来保存数据，根据对象的大小，它可能需要占用的空间大小也不等。访问对象的时候，我们不会直接是访问对象在内存中的数据，而是通过引用去访问。引用也是一种数据类型，我们可以把它想象为类似 C++ 语言中指针的东西，它指示了对象在内存中的地址——只不过我们不能够观察到这个地址究竟是什么。 如果我们定义了不止一个引用指向同一个对象，那么这些引用是不相同的，因为引用也是一种数据类型，需要一定的内存空间（stack，栈空间）来保存。但是它们的值是相同的，都指示同一个对象在内存（heap，堆空间）的中位置。 123String a = "hello";String b = a;//表示a和b是两个不同的引用，但它们的值是一样的，都指向同一个对象"hello" 总结： 引用是一种数据类型（保存在stack中），保存了对象在内存（heap，堆空间）中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)； 不同的引用可能指向同一个对象，换句话说，一个对象可以有多个引用，即该类类型的变量。 2.7 整数运算运算规则： 基本四则运算法则 除法结果为整数 除数为0时，运行将报错 ++运算和—运算 +=运算和-=运算 取余运算% Java源码中经常会使用移位运算来代替乘除运算，因为移位运算的性能比乘除运算的高（PS：对于计算机而言，移位运算只是移了个位置），所以了解移位运算的计算过程对于我们阅读源码会有一定的帮助。 原码：第一位表示符号, 其余位表示值 反码：正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 移位运算（3种）： 左移&lt;&lt;：丢弃左边指定位数，右边补0 带符号右移&gt;&gt;：丢弃右边指定位数，左边补上符号位 不带符号右移&gt;&gt;&gt;：丢弃右边指定位数，左边补上0 byte和short会先转换为int再进行移位 结论：对于机器而言，java中的移位运算都是对补码执行移位运算的，下面以-1&lt;&lt;1=-2为例进行讲解: -1的原码：10000000 00000000 00000000 00000001 -1的反码：11111111 11111111 11111111 11111110 -1的补码：11111111 11111111 11111111 11111111 执行移位操作 -1移位后的补码：11111111 11111111 11111111 11111110 -1移位后的反码：11111111 11111111 11111111 11111101 -1移位后的原码：10000000 00000000 00000000 00000010 得到最后的原码十进制值为-2 举例如下： 12345int n1 = 5;int n2 = n1&lt;&lt;10; //5120int n3 = n2&gt;&gt;11; //2int n4 = n1&lt;&lt;29; //-1610612736int n5 = n4&gt;&gt;29; //-3 类型自动提升与强制转型 在运算过程中，计算结果为较大类型的整型 12short s = 12;int i = 100+s; //100为int型，计算结果自动转为int型 较大类型的整数不能直接赋值给一个较小类型的整数，相反较小类型的整数能直接赋值给较大类型的整数 12long a = 100L;int b = a; //编译错误 可将结果强制转型 123(类型)变量或数值long a = 100L;int b = (int)a; 强制转型可能会丢失精度，因为int是32位，long是64位，所以如果数值大于32位会损失精度 2.8 浮点数运算浮点数运算的特点： 很多浮点数无法精确表示(详情可见另一篇博客：MySQL数据类型) 计算有误差，因为浮点数无法精确表示 1double b = 1-9.0/10; //0.09999999999999998 计算时如果浮点数和整数进行运算，整型可以自动提升为浮点型 浮点数运算特殊值（三种）： 1double d1 = 0.0/0; //NAN，不报错 1double d2 1.0/0; //Infinity 1double d3 = -1.0/0; //Infinity 强制转型 强制转为整型会直接扔掉小数位 12int n1 = (int)12.3; //12int n2 = (int)12.7; //12 四舍五入的技巧 1int n3 = (int)(12.7+0.5); 超出整型范围自动变为最大值 1int n4 = (int)1.2e20; //2147483647 2.9 布尔运算 关系运算符：&gt; , &gt;= , &lt; , &lt;= , == , != 与运算：&amp;&amp; 或运算：|| 非运算：！ 短路运算符： 与运算&amp;&amp;：与运算中，如果有任何一个表达式的计算结果为false，则后面的表达式将不再计算 或运算||：或运算中，如果有任何一个表达式的计算结果为true，则后面的表达式将不再计算 三元运算符：b ? x : y 根据条件b计算x或y，b为true计算x，b为false计算y x和y只计算其中一个 x和y类型必须相同 2.10 字符和字符串 字符类型是基本数据类型，保存一个字符。Java使用Unicode编码，因此可将字符类型直接赋值给一个int类型。还可直接用Unicode编码表示字符类型： 12// '\u####',4位16进制char c = '\u0041'; //'A' 字符串类型不是一个基本类型，是引用类型。String保存一个字符串。 1String s = "ABC"; 字符串连接用+，可以连接字符串和其它数据类型 12String s = "hello" + "world";String a = "age is" + 12; 因为字符串类型是引用类型，所以字符串不可变，只能改变其引用指向的对象。 所有的引用类型可以指向空值null，表示不指向任何对象。空值null和空字符串””是不一样的，注意区分。 1String s = null; 2.11 数组类型当有一组类型相同的变量时，可以用数组表示： 数组类型是：类型[] 数组初始化用new int[数组长度] 数组所有元素初始化为默认值 数组创建后大小不可改变 数组索引从0开始 12345678910public class hello&#123; public static void main(String[] args)&#123; int[] ns = new int[5]; ns[0] = 1; ns[1] = 2; ns[2] = 3; ns[3] = 4; ns[4] = 5; &#125;&#125; 用数组变量.length获取数组大小 12int[] ns = new int[5];System.out.println(ns.length); 数组变量是引用类型 可以指定初始化的元素，由编译器自动推算数组大小 123int[] ns = new int[] &#123;1,2,3,4,5&#125;;//可进一步简写int[] ns = &#123;1,2,3,4,5&#125;; 数组变量是引用类型，数组大小不可变，可指向不同的数组对象 数组元素是值类型（如int[]）或引用类型（如String[]） 3. 流程控制3.1 输入和输出输出： 输出并换行 1System.out.println() 输出但不换行 1System.out.print() 输入: 导入java.util.Scanner 创建Scanner并传入System.in 使用scanner.nextLine()读字符串 使用scanner.nextInt()读整数 使用scanner.nextDouble()读长整型 …… 1234567891011import java.util.Scanner;public class hello&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("Input your name:"); String name = scanner.nextLine(); System.out.println("Input your age:"); int age = scanner.nextInt(); &#125;&#125; 格式化输出： 格式化输出使用System.out.printf() 使用占位符%### 1System.out.printf("%s is %d years old\n","Bob",12); 常用占位符： 占位符 含义 %d 整数 %x 十六进制整数 %f 浮点数 %s 字符串 %% 百分号字符本身 %e 科学计数法表示浮点数 %c 字符 %b 布尔值 12345678public class hello&#123; public static void main(String[] args)&#123; double d = 3.1415926; System.out.println(d); System.out.printf("PI = %.2f\n",d); System.out.printf("PI = %7.2f\n",d); &#125;&#125; 运行结果如下： 1233.1415926PI = 3.14PI = 3.14 //3前面补充了三个空格 格式标识符解释 %7.2f： 7为域宽度.输出的浮点数条目宽度至少为7,包括小数点和小数点后两位数字.这样,给小数点前分配了5位数字.如果该条目小数点前的位数小于5,就在数字前面加空格.如果该条目小数点前的位数大于5,则自动增加宽度. 2为精度().即想要输出的小数点的长度. f为转换码 指定宽度和精度的例子 举例 输出 %5c 输出字符并在这个字符条目前面加4个空格 %6b 输出字符并在这个字符条目前面加4个空格 %5d 输出整个条目,宽度至少为5.如果该条目的数字位数小于5,就在数字前面加空格.如果该条目的位数大于5,则自动增加宽度 %10.2f 输出的浮点条目宽度至少为10,包括小数点、和小数点后两位数字.这样,给小数点前分配了7位数字. 如果该条目小数点前的位数小于7,就在数字前面加空格. 如果该条目小数点前的位数大于7,则自动增加宽度. %10.2e 输出的浮点条目的宽度至少为10,包括小数点、小数点后面两位数字和指数部分(包括e、正负号和指数数字).如果按科学计数法显示的数字位数小于10,就给数字前加空格 %12s 输出的字符串至少为12个字符.如果该字符串条目小于12个字符,就在该字符串前加空格.如果该字符串条目多余12个字符,则自动增加宽度 注意的问题： 默认情况下,输出是右对齐的（即如果宽度不够，在左边补齐空格）.可以在格式标识符中放一个符号(-),表明该条目在特定区域中的输出是左对齐的. 123456System.out.printf("%8.4f",1.12);System.out.printf("%-8.4f",1.12);// 输出 1.12001.1200 使用符号%来标记格式标识符,要在格式字符串里输出直接量%,需要使用%% 如果在补齐时不希望以空格进行补齐，而希望以0进行补齐，如下所示： 1234System.out.printf("PI = %08d\n",1234);// 输出00001234 如果想显示符号位，如下所示： 1234System.out.printf("PI = %+8d\n",1234);// 无论正负都可以用上述形式显示符号位// 输出 +1234 //符号也占一位 如何控制输出顺序 1234567// #$表示第几个变量System.out.printf("%2$d, %1$d",13,14);System.out.printf("%2$s, %1$s","a","b");// 输出14, 13b, a 3.2 引用类型判断是否相等 判断两个引用是否指向堆中的同一个实例，用”==” 123String a = "hello";String b = "world";Sytsem.out.println(a==b); 判断两个引用指向的实例是否相等，用equals。如果变量为null，调用equals()会报错，利用短路运算符&amp;&amp;解决。 1234String a = "hello";String b = "world";if(a!=null &amp;&amp; a.equals(b)) System.out.println("yes"); 3.3 Switch语句1234567891011121314int opt = 2;switch(opt)&#123; case 1: System.out.println("1"); break; case 2: System.out.println("2"); break; case 3: System.out.println("3"); break; default: System.out.println("none");&#125; 注意case语句没有{} case语句具有”穿透性”，如果不加break会导致意想不到的结果。当opt=2，如果不写break导致case2、case3和default顺序执行 switch的计算结果必须是整形、字符串（字符串比较内容相等）或枚举类型 如何避免漏写break和default？ 打开eclipse中的窗口-&gt;首选项 Java-&gt;编译器-&gt;错误/警告-&gt;可能的编程问题，将”switch缺少default语句”和”switch case跳转”修改为警告： 这样以后如果忘了写break或default时会有警告 3.4 While循环 while循环首先判断条件 条件满足时循环 条件不满足时退出 可能一次都不循环 注意逻辑，避免无限死循环 123456int sum = 0;int n = 1;while(n&lt;10)&#123; sum = sum+n; n++;&#125; 3.5 do-while循环 do-while先执行循环，再判断条件 条件满足时继续循环 条件不满足时退出 至少循环一次 123456int sum = 0;int n = 1;do&#123; sum += n; n++;&#125; while(n&lt;10); 3.6 for循环for循环分别设置： 计数器初始值 循环前检测条件 每次循环后如何更新计数器 1234int[] ns = &#123;1,2,3,4,5&#125;;for(int i=0;i&lt;ns.length;i++)&#123; System.out.println(ns[i]);&#125; 初始化计数器总是被执行 可能循环0次 for each循环 1234int[] ns = &#123;1,2,3,4,5&#125;;for(n:ns)&#123; System.out.println(n);&#125; for each循环可以更简单的遍历数组 for each循环能够遍历数组和”可迭代”数据类型，包括List、Map等 for each循环无法指定遍历顺序 for each循环无法获取数组索引，因此无法同时遍历多个数组。只能通过for循环 12345int[] ns1 = &#123;1,2,3,4,5&#125;;int[] ns2 = &#123;6,7,8,9,10&#125;;for(int i=0;i&lt;ns1.length;i++)&#123; ns2[i] = ns1[i]*ns1[i];&#125; break和continue在循环中，可以使用break语句和continue语句。 break跳出循环 循环过程中，可以使用break语句跳出循环 如果有多层循环嵌套，break语句总是跳出最近的一层循环。 break通常配合if，在满足条件时提前结束循环 continue提前结束当前循环 continue可提前结束本轮循环，直接继续下次循环 continue通常配合if，在满足条件时提前结束本轮循环 数组操作遍历数组 for循环可以遍历数组 for(;;)循环通过下标遍历数组 for each循环直接遍历数组元素 直接打印数组变量，得到的是数组在JVM中的引用地址。for each循环打印也很麻烦。Arrays.toString()可以快速打印数组内容 1234import java.util.Arrays;int[] ns = &#123;1,1,2,3,5,8&#125;;System.out.println(Arrays.toString(ns)); 数组排序有两种方法： 自己写排序算法，比如冒泡排序、快排等 使用JDK的Arrays.sort()排序。使用ctrl+鼠标左键可以快速查看JDK源码 12345import java.util.Arrays;int[] ns = &#123;28,12,89,73,65&#125;;Arrays.sort(ns);System.out.println(Arrays.toString(ns)); 对数组排序修改了数组本身 多维数组二维数组 二维数组就是数组的数组 12345int[][] ns = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 二维数组的内存空间分配如图所示： 数组变量分配在栈内存中，其指向一个三维数组，该三维分配在堆内存上。每一维数组元素由指向一个一维数组，同样分配在堆内存上。 访问二维数组元素使用array[rows] [cols] 二维数组每个数组元素长度不要求相同 三维数组与二维数组类似，内存分配如图所示 123456789101112131415int[][][] ns = &#123; &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;, &#123; &#123;10,11&#125;, &#123;12,13&#125; &#125;, &#123; &#123;14,15,16&#125;, &#123;17,18&#125; &#125;&#125;; 其余多维数组类似]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表的基本操作]]></title>
    <url>%2F2019%2F11%2F13%2FMySQL%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ 创建表的时候首先需要描述清楚这个表是什么样的，它有哪些列，这些列都是用来存什么类型的数据等等。表中的一行叫做一条记录，一列就做一个字段。 展示当前数据库的表​ 下面的语句用于展示当前数据库中有哪些表： 1mysql&gt; SHOW TABLES; 创建表1、基本语法创建一个表时至少需要完成下列事情： （1）给表起个名 （2）给表定义一些列，并且给这些列都起个名 （3）每个列都需要定义一种数据类型 （4）如果有需要的话，可以给这些列定义一些列的属性，比如不许存储NULL，设置默认值等，具体列可以设置哪些属性可以在后面再详细说一下 创建表的基本语法如下： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 注意事项： 在CREATE TABLE后写清楚我们要创建的表的名称 在小括号 () 中定义这个表各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性(列的属性用中括号 [] 包起来的意思是这部分是可选的) 列名、数据类型、列属性之间用空白字符分开就好，然后各个列的信息之间用逗号分隔开 下面我们建个表为例展示一下： 1234CREATE TABLE first_table( first_column INT, second_column VARCHAR(100)); 执行结果如下： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; );Query OK, 0 rows affected (0.02 sec) 如何查看已建立的表的列属性信息？ 1234567mysql&gt; show create table first_table;// 结果如下CREATE TABLE `first_table` ( `first_column` int(11) DEFAULT NULL, `second_column` varchar(100) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 2、为建表语句添加注释​ 我们可以在创建表时将该表的用处以注释的形式添加到语句中，只要在建表语句最后加上COMMIT语句即可： 123CREATE TABLE 表名 ( 各个列的信息 ...) COMMENT '表的注释信息'; 比如我们可以这样写first_table的建表语句： 1234CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100)) COMMENT '第一个表'; 注释没必要太长，言简意赅即可，毕竟是给人看的，让人看明白是个啥意思就好了。为了我们自己的方便，也为了阅读你创建的人的方便，请遵守一下职业道德，写个注释吧～ 3、IF NOT EXISTS​ 和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，我们来试试重复创建一下first_table表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; ) COMMENT '第一个表';ERROR 1050 (42S01): Table 'first_table' already exists 如果想要避免这种错误发生，可以在创建表的时候使用这种形式： 123CREATE TABLE IF NOT EXISTS 表名( 各个列的信息 ...); 4、简单的查询和插入语句简单的查询语句 如果我们想查看某个表里已经存储了哪些数据，可以用下边这个语句： 1SELECT * FROM 表名; 比如我们想看看前边创建的first_table表中有哪些数据，可以这么写： 12mysql&gt; SELECT * FROM first_table;Empty set (0.01 sec) 很遗憾，我们从来没有向表中插入过数据，所以查询结果显示的是Empty set，表示什么都没查出来～ 简单的插入语句 MySQL插入数据的时候是以行为单位的，语法格式如下： 1INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...); 也就是说我们可以在表名后边的括号中指定要插入数据的列，然后在VALUES后边的括号中按指定的列顺序填入对应的值，我们来为first_table表插入第一行数据： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(1, 'aaa');Query OK, 1 row affected (0.00 sec) 这个语句的意思就是我们要向first_table表中插入一行数据，first_column列的值是1，second_colum列的值是’aaa’。看一下现在表中的数据： 1234567mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa |+--------------+---------------+1 row in set (0.00 sec) 我们也可以只指定部分的列，没有显式指定的列的值将被设置为NULL，NULL的意思就是此列的值尚不确定。比如这样写： 12345mysql&gt; INSERT INTO first_table(first_column) VALUES(2);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO first_table(second_column) VALUES('ccc');Query OK, 1 row affected (0.00 sec) 这两条语句的意思就是： 第一条插入语句我们只指定了first_column列的值是2，而没有指定second_column的值，所以second_colum的值就是NULL。 第二条插入语句我们只指定了second_column的值是’ccc’，而没有指定first_column的值，所以first_column的值就是NULL。 执行完这两条语句后，再看一下现在表中的数据： 123456789mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc |+--------------+---------------+3 rows in set (0.00 sec) 批量插入 每插入一行数据写一条语句也不是不行，但是对人来说太烦了，而且每插入一行数据就向服务器提交一个请求远没有一次把所有插入的数据提交给服务器效率高，所以MySQL为我们提供了批量插入记录的语句： 1INSERT INTO 表名(列1,列2, ...) VAULES(列1的值，列2的值, ...), (列1的值，列2的值, ...), (列1的值，列2的值, ...), ...; 也就是在原来的单条插入语句后边多写几条记录的内容，用逗号分隔开就好了，举个例子： 12345678910111213141516mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(4, 'ddd'), (5, 'eee'), (6, 'fff');Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc || 4 | ddd || 5 | eee || 6 | fff |+--------------+---------------+6 rows in set (0.01 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库层面基本操作]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ MySQL中把一些标的集合成为一个数据库，MySQL服务器管理着若干个数据库，每个数据库下都可以有若干个表，即 展示数据库​ 在刚安装好MySQL的时候，它内建了许多数据库和表了，我们可以使用下述命令来看一下都有哪些数据库： 1SHOW DATABASES; 创建数据库1CREATE DATABASE 数据库名; ​ 注意如果一个数据库已经存在的情况下再使用CREATE DATABASE去创建这个数据库会产生错误！如果我们并不清楚数据库是否存在，可以使用下边的语句来创建数据库： 1CREATE DATABASE IF NOT EXISTS 数据库名; 上述命令的意思是如果指定数据库不存在的话就创建它，否则什么都不做。 切换当前数据库​ 对于每一个连接到MySQL服务器的客户端，都有一个当前数据库的概念（也可以称之为默认数据库），我们创建的表默认都会被放到当前数据库中，切换当前数据库的命令也贼简单： 1USE 数据库名称; ​ 如果显示了Databases changed，说明当前数据库已经切换成功了。需要注意的是，在退出当前客户端之后，也就是你输入了exit或者quit命令之后或者直接把当前的黑框框页面关掉，当你再次打开MySQL时，相当于重新开启了一个客户端，需要重新调用USE 数据库名称的语句来选择一下当前数据库。 ​ 其实我们在新客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，只要把数据库名称写在启动客户端的命令后面就好，如下： 1mysql -hlocalhost -uroot -p 数据库名称; 删除数据库​ 如果我们觉得某个数据库没用了，可以把它删除掉，语法如下： 1DROP DATABASE 数据库名; ​ 在真实的工作环境里，在删除数据库之前你需要先拿体温计量量是不是发高烧了，然后再找至少两个人核实一下自己是不是发烧了，然后你才敢执行删除数据库的命令。删除数据库意味着里边的表就都被删除了，也就意味着你的数据都没了，所以是个极其危险的操作，使用时需要极其谨慎。 ​ ​ 如果某个数据库并不存在，我们仍旧调用DROP DATABASE语句去删除它，会报错。 ​ 如果想要避免这种报错，可以使用这种形式的语句来删除数据库： 1DROP DATABASE IF EXISTS 数据库名;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F10%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL支持所有的SQL数据类型，主要分为以下四类： 数值类型 字符串类型 时间日期类型 二进制类型 一、数值类型​ MySQL数值类型有9种，其中整数类型有5种（INTEGER、TINYINT、SMALLINT、MEDIUMINT和BIGINT）、浮点类型2种（float(M,D)、double(M,D)）、定点数1种（decimal(M,D)）和bit(M)类型1种。 整数类型 ​ 使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间。根据表示一个数占用字节数的不同，MySQL把整数划分成如下所示的类型： 类型 占用的存储空间（单位：字节） 无符号数取值范围 有符号数取值范围 含义 TINYINT 1 0~255 -128~127 非常小的整数 SMALLINT 2 0~65535 -32768~32767 小的整数 MEDIUMINT 3 0~16777215 -8388608~8388607 中等大小的整数 INT(INTEGER) 4 0~4294967 295 -2147483648~2147483647 标准的整数 BIGINT 8 0~2^64^-1 -2^63^~2^63^-1 大整数 以TINYINT为例，用1个字节，也就是8位表示有符号数的话，就是既可以表示正数，也可以表示负数的话，需要有一个比特位表示正负号。但是如果表示无符号数的话，也就是只表示非负数的话，就不需要表示正负号，这就是有符号数和无符号数的区别。 注意，对于INT(M)类型，M值不代表可以存储的数字长度，代表的是数据在显示时显式的最小长度。在 INT(M) 中，M 的值跟 INT(M) 所占多少存储空间并无任何关系。 INT(3)、INT(4)、INT(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，INT(M) 跟 INT 数据类型是相同的。当数据长度超过M时，相当于啥也没发生，正常显示。如果数据长度小于M，需要指定某个字符来填充。要查看出不同效果记得在创建类型的时候加 zerofill（见”列的属性”一节）这个值，表示用0填充，否则看不出效果的 浮点数类型 ​ 浮点数是用来表示小数的，平时用的十进制小数也可以转换成二进制后被计算机存储。比如9.875，这个小数可以被表示成这样： 19.875 = 8 + 1 + 0.5 + 0.25 + 0.125 = 1 × 2³ + 1 × 2⁰ + 1 × 2⁻¹ + 1 × 2⁻² + 1 × 2⁻³ 即，如果十进制小数9.875转换成二进制小数的话就是：1001.111。为了在计算机中存储这种二进制小数，统一把它们表示成 a*2^n 的科学计数法的形式，其中1&lt;=|a|&lt;2，比如1001.111可以表示为1.001111*2^3，我们把小数点后的001111成为尾数，把3称为指数，然后只需要在计算机中的比特位中表示出尾数和指数就行了。另外，小数也有正负之分，我们还需要单独的部分来表示小数的正负号。综上所述，表示一个浮点数需要下边几个部分： 符号部分：占用1个比特位即可 指数部分：视具体浮点数格式而定 尾数部分：视具体浮点数格式而定 ​ 很显然，表示一个浮点数使用的字节数越多，表示尾数和指数的范围就越大，也就是说可以表示的小数范围就越大。MySQL根据表示一个小数需要的不同字节数定义了如下的两种浮点数类型： 类型 占用的存储空间（单位：字节） 绝对值最小非零值 绝对值最大非零值 含义 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 MySQL中，FLOAT占4字节（1位符号位，8位表示指数，23位表示尾数），DOUBLE占8字节（1位符号位，11位表示指数，52位表示尾数）。这里以单精度浮点数类型FLOAT为例，它占用的4个字节的各个组成部分如下图所示： 另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的（即可能存在精度损失的问题）。 ​ 这里我们补充一下浮点数类型在内存中的存储方式： ​ 先来卡一下浮点数二进制表达的三个组成部分： ​ 三个主要部分是： 符号：表示浮点数是正数还是负数，0表示正数，1表示负数 指数部分：类似于科学计数法中的M*10^N^中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中以2^7^-1即127，也即01111111代表指数部分为0，转换时需要根据127作偏移调整。 尾数部分：浮点数中具体数值的实际表示。 ​ 下面展示实际转换过程： step 1：改写整数部分 ​ 以数值5.2为例。先不考虑小数部分，我们先单纯的将十进制数改写成二进制。即5转换为101 step 2：改写小数部分 ​ 把十进制的小数部分乘以2，取整数部分作为作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。 ​ 例如0.2可以转换为： ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ 0.6*2 = 1.2 1 ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ …… ​ 即最后转换结果为：.0011001……（它是一个无限循环的二进制数，明白为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况了吗） step 3：规格化 ​ 现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。 step 4：填充 ​ 指数部分（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。 ​ 尾数部分：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分1在填充时被舍去了。因为规格化后的数值整部部分总是为1。那省略整数部分后岂不是1.010011和0.010011就混淆了么？其实并不会，如果仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。（那么如何表示指数为-2的形式呢？即127-2=125，二进制表示为01111101） 举两个例子吧，比较直观一些（浮点数二进制转换工具） 1、9.875 其中打钩代表对应的二进制位为1，否则为0 2、0.3 ​ 设置最大位数和小数位数 ​ 在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，即 12FLOAT(M,D)DOUBLE(M,D) ​ 对我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M,D)或DOUBLE(M,D)来限制可以存储到本列中的小数范围。其中： M表示该小数最多需要的十进制有效数字个数 注意是有效数字个数，比如对于2.3，有效数字个数是2，对于0.9来说有效数字个数就是1 D表示该小数的小数点后的十进制数字个数 小数点后有几个十进制数字，D的值就是什么 举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化： 类型 取值范围 FLOAT(4,1) -999.9~999.9 FLOAT(5,1) -9999.9~9999.9 FLOAT(4,0) -9999~9999 FLOAT(4,2) -99.99~99.99 M取值范围为0~255。FLOAT只保证6位有效数字的准确性，所以FLOAT(M,D)中，M&lt;=6时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 D取值范围为0~30，同时必须&lt;=M。double只保证16位有效数字的准确性，所以DOUBLE(M,D)中，M&lt;=16时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 FLOAT和DOUBLE中，若M的定义分别超出7和17，则多出的有效数字部分，取值是不定的，通常数值上会发生错误。因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。 定点数类型 ​ 因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了定点数类型，它也是存储小数的一种方式： 类型 占用的存储空间（单位：字节） 取值范围 DECIMAL(M,D) 取决于M和D 取决于M和D ​ M和D的含义与浮点数中M和D的含义一样。但单精度浮点数类型FLOAT(M,D)占用的字节一直都是4字节，双精度浮点数类型DOUBLE(M,D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动。但对于定点数类型DECIMAL(M,D)来说，它占用的存储空间大小就和M、D的取值有关。 ​ 定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。如何才能保证精确存储呢？只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么。比如对于十进制小数9.85来说，我们可以把小数点左右的两个整数，也就是9和85分别保存起来，那么不就相当于保存了一个精确的小数。 ​ ​ 下面详细说一下DECIMAL(M,D)的存储方式，以DECIMAL(16,4)为例： 1、首先确定小数左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图： 2、从小数点位置出发，每个整数每隔9个十进制位划分为一组，如图： 从上图可以看出，如果不足9个十进制位，也会被划分为一组 3、针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表： 组中包含的十进制位数 占用的存储空间大小（单位：字节） 1或2 1 3或4 2 5或6 3 7或8或9 4 所以DECIMAL(16,4)共需要占用8个字节的存储空间大小，这8个字节由下边三个部分组成： 第一组包含3个十进制位，需要2个字节 第二组包含9个十进制位，需要4个字节 第三组包含4个十进制位，需要2个字节 4、 将转换完成的比特位序列的最高位设置为1 举个例子吧，要不这咋可能弄得懂嘛，哼！ 比如用DECIMAL(M,D)存储十进制小数1234567890.1234，这个小数会被分为三部分： 11 234567890 1234 然后将每一组中的十进制数字转换成对应的二进制数字 第一组占用2个字节，即对应的二进制数为： 100000000 00000001(0x0001) 第二组占用4个字节，整数234567890对应的十六进制数为 10x0DFB38D2 第三组占用2个字节，整数1234对应的十六进制数为 10x04D2 所以将这些十六进制数字连起来之后就是： 10x00010DFB38D204D2 ​ 最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(M,D)存储时共占用8个字节，具体为： 10x80010DFB38D204D2 ​ 如果用定点数类型DECIMAL(16,4)存储一个负数怎么办？比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就行，即 10x7FFEF204C72DFB2D ​ 对于定点数类型，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。 ​ 对于定点数类型DECIMAL(M,D)来说，M和D都是可选的，默认的M的值是10，默认的D的值为0，即 12DECIMAL = DECIMAL(10) = DECIMAL(10,0)DECIMAL(n) = DECIMAL(n,0) M的范围是1-65，D的范围是0-30，且D的值不能超过M。 ​ 注意：比如DECIMAL(5,2)，取值范围为-999.99~999.99 如果存储时，整数部分超出了范围（如1000.01）,MySQL就会报错，不允许存这样的值。 如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。 如：999.994实际被保存为999.99。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如999.995和-999.995都会报错。 无符号数值类型 ​ unsigned是MySQL自定义的类型，主要有以下用途： 起到约束数值的作用，即非负数 增加数值范围 unsigned可以用于整数、浮点数和定点数。MySQL提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词unsigned 1数值类型 unsigned 注意：在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。 二、日期时间类型​ MySQL提供了多种关于时间和日期的类型，各种类型能表示的范围如下： 类型 存储空间要求（单位：字节） 取值范围 含义 YEAR 1 1901~2155 年份值 DATE 3 ‘1000-01-01’ ~ ‘9999-12-31’ 日期值 TIME 3 ‘-838:59:59’ ~ ‘838:59:59’ 时间值 DATETIME 8 ‘1000-01-01 00:00:00’ ～ ‘9999-12-31 23:59:59’ 日期加时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ ～ ‘2038-01-19 03:14:07’ 时间戳 ​ 在MySQL5.6.4这个版本后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持，称为小数秒。MySQL最多支持6为小数秒的支持，各个位代表的意思如下： 如果想让TIME、DATETIME、TIMESTAMP支持小数秒，可以这样写： 12类型(小数秒位数)其中的小数秒位数可以在0,1,2,3,4,5,6中选择 比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果多了小数秒，就需要额外的存储空间： 保留的小数秒位数 额外需要的存储空间（单位：字节） 0 0 1或2 1 3或4 2 5或6 3 注意，要特别注意下DATETIME和TIMESTAMP的区别 占用空间不同，datetime占8字节，timestamp占用4字节 表示范围不同，timestamp表示当前时间到Unix元年（1970 年 1 月 1 日 0 时 0 分 0 秒）的秒数。 时区。timestamp以UTC的格式存储，它会自动检索当前时区并进行转换，datetime不会进行时区的检索。也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。比如 1set time_zone = "+9:00";(时区设为东九区) 此时就相当于是改变了时区。 如果存进去的是NULL，timestamp会自动存储当前时间，而datetime会储存NULL timestamp类型可以在修改时自动更新 1uptime timestamp default current_timestamp on update current_timestamp 三、字符串类型​ 字符是面向人的概念，如果想在计算机中表示字符，那就需要将该字符与一个特定的二进制序列对应起来，这个映射过程称为编码。但这种映射关系不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种： 固定长度的编码方案 表示不同的字符所需要的字节数量是相同的。比方说ASCII编码方案采用1个字节来编码一个字符，usc2采用2个字节来编码一个字符。 变长的编码方案 表示不同的字符所需要的字节数量是不同的。比如utf8编码方案采用1-3个字节来编码一个字符，gb2312采用1-2个字节来编码一个字符。 MySQL的字符串类型 ​ 下表示MySQL中提供的字符串类型，其中M代表该数据类型最多能存储的字符数量，L代表实际向该类型中存储的字符串在特定字符集下所占的字节数，W代表该特定字符集下，编码一个字符最多需要的字节数： 类型 最大程度 存储空间要求 含义 CHAR(M) M个字符 M*W个字节 固定长度字符串 VARCHAR(M) M个字符 L+1或L+2个字节 可变长度字符串 TINYTEXT 2^8^-1个字节 L+1个字节 非常小型的字符串 TEXT 2^18^-1个字节 L+2个字节 小型的字符串 MEDIUMTEXT 2^24^-1个字节 L+3个字节 中等大小的字符串 LONGTEXT 2^32^-1个字节 L+4个字节 大型的字符串 CHAR(M) ​ M是该类型最多可以存储的字符数量（非字节数量），M的取值范围是0-255。如果省略掉M的值，那它的默认值就是1，也就是说CHAR和CHAR(1)是一个意思。CHAR(0)是一种特别的类型，它只能存储空字符串或者NULL值。 ​ CHAR(M)在不同的字符集下需要的存储空间也是不一样的，我们假设某个字符集编码一个字符最多需要W个字节，那么类型CHAR(M)占用的存储空间大小就是M×W个字符。比方说： 对于采用ASCII字符集的CHAR(5)类型来说，ASCII字符集编码一个字符最多需要1个字节，也就是M=5，W=1，所以占用的内存空间大小是5*1=5个字节。 对于采用gbk字符集的CHAR(5)类型来说，gbk字符集编码一个字符最多需要2个字节，也就是M=5，W=2，所以占用的内存空间大小是5*2=10个字节。 对于采用utf8字符集的CHAR(5)类型来说，utf8字符集编码一个字符最多需要3个字节，也就是M=5，W=3，所以占用的内存空间大小是5*3=15个字节。 ​ 如果我们实际存储的字符串在特定字符集编码下占用的字节数不足M*W，那么剩余的那些存储空间用空格字符补齐。即一旦确定了CHAR(M)类型的M，如果M的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费。 VARCHAR(M) ​ 如果某个列存储的字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，因此可以使用VARCHAR(M)。 ​ VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是1-65535。但是，MySQL中有一个规定，表中某一行包含的所有列中存储的数据大小总共不能超过65535个字节，也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。 ​ VARCHAR(M)类型表示的数据由以下两部分组成： 1、真正的字符串内容 ​ 假设真正的字符串在特定字符集编码后占用的字节数为L 2、占用字节数 ​ 假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么： 当M*W&lt;256时，只需要一个字节来表示占用的字节数 当M*W&gt;=256且M*W&lt;65536时，需要两个字节来表示占用的字节数 （因为一个字节能表示的最大无符号数是255，两个字节能表示的最大无符号数十65535） 各种TEXT类型 ​ 虽然VARCHAR(M)已经可以存储很长的字符串了，可有时候还是不够怎么办？对于很长的字符串，可以用TEXT存储大型字符串，它们都是变长类型。 ​ MySQL有个规定，某一行包含的所有列中存储的数据大小总和不得超过65535个字节。这个规定对于这些TEXT类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了。 ENUM类型和SET类型 ENUM类型称为枚举类型，它表示在给定的字符串列表里选择一个。比如性别，只能在’男’和’女’里面选一个，相当于一个单选框 1ENUM('str1','str2','str3',...) SET类型表示可以在给定的字符串列表里选择多个。比如兴趣列表，相当于一个多选框 1SET('str1','str2','str3',...) 综上所述，ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。 四、二进制类型 BIT类型 ​ 有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型： 类型 字节数 含义 BIT(M) 近似为(M+7)/8 存储M个比特位的值 M默认为1，M的取值范围为1~64，M可以省略，即BIT和BIT(1)一样。 BINARY(M)和VARBINARY(M) ​ 前者是固定长度的类型，后者是可变长度的类型，其中M代表该类型最多能存放的字节数量。 其它的二进制类型 ​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB是针对数据量很大的二进制数据提出的，比如图片、音乐、压缩文件啥的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句使用注意事项]]></title>
    <url>%2F2019%2F10%2F25%2FMySQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[​ MySQL的基本运行过程是：通过客户端发送命令给服务器程序，服务器程序按照接收的命令去操作实际的数据。在我们使用黑框框启动了MySQL客户端程序之后，界面上会一直显示一行字儿：mysql&gt;，这是一个提示符，你可以在它后边输入我们的命令然后按下回车键就把命令从客户端程序发送到了服务器程序，在书写命令的时候需要注意下边这几点： 1、命令结束符号 ​ 在书写完一个命令后需要以下面几个符号之一结尾： ； \g \G 其中；和\g的效果一样，如下所示： 123456789101112131415161718192021mysql&gt; show tables;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+mysql&gt; show tables\g+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 其中\G有一点特殊，它并不以表格的形式返回查询结果，而是以垂直的形式将每个列都展示在单独的一行中： 1234567891011mysql&gt; show tables\G*************************** 1. row ***************************Tables_in_run: student_info*************************** 2. row ***************************Tables_in_run: student_score*************************** 3. row ***************************Tables_in_run: t1*************************** 4. row ***************************Tables_in_run: t1_view*************************** 5. row ***************************Tables_in_run: t2 如果查询结果的列数非常多的话，使用\G可以让我们看清结果。 注意：使用Navicat第三方工具是不支持\g和\G的，只能在cmd界面中使用。 2、命令可以随意换行 ​ 并不是按了回车键就提交命令了，只要按回车键的时候输入的语句里没有；、\g或\G这些语句结束符号，该语句就算是没有结束。比如上面的语句可以写成： 123456789101112mysql&gt; show -&gt; tables -&gt;;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 3、可以一次提交多个命令 ​ 我们可以在一条语句里面写多个命令（命令之间用上面说的结束符间隔，但记住在写完前不要回车），只要没按回车键，就不会提交命令，如： 1234567891011121314151617181920212223mysql&gt; SELECT NOW(); SELECT NOW(); SELECT NOW();+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)mysql&gt; 4、使用 \c 放弃本次操作 ​ 如果你想放弃本次编写的命令，可以在输入的命令后边加上\c，比如 12mysql&gt; SELECT NOW()\cmysql&gt; 如果不使用\c，那客户端会以为这是一个多行命令，还在一直傻傻的等你输入命令。 注意：\c在Navicat第三方软件中不能用，只能用于cmd窗口中。 5、大小写 ​ MySQL默认对命令的大小写并没有限制。但是如果是表、列的名称就会对大小写敏感了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL密码错误如何修改？]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[​ 前两天我在用MySQL的时候，出现了一个小问题：就是我在注册完windows服务后，然后用net start MySQL80登录到数据库服务器，却无法使得客户端连接到服务器，即在输入完mysql -uroot -p后，会报如下的错误： (这种问题一般是由于密码错误引起的) ​ 于是我就查了一个解决方法，特此记录一下： 1、首先打开一个cmd窗口A： 首先关闭MySQL服务器 1net stop MySQL80 无密码启动MySQL服务 1mysqld --console --skip-grant-tables --shared-memory 2、再开一个cmd窗口B： 无密码登录（密码处直接enter） 12mysql -uroot -p//注意下面出现密码时，直接enter即可连接至MySQL 免密码登录设置空密码 ​ 设置空密码 1UPDATE mysql.user SET authentication_string=&apos;&apos; WHERE user=&apos;root&apos; and host=&apos;localhost&apos;; ​ 刷新 1flush privileges; 设置加密的密码 ​ 以caching_sha2_password加密密码并设置 1ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH caching_sha2_password BY &apos;新密码&apos;; ​ 刷新 1flush privileges; 这样修改完之后，就可以设置新的密码了，也就可以解决上述问题。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初始化与启动那些事]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL采用客户端/服务端架构，即它是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可以有多种形式，比如手机APP，电脑软件或者网页版微信。每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器程序，我们平时操作微信其实都是用客户端来和这个服务器来打交道。 ​ MySQL的使用过程大概为：它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器程序就响应这些请求，从而操作它维护的数据。日常使用MySQL的场景一般是这样的： 启动MySQL服务器程序 启动MySQL客户端程序并连接到服务器程序 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。 MySQL默认安装位置：C:\Program Files\MySQL\MySQL Server 8.0\，也可以自定义安装路径，为了方便就按照默认路径来安装吧~ 如何启动MySQL服务器程序？​ 这里以windows系统为例介绍。在windows系统下提供了手动启动和以服务的形式启动两种启动方式。 以服务的形式启动 ​ 什么是windows服务呢？如果需要长时间的运行某个程序，而且需要在计算机启动的时候启动它，一般我们都会把它注册为一个windows服务，操作系统会帮助我们管理它。 在MySQL根目录下(C:\Program Files\MySQL\MySQL Server 8.0)手动创建一个data文件夹 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld install MySQL80 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld --initialize-insecure --user=mysql80 打开MySQL服务器程序： 12net start MySQL80 //打开net stop MySQL80 //关闭 手动启动 ​ MySQL安装目录下的bin目录下的mysqld可执行文件代表着服务器程序，我们运行这个可执行文件就会启动MySQL服务器。 ​ MySQL服务器运行过程中严重依赖一个称之为数据目录的路径，不过我们安装MySQL时使用的MySQL Installer把这个数据目录的路径设置为了： 1C:\ProgramData\MySQL\MySQL Server 8.0\data 当然不同版本的MySQL Installer可能将数据目录的路径设置为不同的值。 ​ 在使用mysqld可执行文件启动MySQL服务器程序时，它默认并不会将上述路径设置为数据目录的路径，此时需要我们在启动MySQL服务器时显式地指定一个称之为datadir的参数，该参数就代表着数据目录的路径，所以使用下面的命令启动MySQL服务器： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; 特别要注意的是，当我们按下回车键后，cmd命令窗似乎卡住不动了，这就意味着MySQL服务器启动了，如果此时我们把这个cmd命令窗关掉，或者按下Ctrl+C键，就会停止MySQL服务器程序的运行。因此，还是推荐使用windows服务的方式来启动或停止MySQL服务器程序。 ​ 如果想查看使用mysqld启动MySQL服务器的过程中输出的日志信息，可以在上述命令后边加上—console： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; --console 如何启动MySQL客户端程序？​ 在服务器程序启动之后（不管是使用mysqld可执行文件启动的还是使用Windows服务的方式启动的），就可以接着启动客户端程序来连接到这个服务器喽。bin目录下有许多客户端程序，比方说mysqladmin、mysqldump、mysqlcheck等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件mysql.exe，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求以及接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下： 1mysql -h主机名 -u用户名 -p密码 参数意义： 参数名 含义 -h 表示启动服务器程序的计算机的域名或者IP地址，如果服务器程序就运行在本机的话，可以省略这个参数，也可以填localhost或127.0.0.1。也可以写成—host=主机名 -u 表示用户名，作为超级管理员的我们的用户名是root。也可以写成—user=root -p 表示密码。也可以写成—password=密码 连接注意事项 最好不要再一行命令中输入密码 这样容易导致密码泄露，可以这样写 1mysql -hlocalhost -uroot -p 如果非要显示的把密码写出来，那密码值和-p之间不能有空格，其他参数之间可以有空格。且各个参数的摆放顺序没有硬性规定。 如果你的服务器和客户端安装在同一台机器上，-h参数可以忽略，就像这样 1mysql -uroot -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客如何迁移至其它电脑]]></title>
    <url>%2F2019%2F07%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[​ 当你在一台电脑上写博客写的蛮爽的，但突然有一天你的电脑坏了或者被偷了咋办？你那些本地的博客可咋整！一想到这种有可能发生的危险，我就夜不能寐呀。于是我就开始疯狂地查找资料，但网上的资料良莠不齐。于是本人就自己慢慢的摸索嘛，这是一个程序员最基本的素质(其实还是自己太菜了)。下面我就把我的总结写一下，希望能对以后的自己和大家有帮助。 1、在新电脑上安装NodeJs和Git​ 这一步很简单，具体怎么安装，可以参见我的上一篇博文：利用hexo框架搭建个人博客(手把手教学) 2、GitHub新建分支​ 在pringce.github.io仓库下： 这里的分支名可以任意设置。 3、设置分支为默认仓库当前仓库-&gt;Settings-&gt;Branches-&gt;Default Branch 4、clone至本地​ 将该分支克隆至本地 1git clone https://github.com/pringce/pringce.github.io.git ​ cd进入 clone 下来的pringce.github.io文件夹，在此文件夹目录下git bash执行git branch命令，应该是新建的分支名 new。 5、新电脑生成ssh key并添加至GitHub​ 依次按照下述步骤生成本机ssh key： 1git config --global user.email "GitHub注册并验证时的邮箱" 1git config --global user.name "GitHub用户名" 1ssh-keygen // 一直按enter就行 在本机目录“C:\Users\10530\.ssh”会生成两个文件：id_rsa(私钥)和id_rsa.pub(公钥)。打开id_rsa.pub，复制里面的内容到GitHub: Settings -&gt; SSH and GPG keys -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key 测试是否成功： 1ssh -T git@github.com 输出 You’ve successfully authenticated 表示添加key 成功。 6、安装hexo1npm install hexo-cli -g 7、将原博客文件拷贝至pringce.github.io文件夹​ 将原博客文件夹下的文件拷贝至pringce.github.io，需要拷贝6个：_config.yml（站点配置文件）、themes\（主题）、source\（博客源文件）、scaffolds\（文章的模板）、package.json、.gitignore。 此时，我们不需要再用hexo init来生成博客了，因为需要的文件我们已经拷贝过来了。 8、提交本地至new分支​ 进入pringce.github.io文件夹，依次执行 1git add . 1git commit -m &quot;新电脑&quot; 1git push 这样，master分支用于保存博客静态资源，提供博客页面供人访问；new分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突。 9、安装hexo依赖的包1npm install ​ 所依赖的包都在上一步中的package.json备份文件里，所以直接这一个命令就可以了。就可以把你以前配置的那些包都安装上了。 10、新旧电脑更新博客​ 依次按照以下步骤来更新博客： 1git pull 1hexo new &quot;name&quot; 1hexo clean 1hexo g 1hexo s(测试时候在localhost看一下) 1hexo d(部署) 1git add . 1git commit -m &quot;新电脑&quot; 1git push //保证new分支版本为最新 因此，如果我们电脑又坏了或者又被偷了。。。那我们可以先获得新电脑的ssh key，然后添加到GitHub。然后把new分支下文件git clone下来，然后再新建、编辑、部署一步一步来即可。 好啦，心理的最大隐患解除了，可以安心睡觉啦。大家晚安！！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树全解析]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言​ 其实大家都说决策树简单，但个人觉得如果想学好这个算法其实还是需要下一些功夫的。决策树是一种基本的分类与回归方法(不要觉得决策树只能分类哦，它也可以做回归的)。 ​ 为了方便下面的讨论，我们先做一下说明： ​ 假设有一组训练数据 D=(x1,y1),(x2,y2),\cdots,(xn,yn)​ 表示有n个样本，样本共分为K类情况下，yi的取值来自K个类别值 (C1,C2,\cdots,Ck) ​ 另外，无论是ID3树、C4.5树还是CART树都是差不多的，都由特征选择(分裂特征选择算法)、树的生成和剪枝组成。它们之间的区别主要是特征选择和剪枝算法不同，这些我们后面会详细讨论，这里先留个伏笔。 ID3树​ 在介绍ID3决策树之前，我想先说一个概念：信息增益。 ​ 一个离散型随机变量x的概率分布为 P(x=x_i)=p_i​ ，则x的信息熵定义为 H(x)=-\sum_{i=1}^{n}{p_i}​ 数据集的熵表征其类别的不确定程度，而数据集关于某个特征的条件熵则表征着给定某个特征后，其类别的不确定程度： 数据集的熵—条件熵 = 该特征使数据集不确定性减小程度 设数据集D的熵为H(D)，关于特征Am的条件熵为H(D|Am)，因此可以获得信息增益为 g(D|A_m)=H(D)-H(D|A_m)其中， H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|}}log_2\frac{|C_k|}{|D_k|} H(D|A_m)=\sum_{i=1}^{K}{\frac{|D_i|}{|D|}}H(D_i)​ Di 表示训练样本中特征A取值为 ai 的样本点集合(比如说特征A有三个可能的取值，则K为3)。 ID3决策树构建​ 自根节点开始，选择信息增益最大的特征作为节点的分类特征，并根据该特征的可能取值将训练数据分配到不同的子节点(对子节点进行同样的操作)。 ​ 若子节点的所有样本属于同一类别或该子节点处所有特征的信息增益均小于给定阈值或无可供选择的特征，此时我们判定该子节点为一个叶节点，将该叶节点的样本数量最多的类别作为该叶节点的类别。 ​ 算法步骤如下： 若D中样本特征为空，那么树T为一棵单节点树，将样本数量最大的类别作为节点类别，返回T。否则转到第二步； 计算D关于所有特征的信息增益，若信息增益均小于某一阈值，则T为单节点树。否则转到第三步； 选择信息增益最大的特征作为分裂特征，依据该分裂特征的所有可能取值建立相应子节点。若子节点样本全为同一类别，则子节点为叶节点。若均为叶节点，返回T。否则转到第四步； 对非叶节点 i，以 Di 为训练集，将特征集减去刚才的分裂特征(这里特别需要注意一点，如果该特征是类别特征，则在分裂完成后删除该特征；如果为连续特征，则不删除该特征)，以得到新的特征集，然后递归调用第一步至第三步。 总结 ID3树在选取分裂特征时采用信息增益原则(其实个人理解，无论是ID3、C4.5还是CART树，在选取分裂特征时，基于的总原则都是使分裂前后的数据复杂度减少程度最多，因为选取该特征才能使得这样构建出来的决策树分类或回归效果最好)。 ID3树后剪枝的策略是PEP(悲观误差剪枝)，这里后面再介绍，这里先占个坑哈哈哈。 C4.5树​ 上述ID3树采用的是信息增益来进行节点分裂特征的选取。信息增益原则对于每个分支节点，都会乘以其权重，也就是说，由于权重之和为1，所以分支节点分的越多，即每个节点数据越少，纯度可能越高。这样会导致信息增益准则偏爱那些取值数目较多的属性。 ​ 为了解决该问题，引入了信息增益率，这个也就是C4.5树的分裂准则。C4.5树的基本构建流程与ID3树类似，唯一的区别就是C4.5树采用信息增益率进行特征选择，而ID3树采用信息增益进行特征选择。 ​ 信息增益率的定义如下： G_{ratio}=\frac{g(D|A_m)}{H_{A_m}(D)}​ 其中， H_{A_m}(D)=-\sum_{i=1}^{K}\frac{|D_i|}{|D|}log2{\frac{|D_i|}{|D|}}​ 需要注意的是，信息增益率原则可能对取值数目较少的属性更加偏爱。因此，C4.5并不是直接选择增益最大的候选划分属性。为了解决这个问题，C4.5采用了一种启发式算法，可以先从候选划分属性中找出信息增益在平均值以上的属性，再从中选择信息增益率最高的。 CART树​ 这里先强调一点，CART树是二叉树。与ID3和C4.5的决策树所不同的是，ID3和C4.5生成的决策树可以是多叉的，每个节点下的叉树由该节点特征的取值种类而定，比如特征年龄分为(青年，中年，老年)，那么该节点下可分为3叉。而CART决策树为二叉树，内部节点特征取值为“是”和“否”。左分支取值为“是”，右分支取值为“否”。因此在搜索分裂特征时，是递归地二分每一个特征。个人理解为不仅要遍历每一个特征，还要遍历每一个特征的二分取值，等于是做了一次双层遍历。相比于ID3和C4.5要更加复杂一些。 ​ 另外，我们还需要注意一点，ID3和C4.5只能用于分类，而CART树既可以用于分类，也能用于回归。 ​ CART树的基本构建流程与ID3树和C4.5树类似。唯一的区别就在于特征选择准则不同，另外CART树不仅要选择最优特征，还要选择最优二值切分点。别的都一样哈哈哈！！ ​ CART分类树特征选择​ CART分类树通过基尼指数选择最优特征，同时决定该特征的最优二值切分点，而ID3和C4.5直接选择最有特征，不用划分二值点。 ​ 这里先介绍一下基尼指数，我个人的理解是基尼指数和前面的信息熵的概念是一样的，都是表征数据集的不纯度，因此我们如何选择最优特征和最优二值切分点呢？也就是分裂后如何使基尼指数下降最大！ ​ 分类问题，假设有数据集D有K个类，样本点属于第k个类的概率为 pk，则基尼指数定义为 Gini(D)=1-\sum_{k=1}^{K}p_k^2​ 在特征A下，集合D的基尼指数定义为 Gini_A(D)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)​ 那么如何选择最优特征和最优二值切分点呢？就是使切分前后的不确定性下降最大！即切分前的基尼指数和在特征A下切分后的基尼指数之间的差越大，越应该为最优特征和最优二值切分点。同理也可以得到，在特征A下切分后的基尼指数越小，越应该为最优特征和最优二值切分点。 CART回归树特征选择​ 跟CART分类树大致相同，区别主要在以下几点： ​ 分裂准则：选择特征A以及对应的属性值s将当前节点分到两个区域 R1 和 R2 中， R_1={(x|x_is)}​ 如何选择呢？就是使上述两个区域的均方误差和最小！ ​ 最终预测值：最终节点值为该节点下所有数据的平均值。 剪枝​ 剪枝很好理解，它的目的就是防止过拟合。它主要分为预剪枝和后剪枝。 预剪枝 通过提前停止树的构建而对树剪枝。一旦停止，节点就是叶节点。 停止决策树生长最简单的方法有： 定义一个高度，当决策树达到该高度时就停止决策树的生长； 当节点实例个数小于某一阈值； 当分裂增益小于某一阈值。 后剪枝 ​ 它首先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的结点子树用叶子结点来代替，该叶子的类标号用该结点子树中最频繁的类标记。相比于先剪枝，这种方法更常用，正是因为在先剪枝方法中精确地估计何时停止树增长很困难。 ​ 后剪枝方法主要有以下几个方法： ​ Reduced-Error Pruning(REP，错误率降低剪枝） ​ Pessimistic-Error Pruning(PEP，悲观错误剪枝） ​ Cost-Complexity Pruning（CCP，代价复杂度剪枝) REP REP方法是一种最简单的后剪枝方法，对每个非叶子节点，从下往上遍历，尝试将该子树从叶子节点代替。然后利用验证集进行验证，看精度是否提升。若提升，则剪枝。这种方法一般不采用。 PEP PEP的策略主要用于ID3和C4.5树。悲观错误剪枝法是根据剪枝前后的错误率来判定子树的修剪。 把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代的话，在训练集上的误判率肯定是上升的，但是在新数据上不一定。于是我们需要把子树的误判计算加上一个经验性的惩罚因子。 对一个叶子节点，有n个样本，其中e个错误，则该叶子节点错误率为 (e+0.5)/n其中，0.5为惩罚因子 对一棵子树，有L个叶子节点，则该子树的错误率为 err\_ratio=\frac{(\sum_{i=1}^{L}e_i)+0.5L}{\sum_{i=1}^{L}n_i}这样的话，我们可以看到一颗子树虽然具有多个子节点，但由于加上了惩罚因子，所以子树的误判率计算未必占到便宜。 我们可以得到子树的错误次数均值和标准差 err\_mean=err\_ratio*\sum_{i=1}^{L}n_i err\_std=\sqrt{err\_ratio*\sum_{i=1}^{L}n_i*(1-err\_ratio)}当把子树替换成叶子节点后，该叶子节点的错误率和错误次数均值为 err\_ratio^{'}=\frac{(\sum_{i=1}^{L}e_i)+0.5}{\sum_{i=1}^{L}n_i} err\_mean^{'}=err\_ratio^{'}*\sum_{i=1}^{L}n_i剪枝条件为： err\_mean+err\_std>=err\_mean^{'}PEP的缺点： PEP算法采用的是自上而下的剪枝策略，这种剪枝会导致和预剪枝同样的问题，即剪枝过度。 CCP CCP的策略主要用于CART树。 代价指在剪枝过程中因子树 Tt 叶节点替代而增加的错分样本，复杂度表示剪枝后子树 Tt 减少的叶结点数，则定义每个非叶节点剪枝后树的复杂度降低程度与代价间的关系： α(t)=\frac{C(t)-C(T_t)}{|T_t|-1}其中， C(t) = r(t) * p(t)代表剪枝后叶子节点的误差代价 对于分类树，r(t) 为该节点的错误率；对于回归树，代表该节点的均方误差。 p(t) 为该节点数据占总数据的比例。 C(T_t)=\sum_{i=1}^{m}r_i(t)p_i(t)代表剪枝前的子树误差代价 对于分类树，ri(t) 为该子树某叶子节点的错误率；对于回归树，代表该子树某叶子节点的均方误差。 pi(t) 为该子树某叶子节点占总数据的比例。 CCP剪枝算法分为两个步骤： 对于完全决策树 T 自下而上的计算每个非叶结点的 α 值，然后自上而下的循环(注意，每剪枝一次，就重新计算表面误差增益率，再循环第一步)剪掉具有最小 α 值的子树(自上而下代表若有多个非叶子节点的表面误差率增益值相同小，则选择非叶子节点中子节点数最多的非叶子节点进行剪枝)，直到剩下根节点。在该步可得到一系列的剪枝树序列｛T0，T1，T2……Tn｝,其中 T0 为原有的完全决策树，Tn为根结点，Ti+1为对 Ti 进行剪枝的结果； 从子树序列中，根据真实的验证集误差选择最佳剪枝后决策树。 例. 下图是一棵子树，设决策树的总数据量为40 C(t)=\frac{8}{18}*\frac{18}{40}=\frac{1}{5} C(T_t)=\frac{1}{3}*\frac{3}{40}+\frac{4}{9}*\frac{9}{40}+\frac{1}{6}*\frac{6}{40}=\frac{6}{40} α(t)=\frac{\frac{1}{5}-\frac{6}{40}}{3-1}=\frac{1}{40}​ 好啦，到了这里，基本就把所有的决策树知识说完啦！希望能对大家有帮助。]]></content>
      <categories>
        <category>机器学习算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo框架搭建个人博客]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%88%A9%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言​ 本文是在Windows 10环境下搭建个人博客，对于Linux和Mac环境，搭建工作基本类似，区别无非在于个别命令行指令的区别，读者只需作相应的调整即可。 1. 安装NodeJs​ hexo是基于NodeJs环境的静态博客，里面的npm工具很有用（个人感觉类似于python里面的pip或者anaconda里面的conda，是一个包管理工具），所以说NodeJs是搭建个人博客的第一步。 下载地址：https://nodejs.org/en/ 下载下图的10.16.0 LTS即可。 然后点击下载的安装包，无脑点yes安装即可。至此NodeJs已经全部安装完成。 2. 安装Git Bash​ 由于本人使用的是Windows环境，cmd指令过于难用（也难怪众多开发者投入了Linux的怀抱）。所以本人下载了Git Bash（其实也就是下载了Git工具）。在网上搜索Git可以下载一个下面这个应用程序： ​ 然后依旧无脑点yes，安装完成后，在左面点击鼠标右键，如果出现了Git Bash和Git GUI即代表Git安装成功。 ​ 然后打开Git Bash可以查看NodeJs和npm的版本： NodeJs版本 1$ node -v npm版本 1$ npm -v 3. 安装hexo​ 我们是需要借助npm来安装hexo框架的。但是由于墙的原因，国内使用npm的下载速度很慢。因此我们需要更换源（使用淘宝的那个源），利用npm来安装一个cnpm。安装完成后，后面完全可以用cnpm全面取代npm。 ​ 如何安装cnpm？ 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 安装完成后，可以查看一下cnpm的版本 1$ cnpm -v ​ 随后，开始正式安装hexo框架 1$ cnpm install -g hexo-cli ​ 如何判断hexo是否安装成功，我们只需要查看hexo的版本，如果出现版本信息，则代表hexo安装成功 1$ hexo -v 4. 开始正式搭建博客​ 首先我们需要先建立一个空的目录，存储我们的博客信息。这样的好处就是，一旦这个博客出错了或者你不想要了，直接把这个文件夹删除即可，不会影响其他的文件，保持独立性。 12$ mkdir blog$ cd blog ​ 随后在blog目录下利用hexo生成博客，很简单 1$ hexo init ​ 可以看到，生成完成后会出现下面这些文件 ​ 随后启动博客 1$ hexo s ​ 可以看到，博客可以在本地的4000端口进行访问 ​ 我们利用浏览器打开该端口，即可访问到我们最初始的博客。该博客默认有一篇hello word的博文 ​ 随后我们可以新建一篇文章，里面写上我们想要的内容即可。如何新建一篇文章？ 1$ hexo new &quot;我的第一篇文章&quot; ​ 生成完成后，便可以在blog/source/_post目录下找到我们生成的这篇文章，文件名为”我的第一篇文章.md”。随后便可以用Typora来写该博客了（markdown语法）。 ​ 因为我们现在新建了一篇文章，如何把它上传呢？（即在浏览器中也可以看到改文章）。这里就要用到hexo中著名的“素质三连”指令了 123$ hexo clean (清理)$ hexo g (生成)$ hexo s (启动) ​ 随后便可以在本地4000端口看见我们刚才新建的那篇文章了。 一切都是这么简单，一切都是这么优雅！ 5. 远端部署​ 我们写个人博客的目的不是为了只自己访问，也希望别人能看见，因此需要部署到远端服务器。这里有一种免费的部署方式，即把我们的博客部署到github上公开使用。 5.1 新建仓库 ​ 一定要注意仓库的命名方式，仓库的名称一定要和你的github昵称保持一致，否则将无法访问。例如我的github昵称为pringce，那么仓库的名称一定要命名为pringce.github.io。如下图 5.2 安装Git部署插件1$ cnpm install hexo-deployer-git --save 5.3 配置config文件​ 在我们的blog目录下，找到_config.yml这个文件，然后到文件的最底部，写入如下配置 5.4 部署到远端1$ hexo d ​ 随后输入”https://pringce.github.io&quot;，即可访问我们部署到远端服务器上的博客了。至此任何人都可以访问你的博客了，博客的部署工作完成。 一切都是这么简单，一切都是这么优雅！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
