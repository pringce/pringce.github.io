<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[方法调用时的参数传递问题]]></title>
    <url>%2F2020%2F04%2F04%2F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java方法在调用的时候，需要传递参数。参数一般有两种数据类型：基本数据类型和引用数据类型。下面我们分别针对这两种类型分析一下参数在传递的时候发生了些什么？ 基本数据类型 12345678910111213public class test&#123; public static void main(String[] args)&#123; int i = 10; // add方法在调用的时候，给add方法传递了一个变量i，到底传递的是什么？ add(i); System.out.println(i); // 10 &#125; public static void add(int i)&#123; i++; System.out.println(i); // 11 &#125;&#125; 上述代码内存结构如图所示 Java语言当中方法调用的时候需进行参数传递，参数传递实际上传递的是变量中保存的具体值，与变量无关（相当于复制了一份）。所以上面add方法里对i进行自增，不影响main函数里的i变量。 引用数据类型 1234567891011121314151617181920public class test&#123; public static void main(String[] args)&#123; User u = new User(20); add(u); System.out.println(u.age); // 21 &#125; public static void add(User u)&#123; u.age++; System.out.println(u.age); // 21 &#125;&#125;class User&#123; int age; public User(int age)&#123; this.age = age; &#125;&#125; 上述代码内存结构如图所示 上面在传递参数的时候，还是传递的是变量中保存的值。但这里保存的是堆内存地址，所以这里传递的是地址。但本质上和上面是一样的。 最终结论：方法调用的时候，涉及到参数传递问题，java只遵循一种语法机制，就是将变量中保存的值传递过去了。只不过有时候这个值是一个字面值（比如10），有时候这个值是另一个java对象的内存地址（比如0x1234）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象封装性]]></title>
    <url>%2F2020%2F04%2F03%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[下面先举个小例子 1234567891011121314151617// user.javapublic class user&#123; // 这里的age属性显然完全暴露给外部程序的，对于程序员来说可以操作user对象当中所有的细节，导致user中部分数据不安全 // 不建议这样，建议user类型进行封装，建议在外部程序中不能随意访问user对象中的属性，这样可以保证属性的安全 int age;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 下面代码可以顺利编译运行，但是存在逻辑问题，因为年龄不可能是负数 u.age = -100; System.out.println(u.age); &#125;&#125; 对上述代码而言，user类中的age属性在外部程序可以随意访问，导致age属性不安全。一个user对象表示一个用户，用户的年龄不可能是负数。 封装的好处： 封装之后，对于那个事物来说，看不到这个事物比较复杂的那一面，只能看到该事物简单的那一面。复杂性封装，对外提供简单的操作入口。照相机就是一个很好的封装的案例，照相机的实现原理非常复杂。但是对于使用照相机的人来说，操作起来是非常便捷的。还有电视机也是封装的，电视机内部实现非常复杂，但是对于使用者来说不需要关心内部的实现原理，只需要会操作遥控器就行 封装之后才会形成真正的对象，真正的独立体 封装就意味着以后的程序可以重复使用，并且这个事物适应性比较强，在任何场合都可以使用 封装之后，对于事物本身，提高了安全性（安全级别高） 封装的步骤： 所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问 对外提供简单的操作入口，也就是说以后外部程序要想访问age属性，必须通过这些简单的入口进行访问 对外提供两个公开的方法，分别是set方法和get方法 想修改age属性，调用set方法 想读取age属性，调用get方法 set方法的命名规范： 123public void setAge(int a)&#123; age = a;&#125; get方法的命名规范： 123public int getAge()&#123; return age;&#125; 注意 setter和getter方法没有static关键字 有static关键字修饰的方法怎么调用：类名.方法名(实参) 没有static关键字修饰的方法怎么调用：引用.方法名(实参) 12345678910111213141516// user.javapublic class user&#123; private int age;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 编译报错 // age属性私有化，在外部程序中不能直接访问 // 从此之后age属性非常的安全，但是有点太安全了 // 对于目前的程序来说，age属性彻底在外部访问不到了 System.out.println(u.age); &#125;&#125; 回想一下，一个属性通常访问的时候包括几种访问形式？ 第一种方式：想读取这个属性的值，读取get 第二种方式：想修改这个属性的值，修改set 下面介绍一下封装后该怎么写？ 12345678910111213141516171819202122232425262728293031// user.javapublic class user&#123; private int age; // set方法没有返回值，因为set方法只负责修改数据 // setter public void setAge(int age)&#123; // 编写业务逻辑代码进行安全控制 if(age&lt;0 || age&gt;150)&#123; System.out.println("不符合逻辑！"); return; &#125; this.age = age; &#125; // getter public int getAge()&#123; return age; &#125;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; user u = new user(); // 修改 u.setAge(20); // 读取 System.out.println(u.getAge()); &#125;&#125; 这样的话，如果利用setAge()给age赋值为-100的时候，就会报错。这样就可以保证安全性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建与使用-内存分析]]></title>
    <url>%2F2020%2F04%2F03%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[首先定义一个学生类，学生类是一个模板，描述了所有学生的共同特征（状态+行为）： 1234567891011121314151617181920212223// student是类，属于引用数据类型，这个类型名就是studentpublic class student&#123; // 类体：属性+方法 // 学号 int number; // 属性（存储数据采用变量的形式） // 由于变量定义在类体当中，方法体之外，这种变量称为成员变量 // 所有学生都有学号信息，但是每一个学生的学号都是不同的 // 所以要访问这个学号必须先创建对象，通过对象去访问学号信息 // 学号信息不能直接通过类去访问，所以这种成员变量又称为实例变量 // 对象又被称为实例，实例变量又被称为对象变量（对象级别的变量） // 不创建对象，这个number变量的内存空间是不存在的，只有创建了对象，这个number内存空间才会创建 // 姓名 String name; // 年龄 int age; // 性别 boolean sex; // 住址 String addr;&#125; 对象的创建与使用通过一个类可以实例化N个对象，实例化对象的语法： 1student s = new student(); new是Java语言当中一个运算符，它的作用是创建对象，在JVM堆内存当中开辟新的内存空间 方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中 栈内存（存储局部变量）：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈 堆内存：new的对象在堆内存中存储 123456789101112131415public class test&#123; public static void main(String[] args)&#123; // i是一个变量名，10是一个int类型字面值 int i = 10; // student是一个引用数据类型 // s是一个变量名 // new student()是一个学生对象 // s是一个局部变量（在栈内存中存储） // 什么是对象？new运算符在堆内存中开辟的内存空间称为对象 // 什么是引用？引用是一个变量，只不过这个变量中保存了另一个java对象的内存地址 // 这里的s被称为一个student对象的引用 student s = new student(); &#125;&#125; 下面介绍一下上述代码的内存分析 首先说明：成员变量没有手动赋值的话，系统赋默认值（局部变量不会，如果不赋值就访问局部变量会报错） 数据类型 默认值 byte,short,int,long 0 flaot,double 0.0 boolean false char ‘/u0000’ 引用数据类型 null 内存分析如下所所示： Java语言当中，程序员不能直接地操作堆内存，java中没有指针，不像C语言。java语言当中，程序员只能通过引用去访问堆内存当中对象内部的实例变量。访问实例变量的语法格式： 1234// 读取数据引用.变量名// 修改数据引用.变量名 = 数据 注意 局部变量在栈内存中存储 成员变量中的实例变量在堆内存中的java对象内部存储。实例变量是一个对象一份，100个对象有100份 下面我们再针对一个更复杂的情况，对创建对象进行内存分析： 123456789101112131415161718192021222324252627282930// address.javapublic class address&#123; // 城市 // String是一种引用数据类型，city是一个实例变量 // city是一个引用，保存内存地址的一个变量，该变量保存的内存地址指向了堆内存中的对象 String city; // 街道 String street; // 邮编 String zipcode;&#125;// user.javapublic class user&#123; // 用户名 String name; // 用户编号 int no; // 家庭住址 // address是一种引用数据类型，addr是一个实例变量，是一个引用 address addr;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); &#125;&#125; 上述代码的内存图如下所示： 下面修改user对象内部实例变量的值 12345678910// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); u.no = 110; u.name = "jack"; u.addr = new address(); &#125;&#125; 上面代码的内存图如下： 注意：上图的u、name、addr、city、street和zipcpde都是引用。 如何访问对象u他家在那个城市、街道、邮编是多少？ 12345678910111213141516171819// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); u.no = 110; u.name = "jack"; u.addr = new address(); // 在main方法当中只能看到一个引用u // 一切都是只能通过u来进行方法 u.addr.city = "Beijing"; u.addr.street = "top"; u.addr.zipcode = "123456"; System.out.println(u.addr.city); System.out.println(u.addr.street); System.out.println(u.addr.zipcode); &#125;&#125; 根据上述分析可得：引用既可以是局部变量，也可以是成员变量。引用保存了内存地址，指向了堆内存当中的对象。 下面继续分析对象创建过程中的内存： 123456789// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); address a = new address(); u.addr = a; &#125;&#125; 注意；这里u.addr和a是两个引用。a中存储的地址赋值给了u.addr，a和u.addr指向了同一块堆中的对象。 1234567891011121314// test.javapublic class test&#123; public static void main(String[] args)&#123; // 创建user对象 user u = new user(); address a = new address(); u.addr = a; System.out.println(u.addr.city); // null a.city = "beijing"; System.out.println(u.addr.city); // beijing // 这里a和u.addr指向同一块堆内存，因此通过a修改后，再利用u.addr访问的是修改后的对象 &#125;&#125; 下面对JVM内存进行一个总结： JVM主要包括三块内存空间，分别是栈内存、堆内存和方法区内存 堆内存和方法区内存各有一个，栈内存是一个线程一个栈内存 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行结束后，该方法所属的内存空间释放，称为弹栈 栈中主要存储的是方法体中的局部变量 方法的代码片段以及整个类的代码片段都存储到方法区内存当中，在类加载的时候这些代码片段会载入 在程序执行过程中使用new创建的java对象存储在堆内存当中，对象内部有实例变量，所以实例变量存储在堆内存当中。实例变量只有创建对象才能访问，不创建是没有对应的内存空间的 变量分类 局部变量：方法体内声明 成员变量：方法体外声明 实例变量：修饰符没有static 静态变量：修饰符有static 静态变量存储在方法区内存当中 三块内存当中变换最频繁的是栈内存，最先有数据的方法区内存，垃圾回收器主要针对的是堆内存 垃圾回收器(GC机制)什么时候会考虑将某个java对象的内存回收呢？ 当堆内存当中java对象成为垃圾数据的时候会被回收 什么时候堆内存当中的java对象会成为垃圾呢？ 没有任何引用指向它的时候。因为如果没有引用，这个对象就无法被访问，因为访问对象只能通过引用的方式访问 下面看一个情况 12345678910111213141516171819// customer.javapublic class customer&#123; int id;&#125;// test.javapublic class test&#123; public static void main(String[] args)&#123; customer c = new customer(); // 空引用 c = null; // 以下程序编译可以通过，因为符合语法 // 运行出现空指针异常：java.lang.NullPointerException // 空引用访问“实例相关的数据”一定会出现空指针异常 // 实例相关的数据表示这个数据访问的时候必须要有对象的参与，比如实例变量。但对于静态变量是可以的 System.out.println(c.id); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法执行内存分析]]></title>
    <url>%2F2020%2F04%2F01%2F%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[方法在执行过程当中，在JVM中的内存是如何分配的？内存是如何变化的？ 方法只定义，不调用，是不会执行的，并且在JVM当中也不会给该方法分配运行所属的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的内存空间。 在JVM内存划分上有这样三块主要的内存空间（当然除了这三块之外还有其他的内存空间） 方法区内存 堆内存 栈内存 方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？ 方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中。所以JVM中的三块主要的内存空间中，方法区内存是最先有数据的，存放了代码片段。 代码片段虽然在方法区内存中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配（栈内存中分配方法运行时所属的内存空间） 方法在调用的时候，会给该方法分配独立的内存空间，在栈中发生压栈操作；方法执行结束后，给该方法分配的内存空前全部释放，此时发生弹栈操作 压栈：给方法分配内存 弹栈：释放该方法的内存空间 局部变量在方法体中声明，局部变量运行阶段在栈中存储 下面我们图解一下上述过程，代码如下： 1234567891011121314151617181920public class Hello&#123; public static void main(String[] args)&#123; int a = 10; int b = 20; int retValue = sumInt(a,b); System.out.println(retValue); &#125; public static int sunInt(int i,int j)&#123; int result = i+j; int num = 3; int retValue = divide(result,num); return retValue; &#125; public static int divide(int x,int y)&#123; int z = x/y; return z; &#125;&#125; 下面我将一步一步对上述代码的执行过程进行图解： 执行前的JVM内存空间如下图（主要考虑三块内存，其余的可以先不考虑） 对Hello编译后，类加载器会将Hello.class字节码文件放到方法区内存中。其中的String.class和System.class是Java提供的类库 main方法是入口方法，所以首先在栈内存中给main方法分配一块内存。会在main方法对应的栈内存中为局部变量a和b分配内存（变量名和字面值两个不同的概念，当声明基本类型变量时，变量名和字面值（变量名和字面值是两个概念）均放在栈中，变量名指向字面值。当声明为引用数据类型时，变量名指向栈中一块内存，该内存中存放的是堆内存中对象实例的引用，该引用指向对象实例） 此时在main方法中调用sumInt方法，需要在栈内存中给sumInt方法开辟一块内存（参数也是局部变量） 注意：方法调用时，参数传递实际传递的是变量中保存的那个值（值传递）。比如这里：是把a保存的10传给了i，b保存的20传给了j，而不是把a和b传给了i和j。这样如果修改i和j，是不会影响a和b所对应的内存空间的。如果直接把a和b传给i和j，那么会存在问题：修改i和j的时候也会不知不觉的修改了a和b。 此时在sumInt方法中调用divide方法，需要在栈内存中给divide方法开辟一块内存 divide在返回值时，将z对应的数据值传递给sumInt方法中的retValue，然后divide方法内存释放，弹栈 sumInt在返回值时，将retValue对应的数据值传递给main方法中的retValue，然后sunInt方法内存释放，弹栈 当main方法执行结束后，对应的内存也将释放，弹栈 小问题：我们在Java入门（含Java基本介绍、数据类型、流程控制和数组操作）举过这样一个例子 123456789101112131415161718public class Hello&#123; /* 报错 public static void main(String[] args)&#123; String name = "l"; &#123; String name = "x"; &#125; &#125; */ // 没有报错 public static void main(String[] args)&#123; &#123; String name = "l"; &#125; String name = "x"; &#125;&#125; 这里第二个方法没有报错，那么其被调用时对于两个同名局部变量name是如何分配内存的？ ​ 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。 ​ 所以在main方法对应的栈内存中首先会为第一个name分配空间，当大括号结束后，该变量的内存空间会被释放。此时再为第二个name分配内存空间就不会出错。而第一个方法由于第一个name还没有被释放栈内存空间，就出现了第二个同名局部变量，这显然会报错。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL查询语句的定义顺序和执行顺序]]></title>
    <url>%2F2020%2F03%2F31%2FSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[我们前面介绍了查询语句的各个子句，但是除了SELECT之外，其他的子句全都是可以省略的。如果在一个查询语句中出现了多个子句，那么它们之间的顺序是不能乱放的，顺序如下所示： 1234567SELECT [DISTINCT] 查询列表[FROM 表名][WHERE 布尔表达式][GROUP BY 分组列表 ][HAVING 分组过滤条件][ORDER BY 排序列表][LIMIT 开始行, 限制条数] 其中中括号[]中的内容表示可以省略，我们在书写查询语句的时候各个子句必须严格遵守这个顺序，不然会报错的！ 注意：定义顺序和语句的具体执行顺序是不一致的。上述查询语句中各子句的执行顺序如下： from where group by having select order by limit 特别注意别名的使用问题。 我们在定义别名的时候是在select中定义别名。可能存在使用别名情况的子句包括：where、group by、having和order by。 对于SQL Server而言 由于where、group by和having的执行顺序在select前面，所以他们不能使用别名。而对于order by而言，它在select后才执行，所以可以使用别名。 总结：只有order by才能使用别名 对于MySQL而言 我们只需要记住MySQL比较特殊，它可以在group by、having和order by中使用别名，在where中不能使用别名 mysql特殊是因为mysql中对查询做了加强]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式类型转换]]></title>
    <url>%2F2020%2F03%2F30%2F%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[隐式类型转换的场景只要某个值的类型与上下文要求的类型不符，MySQL就会根据上下文环境中需要的类型对该值进行类型转换，由于这些类型转换都是MySQL自动完成的，所以也可以被称为隐式类型转换。我们列举几种常见的隐式类型转换的场景： 把操作数类型转换为适合操作符计算的相应类型 比方说对于加法操作符+来说，它要求两个操作数都必须是数字才能进行计算，所以如果某个操作数不是数字的话，会将其隐式转换为数字，比方说下边这几个例子： 1231 + 2 → 3&apos;1&apos; + 2 → 3&apos;1&apos; + &apos;2&apos; → 3 虽然&#39;1&#39;、&#39;2&#39;都是字符串，但是如果它们作为加法操作符+的操作数的话，都会被强制转换为数字，所以上边几个表达式其实都会被当作1 + 2去处理的，这些表达式被放在查询列表时的效果如下： 1234567mysql&gt; SELECT 1 + 2, &apos;1&apos; + 2, &apos;1&apos; + &apos;2&apos;;+-------+---------+-----------+| 1 + 2 | &apos;1&apos; + 2 | &apos;1&apos; + &apos;2&apos; |+-------+---------+-----------+| 3 | 3 | 3 |+-------+---------+-----------+1 row in set (0.00 sec) 将函数参数转换为该函数期望的类型 我们拿用于拼接字符串的CONCAT函数举例，这个函数以字符串类型的值作为参数，如果我们在调用这个函数的时候，传入了别的类型的值作为参数，MySQL会自动把这些值的类型转换为字符串类型的： 123CONCAT(&apos;1&apos;, &apos;2&apos;) → &apos;12&apos;CONCAT(&apos;1&apos;, 2) → &apos;12&apos;CONCAT(1, 2) → &apos;12&apos; 虽然1、2都是数字，但是如果它们作为CONCAT函数的参数的话，都会被强制转换为字符串，所以上边几个表达式其实都会被当作CONCAT(&#39;1&#39;, &#39;2)去处理的，这些表达式被放到查询列表时的效果如下： 1234567mysql&gt; SELECT CONCAT(&apos;1&apos;, &apos;2&apos;), CONCAT(&apos;1&apos;, 2), CONCAT(1, 2);+------------------+----------------+--------------+| CONCAT(&apos;1&apos;, &apos;2&apos;) | CONCAT(&apos;1&apos;, 2) | CONCAT(1, 2) |+------------------+----------------+--------------+| 12 | 12 | 12 |+------------------+----------------+--------------+1 row in set (0.00 sec) 存储数据时，把某个值转换为某个列需要的类型 我们先新建一个简单的表t： 12345CREATE TABLE t ( i1 TINYINT, i2 TINYINT, s VARCHAR(100)); 这个表有三个列，列i1和i2是用来存储整数的，列s是用来存储字符串的，如果我们在存储数据的时候填入的不是期望的类型，就像这样： 12mysql&gt; INSERT INTO t(i1, i2, s) VALUES(&apos;100&apos;, &apos;100&apos;, 200);Query OK, 1 row affected (0.01 sec) 我们为列i1和i2填入的值是一个字符串值：&#39;100&#39;，列s填入的值是一个整数值：200，虽然说类型都不对，但是由于隐式类型转换的存在，在插入数据的时候字符串&#39;100&#39;会被转型为整数100，整数200会被转型成字符串&#39;200&#39;，所以最后插入成功，我们来看一下效果： 1234567mysql&gt; SELECT * FROM t;+------+------+------+| i1 | i2 | s |+------+------+------+| 100 | 100 | 200 |+------+------+------+1 row in set (0.00 sec) 类型转换的注意事项 MySQL会尽量把值转换为表达式中需要的类型，而不是产生错误。 按理说&#39;23sfd&#39;这个字符串无法转换为数字，但是MySQL规定只要字符串的开头部分包含数字，那么就把这个字符串转换为开头的数字，如果开头并没有包含数字，那么将被转换成`0`，比方说这样： 1234&apos;23sfd&apos; → 23&apos;2019-08-28&apos; → 2019&apos;11:30:32&apos; → 11&apos;sfd&apos; → 0 看个例子： 1234567mysql&gt; SELECT &apos;23sfd&apos; + 0, &apos;sfd&apos; + 0;+-------------+-----------+| &apos;23sfd&apos; + 0 | &apos;sfd&apos; + 0 |+-------------+-----------+| 23 | 0 |+-------------+-----------+1 row in set, 2 warnings (0.00 sec) 不过需要注意的是，这种强制转换不能用于存储数据中，比方说这样： 12mysql&gt; INSERT INTO t(i1, i2, s) VALUES(&apos;sfd&apos;, &apos;sfd&apos;, &apos;aaa&apos;);ERROR 1366 (HY000): Incorrect integer value: &apos;sfd&apos; for column &apos;i1&apos; at row 1 在运算时会自动提升操作数的类型。 我们知道不同数据类型能表示的数值范围是不一样的，在小的数据类型经过算数计算后得出的结果可能大于该可以表示的范围。比方说t表中有一条记录如下： 1234567mysql&gt; SELECT * FROM t;+------+------+------+| i1 | i2 | s |+------+------+------+| 100 | 100 | 200 |+------+------+------+1 row in set (0.00 sec) 其中的i1列和i2列的类型都是TINYINT，而TINYINT能表示的最大正整数是127，如果我们把i1列的值和i2列的值相加会发生什么呢？请看： 1234567mysql&gt; SELECT i1 + i2 FROM t;+---------+| i1 + i2 |+---------+| 200 |+---------+1 row in set (0.00 sec) 可以看到最后的结果是200，可是它已经超过TINYINT类型的表示范围了。其实在运算的过程中，MySQL自动将整数类型的操作数提升到了BIGINT，这样就不会产生运算结果太大超过TINYINT能表示的数值范围的尴尬情况了。类似的，有浮点数的运算过程会把操作数自动转型为DOUBLE类型。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式与函数]]></title>
    <url>%2F2020%2F03%2F26%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[表达式如果拥有小学学历，就知道将数字和运算符连接起来的组合称之为表达式，比方说这样： 121 + 14 * 3 其中的数字称之为操作数，运算符可以称之为操作符。特殊的，单个操作数也可以被看作是一个特殊的表达式。 在MySQL中也有表达式的概念，不过操作数和操作符的含义有了扩充。下边详细看一下。 操作数MySQL中操作数可以是下边这几种类型： 常数：常数很好理解，我们平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字1，字符串&#39;abc&#39;，时间值2019-08-16 17:10:43啥的。 列名：针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于student_info表来说，number、name都可以作为操作数。 函数调用：MySQL中有函数的概念，比方说获取当前时间的函数NOW，而在函数后边加个小括号就算是一个函数调用，比如NOW()。 标量子查询或行子查询 其它表达式：一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式，比方说（假设col是一个列名）： (1 + 1) 2 + col 3 操作符 算数操作符：就是加减乘除法那一堆，我们看一下MySQL中都支持哪些 操作符 示例 描述 + a + b 加法 - a - b 减法 * a * b 乘法 / a / b 除法 DIV a DIV b 除法，取商的整数部分 % a % b 取余数 - -a 负号 在使用MySQL中的算术操作符时需要注意，DIV和/都表示除法操作符，但是DIV只会取商的整数部分，/会保留商的小数部分。比如表达式 2 DIV 3的结果是0，而2 / 3的结果是0.6667。 比较操作符：就是在搜索条件中我们已经看过的比较操作符，我们把常用的都抄下来看一下： 操作符 示例 描述 = a = b a等于b &lt;&gt; 或 != a &lt;&gt; b a不等于b &lt; a &lt; b a小于b &lt;= a &lt;= b a小于等于b &gt; a &gt; b a大于b >= a &gt;= b a大于等于b BETWEEN a BETWEEN b AND c b &lt;= a &lt;= c NOT BETWEEN a NOT BETWEEN b AND c 不满足b &lt;= a &lt;= c IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2,…) a不是b1,b2,…中的任意一个 IS NULL a IS NULL a是NULL IS NOT NULL a IS NOT NULL a不是NULL LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b 由比较操作符连接而成的表达式也称为布尔表达式，表示真或者假，也可以称为TRUE或者FALSE。比如1 &gt; 3就代表FALSE，3 != 2就代表TRUE。 逻辑操作符：逻辑操作符是用来将多个布尔表达式连接起来，我们需要了解这几个逻辑操作符： 操作符 示例 描述 AND a AND b 只有a和b同时为真，表达式才为真 OR a OR b 只要a或b有任意一个为真，表达式就为真 XOR a XOR b a和b有且只有一个为真，表达式为真 表达式的使用只要把这些操作数和操作符相互组合起来就可以组成一个表达式。表达式主要以下边这两种方式使用： 放在查询列表中 我们前边都是将列名放在查询列表中的(*号代表所有的列名～)。列名只是表达式中超级简单的一种，我们可以将任意一个表达式作为查询列表的一部分来处理，比方说我们可以在查询student_score表时把score字段的数据都加100，就像这样： 1234567891011121314mysql&gt; SELECT number, subject, score + 100 FROM student_score;+----------+-----------------------------+-------------+| number | subject | score + 100 |+----------+-----------------------------+-------------+| 20180101 | 母猪的产后护理 | 178 || 20180101 | 论萨达姆的战争准备 | 188 || 20180102 | 母猪的产后护理 | 200 || 20180102 | 论萨达姆的战争准备 | 198 || 20180103 | 母猪的产后护理 | 159 || 20180103 | 论萨达姆的战争准备 | 161 || 20180104 | 母猪的产后护理 | 155 || 20180104 | 论萨达姆的战争准备 | 146 |+----------+-----------------------------+-------------+8 rows in set (0.00 sec) 其中的number、subject、score + 100都是表达式，结果集中的列的名称也将默认使用这些表达式的名称，所以如果你觉得原名称不好，我们可以使用别名： 1234567891011121314mysql&gt; SELECT number, subject, score + 100 AS score FROM student_score;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180101 | 母猪的产后护理 | 178 || 20180101 | 论萨达姆的战争准备 | 188 || 20180102 | 母猪的产后护理 | 200 || 20180102 | 论萨达姆的战争准备 | 198 || 20180103 | 母猪的产后护理 | 159 || 20180103 | 论萨达姆的战争准备 | 161 || 20180104 | 母猪的产后护理 | 155 || 20180104 | 论萨达姆的战争准备 | 146 |+----------+-----------------------------+-------+8 rows in set (0.00 sec) 需要注意的是，放在查询列表的表达式也可以不涉及列名，就像这样： 123456789101112mysql&gt; SELECT 1 FROM student_info;+---+| 1 |+---+| 1 || 1 || 1 || 1 || 1 || 1 |+---+6 rows in set (0.01 sec) 因为student_info中有6条记录，所以结果集中也就展示了6条结果，不过我们的查询列表处只有一个常数1，所以所有的结果的值也都是常数1。这种查询列表中不涉及列名的情况下，我们甚至可以省略掉FROM子句后边的表名，就像这样： 1234567mysql&gt; SELECT 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec) 作为搜索条件 我们在介绍搜索条件的时候介绍的都是带有列名的表达式，搜索条件也可以不带列名，比如这样： 123456789101112mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE 2 &gt; 1;+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 || 20180103 | 范统 | 17156319980116959X | 软件工程 || 20180104 | 史珍香 | 141992199701078600 | 软件工程 || 20180105 | 范剑 | 181048199308156368 | 飞行器设计 || 20180106 | 朱逸群 | 197995199501078445 | 电子信息 |+----------+-----------+--------------------+--------------------------+6 rows in set (0.00 sec) 由于我们的搜索条件是2 &gt; 1，这个条件对于表中的每一条记录都成立，所以最后的查询结果就是全部的记录。不过这么写有点儿傻哈，没有一毛钱卵用，没一点实际意义～ 所以通常情况下搜索条件中都会包含列名的。 函数如果我们想使用函数，可以在函数名后加一个小括号()就好，表示调用一下这个函数，简称函数调用。比方说NOW()就代表调用NOW函数来获取当前日期和时间。针对某些包含参数的函数，我们也可以在小括号()里将参数填入，比方说UPPER(&#39;abc&#39;)表示将字符串&#39;abc&#39;转换为大写格式。 下边来介绍一些常用的MySQL内置函数： 文本处理函数 名称 调用示例 示例结果 描述 LEFT LEFT(‘abc123’,3) abc 给定字符串从左边取指定长度的子串 RIGHT RIGHT(‘abc123’,3) 123 给定字符串从右边取指定长度的子串 LENGTH LENGTH(‘abc’) 3 给定字符串的长度 LOWER LOWER(‘ABC’) abc 给定字符串的小写格式 UPPER UPPER(‘abc’) ABC 给定字符串的大写格式 LTRIM LTRIM(‘ abc’) abc 给定字符串左边空格去除后的格式 RTRIM RTRIM(‘abc ‘) abc 给定字符串右边空格去除后的格式 SUBSTRING SUBSTRING(‘abc123’,2,3) bc1 给定字符串从指定位置截取指定长度的子串 CONCAT CONCAT(‘abc’,’123’,’xyz’) abc123xyz 将给定的各个字符串拼接成一个新字符串 我们以SUBSTRING函数为例试一下： 1234567mysql&gt; SELECT SUBSTRING(&apos;abc123&apos;, 2, 3);+---------------------------+| SUBSTRING(&apos;abc123&apos;, 2, 3) |+---------------------------+| bc1 |+---------------------------+1 row in set (0.00 sec) 我们前边在唠叨表达式的说过，函数调用也算是一种表达式的操作数，它可以和其他操作数用操作符连接起来组成一个表达式来作为查询列表的一部分或者放到搜索条件中。我们来以CONCAT函数为例来看一下： 1234567891011121314mysql&gt; SELECT CONCAT(&apos;学号为&apos;, number, &apos;的学生在《&apos;, subject, &apos;》课程的成绩是：&apos;, score) AS 成绩描述 FROM student_score;+---------------------------------------------------------------------------------------+| 成绩描述 |+---------------------------------------------------------------------------------------+| 学号为20180101的学生在《母猪的产后护理》课程的成绩是：78 || 学号为20180101的学生在《论萨达姆的战争准备》课程的成绩是：88 || 学号为20180102的学生在《母猪的产后护理》课程的成绩是：100 || 学号为20180102的学生在《论萨达姆的战争准备》课程的成绩是：98 || 学号为20180103的学生在《母猪的产后护理》课程的成绩是：59 || 学号为20180103的学生在《论萨达姆的战争准备》课程的成绩是：61 || 学号为20180104的学生在《母猪的产后护理》课程的成绩是：55 || 学号为20180104的学生在《论萨达姆的战争准备》课程的成绩是：46 |+---------------------------------------------------------------------------------------+8 rows in set (0.00 sec) 日期和时间处理函数 名称 调用示例 示例结果 描述 NOW NOW() 2019-08-16 17:10:43 返回当前日期和时间 CURDATE CURDATE() 2019-08-16 返回当前日期 CURTIME CURTIME() 17:10:43 返回当前时间 DATE DATE(‘2019-08-16 17:10:43’) 2019-08-16 将给定日期和时间值的日期提取出来 DATE_ADD DATE_ADD(‘2019-08-16 17:10:43’, INTERVAL 2 DAY) 2019-08-18 17:10:43 将给定的日期和时间值添加指定的时间间隔 DATE_SUB DATE_SUB(‘2019-08-16 17:10:43’, INTERVAL 2 DAY) 2019-08-14 17:10:43 将给定的日期和时间值减去指定的时间间隔 DATEDIFF DATEDIFF(‘2019-08-16’, ‘2019-08-17’); -1 返回两个日期之间的天数（负数代表前一个参数代表的日期比较小） DATE_FORMAT DATE_FORMAT(NOW(),’%m-%d-%Y’) 08-16-2019 用给定的格式显示日期和时间 在使用这些函数时需要注意一些地方： 在使用DATE_ADD和DATE_SUB这两个函数时需要注意，增加或减去的时间间隔单位可以自己定义，下边是MySQL支持的一些时间单位： | 时间单位 | 描述 || :————-: | :—: || MICROSECOND | 毫秒 || SECOND | 秒 || MINUTE | 分钟 || HOUR | 小时 || DAY | 天 || WEEK | 星期 || MONTH | 月 || QUARTER | 季度 || YEAR | 年 | 如果我们相让2019-08-16 17:10:43这个时间值增加2分钟，可以这么写： 1234567mysql&gt; SELECT DATE_ADD(&apos;2019-08-16 17:10:43&apos;, INTERVAL 2 MINUTE);+----------------------------------------------------+| DATE_ADD(&apos;2019-08-16 17:10:43&apos;, INTERVAL 2 MINUTE) |+----------------------------------------------------+| 2019-08-16 17:12:43 |+----------------------------------------------------+1 row in set (0.00 sec) 在使用DATE_FORMAT函数时需要注意，我们可以通过一些所谓的格式符来自定义日期和时间的显示格式，下边是MySQL中常用的一些日期和时间的格式符以及它们对应的含义： 格式符 描述 %b 简写的月份名称（Jan、Feb、…、Dec) %D 带有英文后缀的月份中的日期（0th、1st、2nd、…、31st)） %d 数字格式的月份中的日期(00、01、02、…、31) %f 微秒（000000-999999） %H 二十四小时制的小时 (00-23) %h 十二小时制的小时 (01-12) %i 数值格式的分钟(00-59) %M 月份名（January、February、…、December） %m 数值形式的月份(00-12) %p 上午或下午（AM代表上午、PM代表下午） %S 秒(00-59) %s 秒(00-59) %W 星期名（Sunday、Monday、…、Saturday） %w 周内第几天 （0=星期日、1=星期一、 6=星期六） %Y 4位数字形式的年（例如2019） %y 2位数字形式的年（例如19） 我们可以把我们想要的显示格式用对应的格式符描述出来，就像这样： 1234567mysql&gt; SELECT DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;);+----------------------------------------+| DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;) |+----------------------------------------+| Mar 30 2020 10:54 AM |+----------------------------------------+1 row in set 数值处理函数下边列举一些数学上常用到的函数，在遇到需要数学计算的业务时会很有用： 名称 调用示例 示例结果 描述 ABS ABS(-1) 1 取绝对值 Pi PI() 3.141593 返回圆周率 COS COS(PI()) -1 返回一个角度的余弦 EXP EXP(1) 2.718281828459045 返回e的指定次方 MOD MOD(5,2) 1 返回除法的余数 RAND RAND() 0.7537623539136372 返回一个随机数 SIN SIN(PI()/2) 1 返回一个角度的正弦 SQRT SQRT(9) 3 返回一个数的平方根 TAN TAN(0) 0 返回一个角度的正切 聚集函数有些函数是用来统计数据的，比方说统计一下表中的行数，某一列数据的最大值是什么，我们把这种函数称之为聚集函数，下边介绍MySQL中常用的几种聚集函数： 函数名 描述 COUNT 返回某列的行数 MAX 返回某列的最大值 MIN 返回某列的最小值 SUM 返回某列值之和 AVG 返回某列的平均值 注意：在mysql中除了count(*)为特例（不忽略null值）外，其余聚集函数是忽略null值 COUNT函数COUNT函数使用来统计行数的，它有下边两种使用方式： COUNT(*)：对表中行的数目进行计数，不管列的值是不是NULL。 COUNT(列名)：对特定的列进行计数，会忽略掉该列为NULL的行。 两者的区别是会不会忽略统计列的值为NULL的行！两者的区别是会不会忽略统计列的值为NULL的行！两者的区别是会不会忽略统计列的值为NULL的行！重要的事情说3遍 MAX函数MAX函数是用来查询某列中数据的最大值，以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT MAX(score) FROM student_score;+------------+| MAX(score) |+------------+| 100 |+------------+1 row in set (0.00 sec) MIN函数MIN函数是用来查询某列中数据的最小值，以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT MIN(score) FROM student_score;+------------+| MIN(score) |+------------+| 46 |+------------+1 row in set (0.00 sec) SUM函数SUM函数是用来计算某列数据的和，还是以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT SUM(score) FROM student_score;+------------+| SUM(score) |+------------+| 585 |+------------+1 row in set (0.01 sec) AVG函数AVG函数是用来计算某列数据的平均数，还是以student_score表中的score列为例来看一下： 1234567mysql&gt; SELECT AVG(score) FROM student_score;+------------+| AVG(score) |+------------+| 73.1250 |+------------+1 row in set (0.00 sec) 给定搜索条件下聚集函数的使用聚集函数并不是一定要统计一个表中的所有记录，我们也可以指定搜索条件来限定这些聚集函数作用的范围。比方说我们只想统计&#39;母猪的产后护理&#39;这门课程的平均分可以这么写： 1234567mysql&gt; SELECT AVG(score) FROM student_score WHERE subject = &apos;母猪的产后护理&apos;;+------------+| AVG(score) |+------------+| 73.0000 |+------------+1 row in set (0.00 sec) 换句话说就是：不在搜索条件中的那些记录是不参与统计的。 聚集函数中DISTINCT的使用默认情况下，上边介绍的聚集函数将计算指定列的所有非NULL数据，如果我们指定的列中有重复数据的话，可以选择使用DISTINCT来过滤掉这些重复数据。比方说我们想查看一下student_info表中存储了多少个专业的学生信息，就可以这么写： 1234567mysql&gt; SELECT COUNT(DISTINCT major) FROM student_info;+-----------------------+| COUNT(DISTINCT major) |+-----------------------+| 4 |+-----------------------+1 row in set (0.01 sec) 组合聚集函数这些聚集函数也可以集中在一个查询中使用，比如这样： 1234567mysql&gt; SELECT COUNT(*) AS 成绩记录总数, MAX(score) AS 最高成绩, MIN(score) AS 最低成绩, AVG(score) AS 平均成绩 FROM student_score;+--------------------+--------------+--------------+--------------+| 成绩记录总数 | 最高成绩 | 最低成绩 | 平均成绩 |+--------------------+--------------+--------------+--------------+| 8 | 100 | 46 | 73.1250 |+--------------------+--------------+--------------+--------------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之使用通配符进行模糊查询]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[有时候我们并不能精确地描述我们要查询的哪些结果，比如我们只想看看姓&#39;杜&#39;的学生信息，而不能精确的描述出这些姓&#39;杜&#39;的同学的完整姓名，我们称这种查询为模糊查询。MySQL中使用下边这两个操作符来支持模糊查询： 操作符 示例 描述 LIKE a LIKE b a匹配b NOT LIKE a NOT LIKE b a不匹配b 注意：如果要进行模糊查询，只能使用上述操作符。不能使用 = 等操作符 既然我们不能完整描述要查询的信息，那就用某个符号来替代这些模糊的信息，这个符号就被称为通配符。MySQL中支持下边这两个通配符： %：表示任何字符出现任意次数 (可以是0次) 具体使用如下： 匹配以&quot;yves&quot;开头的记录:(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;yves%&#39;; 匹配包含&quot;yves&quot;的记录(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;%yves%&#39;; 匹配以&quot;yves&quot;结尾的记录(包括记录&quot;yves&quot;)SELECT * FROM products WHERE prod_name like &#39;%yves&#39;; _：下划线通配符，表示只能匹配单个字符,不能多也不能少,就是一个字符 有的时候我们知道要查询的字符串中有多少个字符，而使用%时匹配的范围太大，我们就可以用_来做通配符。 具体使用： SELECT * FROM products WHERE prod_name like &#39;_yves&#39;;匹配结果为: 像&quot;yyves&quot;这样记录. SELECT * FROM products WHERE prod_name like &#39;yves__&#39;;匹配结果为: 像&quot;yvesHe&quot;这样的记录.(一个下划线只能匹配一个字符,不能多也不能少) 小细节：如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE prod_name like &#39;1000&#39;;只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果. 注意：LIKE或者NOT LIKE操作符只用于字符串匹配。通配符不能代表NULL，如果需要匹配NULL的话，需要使用IS NULL或者IS NOT NULL。%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE prod_name like &#39;%&#39;;是匹配不到prod_name为NULL的的记录 转义通配符 如果待匹配的字符串中本身就包含普通字符&#39;%&#39;或者&#39;_&#39;该咋办，怎么区分它是一个通配符还是一个普通字符呢？ 答：如果匹配字符串中需要普通字符&#39;%&#39;或者&#39;_&#39;的话，需要在它们前边加一个反斜杠\来和通配符区分开来，也就是说： &#39;\%&#39;代表普通字符&#39;%&#39; &#39;\_&#39;代表普通字符&#39;_&#39; 比方说这样： 上面我们说到了LIKE和NOT LIKE只能用于字符串匹配，但我在实际中却发现了这个问题： 123456789mysql&gt; select * from student_score where score like &apos;_8&apos;;+----------+--------------------+-------+| number | subject | score |+----------+--------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 论萨达姆的战争准备 | 98 |+----------+--------------------+-------+3 rows in set 这里score字段是INT型，但为什么还是可以进行模糊查询？后来发现是这里发生了隐式类型转换（具体介绍见：隐式类型转换）。 正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之带条件的查询]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E5%B8%A6%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[通常并不是对所有的记录都感兴趣，只是想查询到符合某些条件的那些记录。这些条件也被称为搜索条件或者过滤条件，当某条记录符合搜索条件时，它将被放入结果集中。 简单搜索条件我们需要把搜索条件放在WHERE子句中，比如我们想查询student_info表中名字是范剑的学生的一些信息，可以这么写： 1234567mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE name = &apos;范剑&apos;;+----------+------+--------------------+------------+| number | name | id_number | major |+----------+------+--------------------+------------+| 20180105 | 范剑 | 181048199308156368 | 飞行器设计 |+----------+------+--------------------+------------+1 row in set 这个例子中的搜索条件就是name = &#39;范剑&#39;，也就是当记录中的name列的值是&#39;范剑&#39;的时候，该条记录的number、name、id_number、major这些字段才可以被放入结果集。搜索条件name = &#39;范剑&#39;中的=称之为比较操作符，除了=之外，设计MySQL的大叔还提供了很多别的比较操作符，比如： 操作符 示例 描述 = a = b a等于b &lt;&gt; 或 != a &lt;&gt; b a不等于b &lt; a &lt; b a小于b &gt; a &gt; b a 大于b &lt;= a &lt;= b a小于等于b >= a &gt;= b a大于等于b BETWEEN a BETWEEN b AND c 满足b &lt;= a &lt;= c NOT BETWEEN a NOT BETWEEN b AND c 不满足b &lt;= a &lt;= c 匹配多个元素有时候搜索条件中指定的匹配值并不是单个值，而是一个列表，只要匹配到列表中的某一项就算匹配成功，这种情况可以使用IN操作符： 操作符 示例 描述 IN a IN (b1,b2,…) a是b1,b2,…中的某一个 NOT IN a NOT IN (b1,b2,…) a不是b1,b2,…中的任意一个 比如我们想查询软件工程和飞行器设计专业的学生信息，可以这么写： 123456789mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE major IN (&apos;软件工程&apos;, &apos;飞行器设计&apos;);+----------+-----------+--------------------+-----------------+| number | name | id_number | major |+----------+-----------+--------------------+-----------------+| 20180103 | 范统 | 17156319980116959X | 软件工程 || 20180104 | 史珍香 | 141992199701078600 | 软件工程 || 20180105 | 范剑 | 181048199308156368 | 飞行器设计 |+----------+-----------+--------------------+-----------------+3 rows in set (0.01 sec) 如果想查询不是这两个专业的学生的信息，可以这么写： 123456789mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE major NOT IN (&apos;软件工程&apos;, &apos;飞行器设计&apos;);+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 || 20180106 | 朱逸群 | 197995199501078445 | 电子信息 |+----------+-----------+--------------------+--------------------------+3 rows in set (0.00 sec) 有个小问题，如果表中存在NULL值，该如何匹配搜索呢？ NULL代表没有值，意味着你并不知道该列应该填入什么数据，在判断某一列是否为NULL的时候并不能单纯的使用=操作符，而是需要专业判断值是否是NULL的操作符： 操作符 示例 描述 IS NULL a IS NULL a的值是NULL IS NOT NULL a IS NOT NULL a的值不是NULL 比如我们想看一下student_info表的name列是NULL的学生记录有哪些，可以这么写： 12mysql&gt; SELECT number, name, id_number, major FROM student_info WHERE name IS NULL;Empty set (0.00 sec) 由于所有记录的name列都不是NULL值，所以最后的结果集是空的 再次强调一遍，不能直接使用普通的操作符来与NULL值进行比较，必须使用IS NULL或者IS NOT NULL！ 多个搜索条件的查询上边介绍的都是指定单个的搜索条件的查询，我们也可以在一个查询语句中指定多个搜索条件。 AND操作符在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候才将其加入结果集，这种情况我们可以使用AND操作符来连接多个搜索条件。 12345678mysql&gt; SELECT * FROM student_score WHERE subject = &apos;母猪的产后护理&apos; AND score &gt; 75;+----------+-----------------------+-------+| number | subject | score |+----------+-----------------------+-------+| 20180101 | 母猪的产后护理 | 78 || 20180102 | 母猪的产后护理 | 100 |+----------+-----------------------+-------+2 rows in set (0.00 sec) 其中的subject = &#39;母猪的产后护理&#39;和score &gt; 75是两个搜索条件，我们使用AND操作符把这两个搜索条件连接起来表示只有当两个条件都满足的记录才能被加入到结果集。 OR操作符在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用OR操作符来连接多个搜索条件。 比如我们想从student_score表中找出成绩大于95分或者小于55分的记录，可以这么写： 123456789mysql&gt; SELECT * FROM student_score WHERE score &gt; 95 OR score &lt; 55;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180102 | 论萨达姆的战争准备 | 98 || 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+3 rows in set (0.00 sec) 注意：AND操作符的优先级高于OR操作符，也就是说在判断某条记录是否符合条件时会先检测AND操作符两边的搜索条件 例如： 1score &gt; 95 OR score &lt; 55 AND subject = &apos;论萨达姆的战争准备&apos; 上述语句可以被看作下面两个条件中任意一个条件成立则使整个式子成立： score &gt; 95 score &lt; 55 AND subject = ‘论萨达姆的战争准备’ 这种优先级是非常尴尬的！因此为了避免这种尴尬，可以用小括号()显示指定各搜索条件优先级，比如上面式子可以写成这样： 1(score &gt; 95 OR score &lt; 55) AND subject = &apos;论萨达姆的战争准备&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之查询、去重、限制条数、排序]]></title>
    <url>%2F2020%2F03%2F24%2FMySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E3%80%81%E5%8E%BB%E9%87%8D%E3%80%81%E9%99%90%E5%88%B6%E6%9D%A1%E6%95%B0%E3%80%81%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[对于使用MySQL的我们来说，平时使用频率最高的还是查询功能，就是按照我们给定的要求将数据给查出来。 查询查询单个列查看某个表中的某一列的数据的通用格式是这样： 1SELECT 列名 FROM 表名; 也就是说把需要查询的列名放到单词SELECT后边就好了，比如查看student_info表中的number列的数据可以这么写： 123456789101112mysql&gt; SELECT number FROM student_info;+----------+| number |+----------+| 20180104 || 20180102 || 20180101 || 20180103 || 20180105 || 20180106 |+----------+6 rows in set 可以看到查询结构中就把所有记录的number列都展示了出来，我们有时候也把这个结果称之为结果集。 列的别名我们也可以为结果集中的列重新定义一个别名，命令格式如下： 1SELECT 列名 [AS] 列的别名 FROM 表名; 我们看到AS被加了个中括号，意味着可有可无，没有AS的话，列名和列的别名之间用空白字符隔开就好了。比如我们想给number列起个别名，可以使用下边这两种方式之一： 方式一 1SELECT number AS 学号 FROM student_info; 方式二 1SELECT number 学号 FROM student_info; 执行结果如下： 123456789101112mysql&gt; SELECT number AS 学号 FROM student_info;+----------+| 学号 |+----------+| 20180104 || 20180102 || 20180101 || 20180103 || 20180105 || 20180106 |+----------+6 rows in set 看到黑框框里的结果集中显示的列名就不再是number，而是我们刚刚定义的别名学号了。不过需要注意的是：别名只是在本次查询的到的结果集中展示，而不会改变真实表中的列名。下一次查询中你对number列取其他的别名也可以。 查询多个列如果想查询多个列的数据，可以在SELECT后边写多个列名，用逗号,分隔开就好： 1SELECT 列名1, 列名2, ... 列名n FROM 表名; 我们把SELECT语句后边跟随的多个列统称为查询列表，需要注意的是，查询列表中的列名可以按任意顺序摆放，结果集将按照我们摆放的列名顺序显示 查询所有列如果需要把记录中的所有列都查出来，MySQL也提供一个省事儿的办法，我们之前也介绍过，就是直接用星号*来表示要查询的东西，就像这样： 1SELECT * FROM 表名; 注意：除非你确实需要表中的每个列，否则一般最好别使用星号*来查询所有列，虽然星号*看起来很方便，不用明确列出所需的列，但是查询不需要的列通常会降低性能。 查询结果去重去除单列的重复结果有的时候我们查询某个列的数据时会有一些重复的结果，比如我们查询一下student_info表的学院信息： 123456789101112mysql&gt; SELECT department FROM student_info;+------------+| department |+------------+| 计算机学院 || 计算机学院 || 计算机学院 || 计算机学院 || 航天学院 || 航天学院 |+------------+6 rows in set 因为表里有6条记录，所以给我们返回了6条结果。但是其实好多都是重复的结果，如果我们想去除重复结果的话，可以将DISTINCT放在被查询的列前边，就是这样： 1SELECT DISTINCT 列名 FROM 表名; 结果如下： 12345678mysql&gt; SELECT DISTINCT department FROM student_info;+------------+| department |+------------+| 计算机学院 || 航天学院 |+------------+2 rows in set 去除多列的重复结果对于查询多列的情况，两条结果重复的意思是：两条结果的每一个列中的值都相同。比如查询学院和专业信息： 如果我们想对多列查询的结果去重的话，可以直接把DISTINCT放在被查询的列的最前边： 1SELECT DISTINCT 列名1, 列名2, ... 列名n FROM 表名; 结果如下： 12345678910mysql&gt; SELECT DISTINCT department, major FROM student_info;+------------+------------------+| department | major |+------------+------------------+| 计算机学院 | 计算机科学与工程 || 计算机学院 | 软件工程 || 航天学院 | 飞行器设计 || 航天学院 | 电子信息 |+------------+------------------+4 rows in set 限制查询结果条数有时候查询结果的条数会很多，都显示出来可能会撑爆屏幕～ 所以MySQL给我们提供了一种限制结果集中的记录条数的方式，就是在查询语句的末尾使用这样的语法： 1LIMIT 开始行, 限制条数; 开始行指的是我们想从第几行数据开始查询，限制条数是结果集中最多包含多少条记录。 比如我们查询一下student_info表，从第0条记录开始，最多查询2条记录可以这么写： 12345678mysql&gt; SELECT number, name, id_number, major FROM student_info LIMIT 0, 2;+----------+-----------+--------------------+--------------------------+| number | name | id_number | major |+----------+-----------+--------------------+--------------------------+| 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 || 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 |+----------+-----------+--------------------+--------------------------+2 rows in set (0.00 sec) 注意：如果指定的开始行大于表中的最大行数，那查询结果就什么都没有：开始行默认从第0行开始（计算机中的第0行是我们平时说的第一行）。如果查询的结果条数不超过限制条数，那就可以全部显式出来。 LIMIT后边也可以只有一个参数，那这个参数就代表着限制行数。也就是说我们可以不指定开始行，默认的开始行就是第0行。 对查询结果排序我们之前查询number列的时候得到的记录并不是有序的，这是为什么呢？MySQL其实默认会按照这些数据底层存储的顺序来给我们返回数据，但是这些数据可能会经过更新或者删除，如果我们不明确指定按照什么顺序来排序返回结果的话，那我们可以认为该结果中记录的顺序是不确定的。换句话说如果我们想让返回结果中的记录按照某种特定的规则排序，那我们必须显式的指定排序规则。 按照单个列的值排序我们可以用下边的语法来指定返回结果的记录按照某一列的值进行排序： 1ORDER BY 列名 ASC|DESC ASC和DESC指的是排序方向。ASC是指按照指定列的值进行由小到大进行排序，也叫做升序，DESC是指按照指定列的值进行由大到小进行排序，也叫做降序，中间的|表示这两种方式只能选一个。这回我们用student_score表测试一下 1234567891011121314mysql&gt; SELECT * FROM student_score ORDER BY score ASC;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180104 | 论萨达姆的战争准备 | 46 || 20180104 | 母猪的产后护理 | 55 || 20180103 | 母猪的产后护理 | 59 || 20180103 | 论萨达姆的战争准备 | 61 || 20180101 | 母猪的产后护理 | 78 || 20180101 | 论萨达姆的战争准备 | 88 || 20180102 | 论萨达姆的战争准备 | 98 || 20180102 | 母猪的产后护理 | 100 |+----------+-----------------------------+-------+8 rows in set (0.01 sec) 可以看到输出的记录就是按照成绩由小到大进行排序的。如果省略了 ORDER BY 语句中的排序方向，则默认按照从小到大的顺序进行排序，也就是说ORDER BY 列名和ORDER BY 列名 ASC的语义是一样的， 按照多个列的值排序我们也可以同时指定多个排序的列，多个排序列之间用逗号,隔开就好了，就是这样： 1ORDER BY 列1 ASC|DESC, 列2 ASC|DESC ... 它的意思是根据顺序依次进行排序，比如先按列1排序，排完之后再按照列2排序，以此类推。 比如我们想让对student_score的查询结果先按照subjuect排序，再按照score值从大到小的顺序进行排列，可以这么写： 1234567891011121314mysql&gt; SELECT * FROM student_score ORDER BY subject, score DESC;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180102 | 母猪的产后护理 | 100 || 20180101 | 母猪的产后护理 | 78 || 20180103 | 母猪的产后护理 | 59 || 20180104 | 母猪的产后护理 | 55 || 20180102 | 论萨达姆的战争准备 | 98 || 20180101 | 论萨达姆的战争准备 | 88 || 20180103 | 论萨达姆的战争准备 | 61 || 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+8 rows in set (0.00 sec) 注意：MySQL中用order by排序的字段不一定要在select语句中 我们还可以让ORDER BY语句和LIMIT语句结合使用，不过 ORDER BY 语句必须放在 LIMIT 语句前边 1234567mysql&gt; SELECT * FROM student_score ORDER BY score LIMIT 1;+----------+-----------------------------+-------+| number | subject | score |+----------+-----------------------------+-------+| 20180104 | 论萨达姆的战争准备 | 46 |+----------+-----------------------------+-------+1 row in set (0.00 sec) 这样就能找出成绩最低的那条记录了]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底弄懂Unicode编码那些事儿]]></title>
    <url>%2F2020%2F03%2F22%2F%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[Java中是采用Unicode编码方式的，作为万国码，它的应用非常广泛，因此下面我们就开始彻底弄懂它吧！ ASCII码在学校学 C 语言的时候，了解到一些计算机内部的机制，知道所有的信息最终都表示为一个二进制的字符串，每一个二进制位有 0 和 1 两种状态，通过不同的排列组合，使用 0 和 1 就可以表示世界上所有的东西，感觉有点中国“太极”的感觉——“太极生两仪，两仪生四象，四象生八卦”。 在计算机种中，1 字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256 中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码，即ASCII码用一个字节完成字符表示。 ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 对应的ASCII码是65（这是十进制数，对应二进制是0100 0001）。这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0。 历史遗留问题英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 因此，ASCII码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。 Unicode编码最终，人们意识到应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。 Unicode相当于是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，即Unicode没有说明如何用二进制存储这些字符。我们只用知道 Unicode 给所有的字符指定了一个数字（后面可以看到，这个数字叫码点）用来表示该字符。 Unicode是计算机领域的一项行业标准，它对世界上绝大部分的文字的进行整理和统一编码，Unicode的编码空间可以划分为17个平面（plane），每个平面包含2的16次方（65536）个码位。在Unicode编码标准中，码点采用十六 进制书写，并加上前缀U+ 例如：U+0041就是A的码点。17个平面的码位可表示为从U+0000到U+10FFFF，共计1114112个码位，第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区段是永久保留不映射到Unicode字符，所以有效码位为1112064个。 对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 Unicode编码方式之前提到，Unicode没有规定其中的字符对应的二进制码点如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。 这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。 于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。 UTF-8UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8是目前互联网上使用最广泛的一种Unicode编码方式，它的特点是可变长。它可以使用1-4个字节来存储一个字符，根据字符的不同而变换长度。编码规则如下： 对于单个字节的字符（码点范围是0 ~ 127），第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同，即可兼容ASCII码。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充 编码规则如下： Unicode十六进制码点范围 UTF-8二进制模板 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16在了解UTF-16编码方式前，先了解以下另外一个概念——“平面” 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个平面，也就是说，整个 Unicode 字符集的大小现在是17*65536=1114112。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 UTF-32UTF-32是一种定长编码，使用一个32bit的码元，其值域Unicode码点值相等。举例如下 字符 Unicode码点值 UTF-32编码 A U+0041 0x00 0x00 0x00 0x41 破 U+7834 0x00 0x00 0x78 0x34 晓 U+6653 0x00 0x00 0x66 0x53 𪚥 U+2A6A5 0x00 0x02 0xA6 0xA5 UTF-8、UTF-16和UTF-32的比较这三种编码方案各有优缺点，下面分别介绍 UTF-8优点 兼容 ASCII 没有字节序问题 以英文和西文符号比较多的场景下（例如 HTML/XML），编码较短 由于是变长，字符空间足够大，未来 Unicode 新标准收录更多字符，UTF-8 也能妥妥的兼容，因此不会再出现 UTF-16 那样的尴尬 容错性高，局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，因为 UTF-8 的字符边界很容易检测出来，这是一个巨大的优点（正是为了实现这一点，咱们中日韩人民不得不忍受 3 字节 1 个字符的苦日子） 缺点 文化上的不平衡——对于欧美地区一些以英语为母语的国家 UTF-8 简直是太棒了，因为它和 ASCII 一样，一个字符只占一个字节，没有任何额外的存储负担；但是对于中日韩等国家来说，UTF-8 实在是太冗余，一个字符竟然要占用 3 个字节，存储和传输的效率不但没有提升，反而下降了。所以欧美人民常常毫不犹豫的采用 UTF-8，而我们却老是要犹豫一会儿。 变长字节表示带来的效率问题——大家对 UTF-8 疑虑重重的一个问题就是在于其因为是变长字节表示，因此无论是计算字符数，还是执行索引操作效率都不高。为了解决这个问题，常常会考虑把 UTF-8 先转换为 UTF-16 或者 UTF-32 后再操作，操作完毕后再转换回去。而这显然是一种性能负担。 UTF-16优点 最流行的操作系统和 UI framework 的内部字符串表达都是 UTF-16 曾经在计算字符串长度、执行索引操作时速度很快。（但随着Unicode收录的字符超过了65536个，UTF-16也从定长变成了变长，就没那么快了） 缺点 UTF-16 能表示的字符数有 65536，看起来很多，但是实际上目前 Unicode 5.0 收录的字符已经达到 99024 个字符，早已超过 UTF-16 的存储范围；这直接导致 UTF-16 地位颇为尴尬——如果谁还在想着只要使用 UTF-16 的定常特性就可以高枕无忧的话，恐怕要失望了。 UTF-16 存在大小端字节序问题，这个问题在进行信息交换时特别突出——如果字节序未协商好，将导致乱码；如果协商好，但是双方一个采用大端一个采用小端，则必然有一方要进行大小端转换，性能损失不可避免（大小端问题其实不像看起来那么简单，有时会涉及硬件、操作系统、上层软件多个层次，可能会进行多次转换）。 另外，容错性低有时候也是一大问题——局部的字节错误，特别是丢失或增加可能导致所有后续字符全部错乱，错乱后要想恢复，可能很简单，也可能会非常困难。（这一点在日常生活里大家感觉似乎无关紧要，但是在很多特殊环境下却是巨大的缺陷）。 UTF-32优点 定长编码，UTF-32 表示任何字符都用 4 字节，读到内存中是个均匀的整形数组，于是我们可以很方便地随机访问任何一个字符 由于是定长，索引比变长的要快，你想访问一个字符串中的第 n 个字符，UTF-32 直接偏移 n 个整型距离即可，UTF-8 得从第一个字节一个字一个字地往后蹦，非常蛋疼。 缺点 太占内存啦 那么在实际使用中，该如何选择上述编码方式呢？ UTF-8，用于存储及传输 UTF-32，用于程序内存中 因为UTF-8灵活，在互联网通信中被编码影响小，兼容性强。UTF-32定长，在内存中程序处理优秀，查询快。]]></content>
      <categories>
        <category>Java</category>
        <category>字符编码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源文件名和类名的关系]]></title>
    <url>%2F2020%2F03%2F21%2F%E6%BA%90%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E7%B1%BB%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一个源文件中可以定义多个类，每个class定义会生成一个对应的字节码文件 123456789// Test.java源文件class A&#123;&#125;class B&#123; &#125;class C&#123;&#125; 上述java源文件编译后，会生成A.class、B.class和C.class三个字节码文件 如果源文件中有被public关键字修饰所修饰的类，那么源文件名必须与public所修饰的类同名 源文件中定义的类，最多只能有一个类被public关键字修饰（可以这么理解，如果有两个public类，它们都需要和源文件同名，这显然是不可能的） 如果源文件中没有public修饰的类，源文件可任意命名 每一个class当中都可以编写main方法，都可以设定程序的入口。可以在所有类里都写上 main 方法，给程序提供N多个入口，但是最后你运行程序的时候也只能从其中的一个入口进去（程序员在做单元测试时，会往自己做的很多类里面添加 main 方法，因为他要为自己做的东西添加运行入口，从而能方便测试） 123456789101112131415161718// A.java源文件public class A&#123; public static void main(String[] args)&#123; System.out.println("A's main method!"); &#125;&#125;class B&#123; public static void main(String[] args)&#123; System.out.println("B's main method!"); &#125;&#125;class C&#123; public static void main(String[] args)&#123; System.out.println("C's main method!"); &#125;&#125; 上述代码编译后会生成三个字节码文件：A.class、B.class和C.class。在DOS界面执行 java A会输出 “A‘s main method！”。同样的，执行 java B会输出 “B’s main method!”。C类似 当在命令窗口执行 java x的时候，要求定义x这个类当中必须有main方法。没有main方法会出现运行阶段的错误]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境变量那些事儿]]></title>
    <url>%2F2020%2F03%2F20%2FJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[虽然现在Java版本已经更新到Java14，且从Java11开始，不提供JRE的下载，只提供JDK的下载。但Java1.8由于其稳定性，依然具有广泛的应用。（注意：Java1.8在安装时会有两套JRE，一套在Java目录下，一套在Java目录下的JDK目录中）。 JDK自带的jre称为专用jre，后面独立安装的jre称为公共jre如果安装了JDK的话，其实是没必要再安装公共jre的，公共jre的作用是自动向系统和浏览器注册Java运行环境，以及提供了一些Java更新服务，所以没必要再去单独安装这个公共jre，只要正常安装JDK，指定好环境变量后，就OK了 从JDK11开始，无论是开发机器还是部署机器都需要下载JDK，且配置环境变量。因为不再提供JRE的下载了。 JDK7与JDK8安装的区别 JDK7在安装公共jre时会在System32中放置ava.exe，javaw.exe，javaws.exe。而JDK8不会在system32里放置java.exe，javaw.exe，javaws.exe，所以在只安装了JDK8未做任何设置的情况下，应该是无法执行java.exe命令的，那么JDK8就只安装了jdk1.8的文件夹和jre1.8么，也不是，在 C:\ProgramData\Oracle\Java\javapath路径下可以找到JDK8版本的java.exe，javaw.exe，javaws.exe，只不过由于这个目录并不在PATH变量下，所以命令行中java命令无法找到这里，当你把这个目录添加到PATH之后，就可以找到了。 下面先聊一聊Java环境变量配置（主要是Path和ClassPath）： 高级系统设置-&gt; 环境变量-&gt; 系统变量 新建JAVA_HOME变量，变量值为下载的JDK路径 新建CLASSPATH变量（非必须），变量值如下（最前面的点不能省略，它代表当前路径） 1.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 在Path变量中，加入如下路径 1%JAVA_HOME%\bin; 至此，环境变量配置完毕。可以在DOS界面使用javac和java了 下面介绍一下CLASSPATH这个环境变量 默认情况下，ClassLoader从当前路径下加载.class字节码文件。当然，也可以让ClassLoader去某个指定路径下加载字节码文件，这时需要配置环境变量CLASSPATH。 CLASSPATH环境变量属于java语言中的环境变量，不属于windows操作系统（Path环境变量属于操作系统）。CLASSPATH是给ClassLoader类加载器指路的。 当CLASSPATH环境变量没有配置的话，类加载器默认从当前路径下找字节码文件；当CLASSPATH环境变量配置为某个指定路径之后，类加载器只去指定的路径中加载字节码。 综上，CLASSPATH环境变量不是必须要配置的。 安装JDK时，有两套JRE的相关问题（JDK1.8版本及以前才存在这个问题） 记得在环境变量path中设置%JAVA_HOME%/bin路径M么？这应该是学习Java的第一步吧，不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。 可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin（公共JRE）目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ 但是，明明没有设置 jre/bin目录到环境变量中啊？ 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？ 所以安装公共jre的时候安装程序自动帮你把公共jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%\system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java.exe，不过除非有必要，我不建议大家这么做。 两套jre，Java程序具体执行时最后使用哪个jre？这个机制是什么？ 这个问题只存在于Java1.8版本及以前，从Java11开始后就不存在了，因为没有JRE可下载，只有JDK。 系统存在多套jre时，那么由谁来决定使用哪一套jre呢？这个重担就落在java.exe的身上。 比如如果在命令行中输入java xxx的时候，java.exe的任务就是在我们电脑系统中众多的jre中找到合适的jre来执行xxx。java.exe依据以下顺序来寻找jre： 当前目录下是否是JRE目录下的bin，适用于JRE\bin目录下的java.exe 父目录下是否存在JRE目录，适用于JDK\bin目录下的java.exe（D:\Java\jdk1.8.0_40\bin中的java.exe执行时只会使用D:\Java\jdk1.8.0_40\jre的jre，就是出于这个原因） 查询注册表HKEY_LOCAL_MACHINE\Software\JavaSoft\JavaRuntime Environment\，适用于system32以及C:\ProgramData\Oracle\Java\javapath下的java.exe 所以java.exe的执行结果与我们电脑里哪一个java.exe（搜索一下就会发现我们电脑里面也不止一个java.exe）被执行有很大的关系。 另外，java.exe在找到合适的jre以后，还有一个验证版本的程序，也就是java.exe与jre的版本一致才可以执行。如果出现版本不一致的问题，一定要记得两件事情： 哪一个java.exe被执行； java.exe找到哪一套jre。 只要这两件事情确定了，我们就抓住了问题的来龙去脉，理解起来也就轻而易举了。 有一篇博客也介绍了类似问题：Windows的JDK与JRE，java.exe在哪里是谁干了什么，用来参考 当存在多个java.exe时，如何知道哪个java.exe被执行？ 1where java 在cmd中输入where java，如果系统环境变量path中存在，就会输出相应的路径。 在windows上实现多个JDK的共存解决办法 安装两个版本的JDK，比如JDK6和JDK7 环境变量如下设置： JAVA7_HOME = JDK7的安装路径 JAVA6_HOME = JDK6的安装路径 JAVA_HOME = %JAVA6_HOME%（注意:如果你想切换jdk，就在此处设置切换即可） 添加%JAVA_HOME%\bin到环境变量path中 可能存在的问题：如果先安装JDK1.6，再安装JDK1.7。未修改JAVA_HOME（仍然为JAVA6_HOME），但调用java -version指令显示1.7的版本。其实原因很简单，上面已经说过了。在安装JDK1.7时（本机先安装jdk1.6再安装的jdk1.7），自动将java.exe、javaw.exe、javaws.exe三个可执行文件复制到了C:\Windows\System32目录，这个目录在WINDOWS环境变量中的优先级高于JAVA_HOME设置的环境变量优先级。 解决方案：删除C:\Windows\System32目录下的java.exe即可 解决后，使用的即为各JDK版本的专用JRE，而非共用JRE。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK和JRE间的那些事儿]]></title>
    <url>%2F2020%2F03%2F20%2FJDK%E5%92%8CJRE%E9%97%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[首先了解下这两者的概念 JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。 JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe等。 显然，这两者的关系是：包含关系。JDK 包含了 JRE。 在JDK1.8（包含以前）的版本中，安装成功后，会存在两个JRE文件夹：…/Java/jre和…/Java/jdk/jre 这两个JRE有什么联系么？ 答案是：没有联系。甚至准确的来说，它俩是一样的，无论是用哪一个都是可以的。只是很多人习惯将会单独安装另一个 jre，虽然单独安装的 jre 也并没有被使用，原因可能就是刚开始大家都不清楚 jdk 和 jre 之间的关系，所以就默认的都安装上了。 在 jdk 的 bin 目录下，基本上都是一些可执行文件，并且它们还不大。其实这些可执行文件只是外层的一层封装而已，这样的目的是避免输入的命令过长。例如 javac.exe 内部调用的其实是 JDK 中 lib 目录中的 tools.jar 中 com.sun.tools.javac.Main 类，也就是说这些工具只是入口而已。而实际上它们本身又都是由 Java 编写的，所以在 jdk 目录下的 jre 既提供了这些工具的运行时环境，也提供了我们编写完成的 Java 程序的运行时环境。 所以，很明显，jdk 是我们的开发工具包，它集成了 jre ，因此我们在安装 jdk 的时候可以选择不再安装 jre 而直接使用 jdk 中的 jre 运行我们的 Java 程序。（但是大部分人都默认将两个都装上了）。但是如果你的电脑不是用来开发 Java 程序的，而仅仅是用来部署和运行 Java 程序的，那么完全可以不用安装 jdk，只需要安装 jre 即可。 从Java 11后Oracle不再单独发布JRE和Server JRE了，并统一JDK名称为：Oracle JDK 。也就是说从Java11开始不再区分JDK和JRE，下载的jdk本身就是jre，默认没有jre目录。11之后不再区分具体的jre和jdk，你非要自己做的话，你用jlink把所有java开头的jmod都打进去就是你要的jre了。 为什么JDK11后不带JRE? jdk本身就是jre的超集，包含了jre，同时也提供了一些开发者工具 jre是jvm的超集，包含了jvm同时也提供了rt.jar，也就是runtime.jar 现在这些都没有了，就只提供一个jdk下载，不再区分jvm，jre和jdk 你下载下来的jdk本身就是一个大的jre（java runtime） 你要的功能jdk里面都有，只是jdk顺便也提供了更多的东西 Java开始没有JRE下载，只有JDK下载。但JDK是包含JRE的，所以Java程序仍旧可以正常运行。 Jlink可以从JDK中分离JRE，创建一个更小的JRE。步骤如下： 管理员模式打开Cmd，运行到jdk目录 输入下面指令 1bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre 即可在JDK目录下生成一个JRE文件夹 Java1.8及以前，服务器上是否只安装 JRE 就可以了？（Java开始不存在这个问题，因为没有单独的JRE下载，全都要下载JDK） 理论上是可以的，但是有前提条件。 服务器上只安装 JRE 的前提： 发布到服务器上时所有文件都是编译好的文件，包括 JSP 文件 后期不在服务器上直接修改（修改后需要编译，必须要有JDK） 如果部署的项目都是编译后重新部署，不在服务器上直接修改的话是可以只安装 JRE 的。 综合考虑，为避免以后这样那样的麻烦事发生，服务器上还是安装 JDK 吧！毕竟项目后期维护才是主要的事情。 在服务器上安装 JDK 的好处： 可以编译 java 文件，方便后期维护 保证 JSP 文件修改后稳定运行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的加载与执行]]></title>
    <url>%2F2020%2F03%2F18%2FJava%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Java程序的运行包含两个非常重要的阶段 编译阶段 运行阶段 编译阶段编译阶段主要的任务是检查Java源程序是否符合Java语法，符合Java语法则能够生成正常的字节码文件（xxx.class）;不符合Java语法规则则无法生成字节码文件。 字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。 编译阶段的过程： 程序员在硬盘的某个位置新建一个.java扩展名的文件，该文件被称为Java源文件，源文件当中编写的是Java源代码，必须符合Java语法规范 Java程序员使用 JDK当中自带的javac.exe命令进行Java程序的编译 javac怎么用？在哪用？ 在DOS命令窗口使用 javac使用规则：javac 源文件.java javac是一个java编译器工具/命令 一个java源文件可以编译生成多个.class文件（由文件中所定义的类的数量决定，class文件的名字即为类名） 字节码文件/class文件是最终要执行的文件，所以class文件生成之后，java源文件删除并不会影响java程序的运行 运行阶段JDK安装之后，除了自带一个javac.exe之外，还有另一个工具，叫做java.exe，它主要负责运行阶段 java.exe在哪里？怎么用？ 在DOS窗口使用 使用方法：java 类名 例如：硬盘上有一个A.class，就是java A 运行阶段的过程： 打开DOS窗口，输入java A java.exe命令会启动JVM，JVM会启动类加载器ClassLoader ClassLoader会去硬盘搜索A.class文件，找到文件后将该字节码文件装载到JVM中 JVM中的解释器将A.class字节码文件解释称二进制数据文件 然后操作系统执行二进制文件和底层硬件平台进行交互]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件反汇编]]></title>
    <url>%2F2020%2F03%2F16%2Fclass%E6%96%87%E4%BB%B6%E5%8F%8D%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[jdk自带的很多命令都很有用，今天就来简单介绍下jdk的javap命令，javap是jdk自带的反汇编器，使用此命令， 可以将 Java文件编译后的class文件反汇编进而看到 Java编译器给我们生成的字节码，以便我们能更好的分析代码 的执行过程和运行流程。 使用方法： 先写好一个demo.java文件 在cmd中进入到该java文件的目录下，然后使用javac demo.java将其编译，这时你会在当前目录看到一个demo.class文件 之后再cmd中输入javap -c demo命令，将其字节码文件进行反汇编。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从JVM角度看Java多态]]></title>
    <url>%2F2020%2F03%2F15%2F%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E7%9C%8BJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态举例如下： 12345678910111213141516171819202122232425262728293031public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); // 调用子类eat() //f.play(); 编译错误 System.out.println("年龄："+f.age ); // 父类age &#125;&#125; 下面从JVM的角度解释上面这种现象，从下面这句代码切入 1Father f = new Child(); 这句代码首先会执行new Child()，在堆中分配一个对象。当然在分类Child类的实例时，先要通过JVM的类加载器将Child类对应的class文件加载到JVM中，然后JVM根据class文件中的字节流产生一个表示class文件的类型信息结构体。 这个表示class文件的类型信息结构体大概由以下几部分构成： 常量池（较为复杂，存放该类型所用到的常量的有序集合，包括直接常量（字符串、整数、浮点数）和对其他类的字段、方法的符号引用） 类变量（静态变量，只包含本类所定义的，不包含继承自父类的，下面字段信息、方法信息类似） 字段信息 方法信息 类型信息 指向类加载器的引用 指向class实例的引用 方法表 之后，JVM会根据上面这个结构体生成一个叫做虚方法表(vtable)的东西。这个方法表是实现Java多态的一个关键。方法表中欧冠包含的是实例方法（就是相对于静态方法而言的，用对象访问的那些方法，即不包含static、final和private修饰的方法）的直接饮用，也就是说通过这个方法表就能够访问到该类的实例方法。 而且，这些实例方法不仅包括本类的方法，还包括其父类的实例方法，以及父类的父类的实例方法（就是一直到Object）。 方法表中的这些直接应用会指向到JVM中表示类型信息的那个结构体（就是上面那个结构体）的相应的方法信息（就是上面结构体中第4块的某个位置），当然这只是本类的方法，方法表中还有父类的方法，相应地指向父类类型信息结构体的具体位置。如图所示 上面提到过，方法表中不仅包括本类的方法，还包括父类的方法，方法表值这样产生的，以Child类的方法表为例： 首先方法表中，会产生指向继承自Object类的方法的引用，这些包括指向toString的和指向equals的，当然Object中还包括很多方法，这里就不写了 然后方法表中产生指向继承自Parent类的方法的引用，这包括eat， 最后产生指向本类的方法的引用。 这里需要注意的一点是，当Child类的方法表产生指向Parent类中的方法的引用时，会有一个指向eat方法的引用，最后产生指向本类的方法的引用时，也有一个指向eat的引用，这时候，新的数据会覆盖原有的数据，也就是说原来指向Parent.eat的那个引用会被替换成指向Child.eat的引用（占据原来表中的位置）。所以我们看到在Child类的方法表中指向的是Child.eat而Parent类的方法表中指向的是Parent.eat。子类的方法表中就没有指向Parent.eat的引用了。(重写的底层实现) 而且还要注意一个特点就是，Parent和Child的方法表中，指向eat的引用在表中的偏移量是一样的，都是第三个位置。（这是因为子类eat方法覆盖掉了父类eat方法，占据了原来父类eat方法的引用在表中的位置） 这里再多说一句，表示类型信息的结构体（非方法表）中的方法信息，只包含本类特有的，或者是重写的方法信息，没有父类的方法信息。 这里介绍一下方法表的两个特点： 方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。 方法表满足两个性质： 子类方法表中包含父类方法表中的所有方法 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。（即如果子类方法表和父类方法表中同时含有一个函数，那么该函数在各自方法表中的索引值相同） 了解了方法区的结构后，再来看堆中对象的结构 从图中可以看出，堆中的实例对象不仅包含本类实例变量，也包含父类实例变量，分配不同的内存，不存在冲突。本类实例变量分配在本类实例变量区，父类实例变量分配在父类实例变量区。子类实例变量区和父类实例变量区不冲突不重合，都存在于该实例对象堆内存空间中。 由于类的实例变量属于类对象实例，所以分配在堆内存中。静态变量属于类，不属于类实例，所以分配在方法区中。 接下来是栈区，产生Father类型的引用，这个引用指向堆区中的Child类的实例。 这里需要解释一下Father f的含义，我们知道f表示一个引用，这个引用指向堆中的Child类的实例，说白了就是一个地址(其实Java中没有地址，因为地址不安全)，这个地址指向堆中的Child的类的实例 下面探讨一下如何调用方法及变量？1. 调用static方法、final方法和private方法1234567891011class Father&#123; public static void f1()&#123; System.out.println("Father— f1()"); &#125; &#125;public class StaticCall&#123; public static void main()&#123; Father.f1(); //调用静态方法 &#125;&#125; 上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令： 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: Father; 紧接着JVM会加载、链接和初始化Father类; 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫常量池解析 ，以后再次调用Father.f1()时，将直接找到f1方法的字节码; 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。 通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做静态绑定机制 。 除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。 2. 调用实例方法12345678910111213141516171819202122class Father&#123; public void f1()&#123; System.out.println("father-f1()"); &#125; public void f1(int i)&#123; System.out.println("father-f1() para-int "+i); &#125; &#125; //被调用的子类class Son extends Father&#123; public void f1()&#123; //覆盖父类的方法 System.out.println("Son-f1()"); &#125; &#125; //调用方法public class AutoCall&#123; public static void main(String[] args)&#123; Father father=new Son(); father.f1(); &#125;&#125; 对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令： 12345670 new Son [13] //在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈3 dup4 invokespecial #7 [15] // 调用初始化方法来初始化堆中的Son对象7 astore_1 //弹出操作数栈的Son对象引用压入局部变量1中8 aload_1 //取出局部变量1中的对象引用压入操作数栈9 invokevirtual #15 //调用f1()方法12 return 其中invokevirtual指令的详细调用过程是这样的： invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(CONSTATN_Methodref_info) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名:Father。这是因为调用方法f1的类的对象father声明为Father类型。 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项记录到AutoCall类的常量池中第15个常量表中(常量池解析 )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间 上述即为多态的实现机制，即动态绑定。 3. 调用变量1234567891011// Father 父类public class Father&#123; int age = 10;&#125;public class Son extends Father&#123; int age = 20;&#125;// Son 子类Father f = new Son();System.out.println(f.age); // 10 这里主要涉及到 Java里面一个字段隐藏的概念。父类和子类定义了一个同名的字段，不会报错。但对于同一个对象，用父类的引用去取值，会取到父类的字段；用子类的引用去取值会取到子类字段的值。在实际开发中，要尽量避免子类和父类使用相同的字段名，否则很容易引入一些不容易发现的bug。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2020%2F03%2F13%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是OOP？ 面向对象编程：Object-Oriented Programming 对现实世界建立计算机模型的一种编程方法 面向过程和面向对象的区别？ 面向过程：主要关注点是实现的具体过程，因果关系 优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低 缺点：采用面向过程的方式很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间的耦合度非常高。只要其中一环出问题，整个系统受到影响。导致最终的软件扩展力低。另外，由于没有独立体的概念，所以无法达到组件复用 面向对象：主要关注对象（独立体）能完成那些功能 优点：耦合度低，扩展力强。更容易解决现实世界中更复杂的业务逻辑，组件复用性强 缺点：前期投入成本较高，需要进行独立体的抽取，存在大量的系统分析与设计 面向对象的三大特性：封装、继承、多态。 采用面向对象的方式开发一个软件，生命周期当中存在： 面向对象分析OOA 面向对象设计OOD 面向对象编程OOP 类和对象的概念​ 类在现实世界中是不存在，是一个模板，是一个概念，是人类大脑思考抽象的结果。类代表了一类事物。在现实世界中，对象A和对象B之间具有共同的特征，进行抽象总结出一个模板，这个模板被称为类 ​ 对象是现实世界实际存在的个体 在Java程序中通过类创建对象 类 ——&gt; (实例化) ——&gt; 对象（对象又被称为实例） 对象 ——&gt;（抽象）——&gt; 类 类描述的是对象的共同特征 一个类主要描述什么信息？ 状态+动作 状态信息：名字、身高、性别等 动作信息：吃、唱歌、学习等 状态 ——&gt; 一个类的属性 动作 ——&gt; 一个类的方法 类{ ​ 属性 // 描述对象的状态信息 ​ 方法 // 描述对象的动作信息 } 现实世界 计算机模型 Java代码 人 类/class class Person{} 小明 实例/ming Person ming = new Preson() 小红 实例/hong Person hong = new Person() 现实世界 计算机模型 Java代码 书 类/class class Book{} Java核心技术 实例/book1 Book book1 = new Book() Java编程思想 实例/book2 Book book2 = new Book() 类/实例（class/instance）class是对象模板 class定义了如何创建实例 class名字就是数据类型 instance是对象实例 instance是根据class创建的实例 可以创建多个instance 各个instance类型相同，但各自属性可能不同 定义class 语法结构： [修饰符列表] class 类名{ } 一个class可以包含多个field（字段），field用来描述一个class的特征 class实现了数据封装 12345678910public class Person&#123; public String name; public int age;&#125;public class Book&#123; public String name; public String author; public String isbn;&#125; 创建实例 new操作符可以创建一个实例，new运算符的作用是创建对象，在JVM堆内存当中开辟新的内存空间 定义一个引用类型变量来指向实例 通过变量来操作实例 通过变量.字段来访问实例字段 12345678public class Person&#123; public String name; public int age;&#125;Person ming = new Person();ming.name = "小明";ming.age = 12; 总结 class和instance是”模板”和”实例”的关系 class是数据类型，instace是数据 class定义了field，每个instance都会拥有各自的field 变量指向instance，并通过变量.字段来访问实例字段 指向instance的变量都是引用变量 数据封装 一个class可以包含多个field 直接将field用public暴露给外部可能破坏了封装 用private修饰field可以拒绝外部访问 当field被设置为private时，可定义public方法间接修改field 123456789101112public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125;&#125;Person ming = new Person();ming.name = "小明"; //编译错误ming.setName("小明"); //正确 方法 外部代码不可访问private字段 外部代码只能通过调用public方法间接设置和获取private字段 public方法封装了数据访问 方法体中不能再定义方法 通过方法访问实例字段更安全 通过变量.方法名()来调用实例方法 定义方法 修饰符列表 返回值类型 返回值类型可以是java中任意一种类型，包括基本数据类型和所有的引用数据类型 方法名称：合法的标识符即可 方法参数列表 形参是局部变量 形参中起决定作用的是形参的数据类型，形参的名字就是局部变量的名字 方法在调用的时候，实际给这个方法传递的真实数据被称为实参 形参列表和实参列表必须满足： 数量和类型对应相同 方法返回值通过return语句实现，如果没有返回值（void）可以省略return。只要带有return关键字的语句执行，return语句所在的方法结束。 当一个方法有返回值时，在调用该方法时可以选择接受也可以选择不接收返回值。但是大部分条件下都是选择接收 12345678910111213141516public class Person&#123; private String name; private int age; public void setName(String name)&#123; this.name = name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String getName()&#123; return this.name; &#125;&#125; 方法内部可以使用隐式变量this，this指向当前实例，this.field可以表示当前实例的字段 在不引起歧义的情况下，可省略this 123public String getName()&#123; return name; //this.name &#125; 局部变量名优先。当字段名和局部变量名重名时，编译器优先查找局部变量名 123public void setName(String name)&#123; this.name = name; &#125; 调用方法 实例变量.方法名(参数) 可以忽略方法返回值 123Person ming = new Person();ming.setName("小明"); // 没有返回值String s = ming.getName(); //返回值为String 类内部调用方法 1234567891011121314151617181920212223public class hello&#123; public static void main(String[] args)&#123; // 完整调用格式 hello.qq(); // 省略调用格式 qq(); // 编译正确 A.a(); // a(); 编译错误 // 注意同一个类中调用方法可以省略类名，不同的类中调用方法不能省略类名 &#125; public static void qq()&#123; System.out.ptintln("xixi"); &#125;&#125;class A&#123; public static void a()&#123; System.out.ptintln("haha"); &#125;&#125; 方法参数传递 方法参数用于接收传递给方法的变量值 方法参数可为基本类型参数或引用类型参数。可简单理解为基本类型是值传递，引用类型是址传递（但是无论是基本类西行还是引用类型，都是传递的是变量中保存的值，只不过有的是字面值，有的是Java对象在堆内存中的地址，所以才会有值传递和址传递的区别，但本质上都是一样的）。见方法调用时的参数传递问题 private方法 外部代码不可访问private方法 内部代码可以调用自己的private方法 构造方法前面可以看到，初始化实例需要三行代码 1234Person ming = new Person(); // 创建对象实例// 初始化对象实例ming.setName("小明");ming.setAge(12); 能否在创建对象实例时就把内部字段全部初始化为合适的值？如下所示 1Person ming = new Person("小明",12); 答案当然是肯定的！需要引入构造方法（又被称为构造函数/ 构造器，constructor）。构造方法用于创建对象 构造方法的作用 创建对象 创建对象的同时，初始化实例变量的内存空间 成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量 实例变量没有手动赋值的时候，系统默认赋值，那么这个系统默认赋值是在什么时候完成的？是在类加载的时候么？ 不是！因为类加载的时候只加载了代码片段，还没来得及创建对象，所以此时实例变量并没有初始化。 实际上，实例变量的内存空间是在构造方法执行过程中完成开辟、初始化的。系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值 构造方法语法结构 [修饰符列表] 构造方法名（形参列表）{ ​ 构造方法体； } 普通方法语法结构 [修饰符列表] 返回值类型 构造方法名（形参列表）{ ​ 方法体； } 构造方法可以在创建对象实例时初始化对象实例 构造方法名就是类名，必须保持一致 构造方法的参数没有限制 构造方法没有返回值(类型也没有void) ，只要写上返回值类型就是普通方法了（不写返回值类型不代表没有返回值） 必须用new操作符调用构造方法 调用方法：new 构造方法名(实参列表) 构造方法调用后有返回值么？ 每一个构造方法实际上执行结束后都有返回值，但是不需要写，构造方法结束的时候java程序自动返回值，返回的是对象在堆内存中的地址。并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写 12345678910public class Person&#123; private String name; private int age; // 构造方法 public Person(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125; 如果一个类没有定义构造方法，编译器会自动生成一个默认构造方法，这个构造方法被称为缺省构造器： 无参数 无执行语句 123456public class Person&#123; private String name; private int age; public Person()&#123; &#125;&#125; 如果自定义了构造方法，编译器就不再自动创建默认构造方法。建议开发中手动的为当前类提供无参数构造方法，因为无参数构造方法太常用了。所以构造方法支持重载机制，在一个类中编写多个构造方法，这多个构造方法显然已经构成方法重载机制 123456789101112public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; // 如果自己写的构造函数中没有对所有的实例变量赋值，那么那些没有被赋值的实例变量会被系统赋默认值 &#125;&#125;Person ming = new Person(); // 编译错误// 因为此时没有默认构造方法了 初始化顺序： 先初始化字段 没有赋值的字段初始化为默认值：基本类型=0，引用类型=null 再执行构造方法的代码 123456789public class Person&#123; private String name = "unnamed"; // 第一顺序 private int age; // =0,第二顺序 public Person(String name, int age)&#123; // 第三顺序 this.name = name; this.age = age; &#125;&#125; 可定义多个构造方法，编译器通过构造方法的参数数量、位置和类型区分 1234567891011121314151617181920public class Person&#123; private String name; private int age; // 构造代码: new person("xiaoming",12); public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; // 构造代码: new person("xiaoming"); public Person(String name)&#123; this.name = name; this.age = 18; &#125; // 构造代码: new person(); public Person()&#123; &#125;&#125; 一个构造方法可以调用其他构造方法，便于代码复用。调用其他构造方法的语法是this(…) 1234567891011121314151617public class Person&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public Person(String name)&#123; this(name,18); &#125; public Person()&#123; this("unnamed"); &#125;&#125; 方法重载什么时候考虑方法重载？功能相似的时候，尽可能让方法名相同 定义方法重载（Overload）是指： 在同一个类中 多个方法的方法名相同 但各自参数不同 参数个数不同 12public static void m1()&#123;&#125; public static void m1(int a)&#123;&#125; 参数类型不同 12public static void m2(int a)&#123;&#125;public static void m2(double a)&#123;&#125; 参数位置不同 12public static void m3(int a,double b)&#123;&#125;public static void m3(double a,int b)&#123;&#125; 方法重载只和方法名+参数列表有关，与返回值类型无关，与修饰符列表无关 12public static int q()&#123;&#125;public static void q()&#123;&#125; // 编译报错，因为就是同一个方法，没有构成重载 方法重载的目的 相同功能的方法使用统一名字 便于调用 方法递归什么是递归方法自身调用自身 1234public static void doSome()&#123; System.out.println("begin"); doSome();&#125; 递归很耗费栈内存，递归算法可以不用的时候尽量别用。容易发生爆栈错误：java.lang.StackOverflowError。因此递归必须有结束条件，否则肯定会发生爆栈 继承1234567891011public class Person /* extends Object */ &#123; private String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; private int score; public void setScore(int score) &#123;...&#125; public int getScore() &#123;...&#125;&#125; Student可以从Person继承 继承使用关键字extends Student获得了Person所有的功能 Student只需要编写新增的功能 Person：超类(super)、父类、基类 Student：子类(subclass)、扩展类 继承树 Object是Java提供的所有类的根类，如果没有写extends，则默认继承自Object类。 Java只允许class继承自一个类 一个类有且仅有一个父类（Object除外） protected Person类定义的private字段无法被子类访问 用protected修饰的字段可以被子类访问 1234567891011public class Person /* extends Object */ &#123; protected String name; private int age; public void run() &#123;...&#125;&#125;public class Student extends Person&#123; public String hello()&#123; return "hello"+this.name; // 编译通过 &#125;&#125; super继承关系中的构造方法 123456789101112public class Person&#123; public Person() &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student()&#123; super(); System.out.println("student"); &#125;&#125; super关键字表示父类(超类) 子类的构造方法的第一行语句必须调用父类的构造方法，调用方式为super() 没有super()时编译器会自动生成super() 如果父类没有默认构造方法，子类就必须显式调用super() 12345678910111213public class Person&#123; public Person(String name) &#123; System.out.println("person"); &#125;&#125;public class Student extends Person&#123; public Student(String name)&#123; //super(); // 这种构造会报错 super(name); //这样才正确 System.out.println("student"); &#125;&#125; 向上转型语法规则：&lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;(); 1Person p = new Student(); 此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，不是父类的方法。 此时通过父类引用变量无法调用子类特有的方法 向上转型虽然使代码变得简洁，体现了JAVA的抽象编程思想，但是也出现了上面提到的子类无法调用其独有的方法，这要怎么解决呢？所以就有了与之对应的向下转型，弥补了向上转型所带来的缺陷。 向下转型 向下转型把抽象的类型变成一个具体的子类型 12Person p = new Student();Student s = (Student)p; // 向下转型 向下转型很可能报错：ClassCastException 在向下转型过程中，分为两种情况： 情况一：如果父类引用的对象是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。 情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 instanceof操作符可以判断对象的类型 1234567Person p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // fasleStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // fasle Java中，instanceof运算符的前一个操作符是一个引用变量，后一个操作数通常是一个类（可以是接口），用于判断前面的引用所指向的对象是否是后面的类，或者其子类、实现类的实例。如果是返回true，否则返回false。 多态多态的优点提高了代码的扩展性，前期定义的代码可以使用后期的内容 多态的弊端前期定义的内容不能使用（调用）后期子类的特有方法（就是多态调用的只能是父类）。但如果是继承子类覆盖了父类方法，多态调用的仍是子类的方法！ 多态的类型分为以下两种： 编译时多态：指的是 方法重载。编译时多态是在编译时确定调用处选择那个重载方法，所以也叫 静态多态，算不上真正的多态。所以，一般说的多态都是运行时的多态。 运行时多态：由于 方法重写，所以想要确定引用变量所调用的方法的入口，必须根据运行时的引用变量所指向的实例对象来确定。从而使得同一个引用变量调用同一个方法，但不同的实例对象表现出不同的行为。 多态的前提条件 子类继承父类 子类覆盖父类的方法 父类引用指向子类对象 多态性的实现： 依靠动态绑定； 绑定： 将一个方法调用与方法主体关联起来。 前期绑定： 在程序执行前绑定，由编译器和链接程序完成，C语言的函数调用便是前期绑定。 动态绑定： 也称 后期绑定。在运行时，根据具体的对象类型进行方法调用绑定。除了static方法、final方法（private方法也是final方法），其他方法都是动态绑定； 方法重载、重写与隐藏重载（Overload）方法重载就是在同一个类中，多个方法名称相同但是参数类型或者参数个数不同的方法，与返回值类型和修饰符无关 重写（Override）子类继承父类时，子类的方法名称、参数类型、参数个数与父类完全相同，则认为子类重写了父类的方法。 方法重写规则： 参数列表和原方法完全相同 返回值类型和原方法相同或者为父类返回值类型的子类型 不能比原方法限制更严格的访问级别(举例：父类方法为public，那么子类不能为protected、private) 父类方法被定义为final时，则不能被重写 父类方法被定义为static时，不能被重写，但是可以重写声明一个相同的方法（参考隐藏） 不能抛出新的异常或比原方法更广泛的异常（父类抛出IOException，重写方法不能抛出Exception只能抛出IOException或者IOException子类异常） 方法重写的条件 重写的方法是子类从父类继承下来的实例方法（就是相对于静态方法而言的，用对象访问的那些方法），不能是静态方法 子类重写后的方法的 返回类型 必须是 原父类方法的返回类型的可替换类型 子类重写后的方法的访问权限 不能比 原父类方法的访问权限低； 子类重写后的方不能比父类方法抛出更多的异常； 当重写泛型方法时，先进行类型擦除。再按照上面的4个小点，重写类型擦除后的方法; 可替换类型补充： 对于返回类型是基本类型、void，重写方法的返回类型必须是一样； 对于返回类型是引用类型，返回类型可替换成该类型的 子类型; 12345678910111213141516171819class ParentClass&#123;//父类 public int count() &#123;// return 0; &#125; Object method() &#123; return "aa"; &#125;&#125;class ChildClass extends ParentClass&#123;//子类 public int count() &#123;//重写count()方法，由于返回类型是基本类型，不能变，必须是一致 return 0; &#125; public String method() &#123;//重写method()：访问权限增大，返回类型是Object的子类String return "aa"; &#125;&#125; 隐藏隐藏是针对于父类的成员变量和静态方法而言的。子类中声明了和父类相同的变量名或静态方法(方法名相同、参数列表相同、返回类型相同)则实现了对父类成员变量和静态方法的隐藏。从父类继承下来的成员中，除了部分方法是可以重写外，其余成员都是隐藏，如变量、内部类、静态方法等。 注意：final方法既不能被重写，也不能被隐藏 JAVA中方法和变量在继承时的覆盖和隐藏规则 父类的实例变量和静态变量能被子类的同名变量隐藏 父类的静态方法被子类的同名静态方法隐藏 父类的实例方法被子类的同名实例方法覆盖 换言之，多态是基于重写实现的，针对实例方法。变量、static方法、final方法和private方法不能重写。其中final方法和private方法不能隐藏。 多态举例123456789101112131415161718192021222324252627282930313233343536public class Father&#123; // 父类 protected int age; public Father()&#123; age = 40; &#125; void eat()&#123; System.out.println("父亲在吃饭"); &#125;&#125;public class Child extends Father&#123; // 子类 protected int age; public Child()&#123; age = 18; &#125; void eat()&#123; System.out.println("孩子在吃饭"); &#125; void play()&#123; System.out.println("孩子在打CS"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Father f = new Child(); // 父类引用指向子类对象，多态实现形式 f.eat(); //f.play(); 编译错误 System.out.println("年龄："+f.age ); &#125;&#125; 结论：当满足Java多态的三个条件时，可以发现f.eat()调用的实际上是子类的eat，但f.age调用的还是父类的age，而f.play()则不会通过编译。(多态实现机制可看另一篇文章：从JVM角度看Java多态)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命令行参数]]></title>
    <url>%2F2020%2F03%2F12%2FJava%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命令行参数定义刚学习Java时，我们都会接触到下面这个简单的程序，我们可以main函数中定义了一个字符串数组参数，这就称为命令行参数，但是我们运行程序时从来没有给这个参数传值，那么我们怎么给这个参数传值呢？ 12345public class hello&#123; public static void main(String[] args)&#123; System.out.println("hello world"); &#125;&#125; 如何传入命令行参数？可以在Eclipse中想main函数传递命令行参数，也可以在dos窗口运行java程序时传入命令行参数。下面分别介绍 在Eclipse中想main函数传递命令行参数 新建Java程序，输入命令行参数 123456public class helloworld&#123; public static void main(String[] args)&#123; for(String arg:args) System.out.println(arg); &#125;&#125; 从窗口中直接设置传入的值，选择”运行”-&gt;”调试配置”。如图所示 选择java应用程序-&gt;自变量，填入命令行参数，并点击运行 运行结果 在dos窗口运行Java程序时传入命令行参数 在cmd中编译上述helloworld.java文件 编译结束后会产生.class字节码文件 在命令行中运行helloworld.class文件，并传入命令行参数，以下是运行结果 注意：如果命令行参数含有空格，要加双引号]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列的属性]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%88%97%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[回顾一下建表语句： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 表中的每个列都可以有一些属性，至于这些属性是什么以及怎么在创建表的时候把它们定义出来就是本章接下来的内容哈。 默认值我们在书写INSERT语句插入记录的时候可以只指定部分的列，那些没有被显式指定的列的值将被设置为NULL，换一种说法就是列的默认值为NULL，NULL的含义是这个列的值还没有被设置。如果我们不想让默认值为NULL，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个DEFAULT属性，就像这样： 1列名 列的类型 DEFAULT 默认值 比如我们把first_table的second_column列的默认值指定为’abc’，创建一下这个表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) DEFAULT 'abc' -&gt; );Query OK, 0 rows affected (0.02 sec) 如果我们不设置默认值，其实就相当于指定的默认值为NULL，比如first_table表并没有设置first_column列的默认值，那它的默认值就是NULL，也就是说上边的表定义语句和下边这个是等价的： 1234CREATE TABLE first_table ( first_column INT DEFAULT NULL, second_column VARCHAR(100) DEFAULT 'abc'); NOT NULL 属性有时候我们需要要求表中的某些列中必须有值，不能存放NULL，那么可以用这样的语法来定义这个列： 1列名 列的类型 NOT NULL 如果将first_column设置为NOT NULL属性，这样的话，我们就不能再往这个字段里插入NULL值了，比如这样： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(NULL, 'aaa');ERROR 1048 (23000): Column 'first_column' cannot be null 看到报了个错，提示first_column列不能存储NUL。 另外，一旦对某个列定义了NOT NULL属性，那这个列的默认值就不为NULL了。上边first_colum并没有指定默认值，意味着我们在使用INSERT插入行时必须显式的指定这个列的值，而不能省略它，比如这样就会报错的： 12mysql&gt; INSERT INTO first_table(second_column) VALUES('aaa');ERROR 1364 (HY000): Field 'first_column' doesn't have a default value 主键有时候在我们的表里可以通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为候选键。比如在学生信息表student_info中，只要我们知道某个学生的学号，就可以确定一个唯一的学生信息，也就是一条记录。当然，我们也可以通过身份证号来确定唯一的一条学生信息记录，所以学号和身份证号都可以作为学生信息表的候选键。在学生成绩表student_score中，我们可以通过学号和科目这两个列的组合来确定唯一的一条成绩记录，所以（学号、科目）这两个列的组合可以作为学生成绩表的候选键。 一个表可能有多个候选键，我们可以选择一个候选键作为表的主键。一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键： 如果主键只是单个列的话，可直接在该列后面声明PRIMARY KEY，比如可以把学生信息表student_info的学号列声明为主键： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 也可把主键的声明单独提取出来，用这样的形式声明： 123456789101112PRIMARY KEY (列名1, 列名2, ...)// 示例如下CREATE TABLE student_info ( number INT, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, PRIMARY KEY (number)); 值得注意的是，对于多个列的组合作为主键的情况，必须使用这种单独声明的形式，比如student_score表里的（学号,科目）的列组合作为主键，可以这么写： 123456CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject)); 在我们创建表的时候就声明了主键的话，MySQL会对我们插入的记录做校验，如果新插入记录的主键值已经在表中存在了，那就会报错。 另外，主键列默认是有NOT NULL属性，也就是必填的，如果填入NULL值会报错。所以大家在插入数据的时候至少别忘了给主键列赋值哈～ UNIQUE属性对于不是主键的其他候选键，如果也想让MySQL在我们向表中插入新记录的时候帮助我们校验一下某个列或者列组合的值是否重复，那么我们可以把这个列或列组合添加一个UNIQUE属性，表明该列或者列组合的值是不允许重复的。与我们在建表语句中声明主键的方式类似，为某个列声明UNIQUE属性的方式也有两种： 如果我们想为单个列声明UNIQUE属性，可以直接在该列后填写UNIQUE或者UNIQUE KEY，比如在学生信息表student_info中，我们不允许两条学生基本信息记录中的身份证号是一样的，那我们可以为id_number列添加UNIQUE属性： 123456789CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18) UNIQUE, department VARCHAR(30), major VARCHAR(30), enrollment_time DATE); 我们也可以把UNIQUE属性的声明单独提取出来，用下面的形式声明。值得注意的是，对于多个列的组合具有UNIQUE属性的情况，必须使用这种单独声明的形式。 123UNIQUE [约束名称] (列名1, 列名2, ...)// 或者UNIQUE KEY [约束名称] (列名1, 列名2, ...) 其实每当我们为某个列添加了一个UNIQUE属性，就像是在孙悟空头上带了个紧箍咒一样，从此我们插入的记录的该列的值就不能重复，所以为某个列添加一个UNIQUE属性也可以认为是为这个表添加了一个约束，我们就称之为UNIQUE约束。每个约束都可以有一个名字，像主键也算是一个约束，它的名字就是默认的PRIMARY。不过一个表中可以为不同的列添加多个UNIQUE属性，也就是添加多个UNIQUE约束，每添加一个UNIQUE约束，我们就可以给它起个名，这也是上边的约束名称的含义。不过约束名称是被中括号[]扩起来的，意味着我们写不写都可以，如果不写的话MySQL自己会帮我们起名。其实就像是自己生了个孩子，如果自己不起名的话，人家公安局的警察叔叔也得给孩子起个名上户口。 如果表中为某个列或者列组合定义了UNIQUE属性的话，MySQL会对我们插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错！ 主键和UNIQUE约束的区别：主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是： 一张表中只能定义一个主键，却可以定义多个UNIQUE约束！ 规定：主键列不允许存放NULL，而声明了UNIQUE属性的列可以存放NULL，而且NULL可以重复地出现在多条记录中！(即多条记录的UNIQUE约束中的列都设置为NULL时，不会报已存在错误) 外键插入到学生成绩表student_score中的number(学号)列中的值必须能在学生基本信息表student_info中的number列中找到，否则如果一个学号只在成绩表里出现，而在基本信息表里找不到相应的记录的话，就相当于插入了不知道是哪个学生的成绩，这显然是荒谬的。为了防止这样荒谬的情况出现，MySQL给我们提供了外键约束机制。定义外键的语法是这样的： 1CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 其中的外键名称是可选的，一个名字而已，我们不自己命名的话，MySQL自己会帮助我们命令。 上面的语法是在创建表时建立外键的方法。如果表已经建立，怎么添加外键？ 1ALTER TABLE 表名 ADD CONSTRAINT [外键名称] FOREIGN KEY(列1,列2,...) REFERENCES 父表名(父列1,父列2,...); 如果A表中的某个列或者某些列依赖与B表中的某个列或者某些列，那么就称A表为子表，B表为父表。子表和父表可以使用外键来关联起来，上边例子中student_score表的number列依赖于student_info的number列，所以student_info就是一个父表，student_score就是子表。在建立student_score时可定义外键如下： 1234567CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject), CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number)); 这样，在对student_score表插入数据的时候，MySQL都会为我们检查一下插入的学号是否能在student_info表中找到，如果找不到则会报错。 注意：父表中被子表依赖的列或者列组合必须建立索引，如果该列或者列组合已经是主键或者有UNIQUE属性，那么它们也就被默认建立了索引。示例中student_score表依赖于stuent_info表的number列，而number列又是stuent_info的主键，所以在student_score表中创建外键是没问题的。 建立外键后如何删除外键？ 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 如果在建立外键时未指定外键名称，MySQL会自动分配外键名。可通过show create table 表名; 来查看外键名称。 AUTO_INCREMENT属性AUTO_INCREMENT翻译成中文可以理解为自动增长，简称自增。如果一个表中的某个列的数据类型是整数类型或者浮点数类型，那么这个列可以设置AUTO_INCREMENT属性。当我们把某个列设置了AUTO_INCREMENT属性之后，如果我们在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为NULL或者0，那么新插入的记录在该列上的值就是当前该列的最大值加1后的值。我们可以用这样的语法来定义这个列： 1列名 列的类型 AUTO_INCREMENT; 定义列为AUTO_INCREMENT时需注意以下几点： 如果未指定值，默认从1开始递增 一个表中最多有一个具有AUTO_INCREMENT属性的列 具有AUTO_INCREMENT属性的列必须建立索引。主键和具有UNIQUE属性的列会自动建立索引 拥有AUTO_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值 一般拥有AUTO_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值 列的注释可以在建表结尾处添加COMMENT语句为表添加注释，也可以在每个列结尾添加COMMENT为列添加注释。具体语法如下： 12345CREATE TABLE first_table ( id int UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '自增主键', first_column INT COMMENT '第一列', second_column VARCHAR(100) DEFAULT 'abc' COMMENT '第二列') COMMENT '第一个表'; ZEROFILL属性对于INT(M)类型，M为所谓的显示宽度。显示宽度是在是在查询语句显示的结果中，如果声明了 ZEROFILL 属性的整数列的实际值的位数小于显示宽度时，会在实际值的左侧补0，使补0的位数和实际值的位数相加正好等于显示宽度。 1234567891011121314151617mysql&gt; CREATE TABLE zerofill_table ( -&gt; i1 INT(5) UNSIGNED ZEROFILL, -&gt; i2 INT UNSIGNED -&gt; );Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO zerofill_table(i1, i2) VALUES(1, 1);Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM zerofill_table;+-------+------+| i1 | i2 |+-------+------+| 00001 | 1 |+-------+------+// 这里补充了4个0，凑齐五位显示宽度1 row in set (0.00 sec) 使用ZEROFILL属性注意以下几点： 在展示查询结果时，某列数据自动补0的条件有这几个： 该列必须是整数类型的 该列必须有UNSIGNED ZEROFILL的属性 该列的实际值的位数必须小于显示宽度 在创建表的时候，如果声明了ZEROFILL属性的列没有声明UNSIGNED属性，那MySQL会为该列自动生UNSIGNED属性。（MySQL现在只支持对无符号整数进行自动补0操作） 显示宽度并不会影响实际类型的实际存储空间。显示宽度仅仅是在展示查询结果时，如果整数的位数不够显示宽度的情况下起作用 只有列的实际值的位数小于显示宽度时才会补0，实际值的位数大于显示宽度时照原样输出。 对于没有声明ZEROFILL属性的列，显示宽度没有一毛钱卵用。 一个列同时具有多个属性每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了～ 注意：有的属性是冲突的，一个列不能具有两个冲突的属性，。如一个列不能既声明为PRIMARY KEY，又声明为UNIQUE KEY，不能既声明为DEFAULT NULL，又声明为NOT NULL。 查看表结构时的列属性有两种方式： 第一种 123456789101112mysql&gt; SHOW CREATE TABLE student_info;| student_info | CREATE TABLE `student_info` ( `number` int(11) NOT NULL, `name` varchar(5) DEFAULT NULL, `sex` enum('男','女') DEFAULT NULL, `id_number` char(18) DEFAULT NULL, `department` varchar(30) DEFAULT NULL, `major` varchar(30) DEFAULT NULL, `enrollment_time` date DEFAULT NULL, PRIMARY KEY (`number`), UNIQUE KEY `id_number` (`id_number`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | 第二种： 123456789101112mysql&gt; DESC student_info;+-----------------+-----------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+-----------------+------+-----+---------+-------+| number | int(11) | NO | PRI | NULL | || name | varchar(5) | YES | | NULL | || sex | enum('男','女') | YES | | NULL | || id_number | char(18) | YES | UNI | NULL | || department | varchar(30) | YES | | NULL | || major | varchar(30) | YES | | NULL | || enrollment_time | date | YES | | NULL | |+-----------------+-----------------+------+-----+---------+-------+ 可以看到： NULL列代表该列是否可以存储NULL，值为NO时，表示不允许存储NULL，值为YES是表示可以存储NULL Key列存储关于所谓的键的信息，当值为PRI时代表主键；当值为UNI时代表UNIQUE属性 Default列代表该列的默认值 Extra代表一些额外的信息。比如说如果某个列具有AUTO_INCREMENT属性就会被展示在这里]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常见问题汇总]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文主要记录在学习和应用MySQL中碰到的各种问题和解决方法，以备查用。 1. 如何查看端口号？一般有两种方法可查看数据库： 查看MySQL配置文件my.ini 123456mysql&gt; show variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3305 |+---------------+-------+ 2. 如何修改端口号？ 停止mysql服务 1net stop mysql80 打开MySQL根目录下my.ini文件，修改文件中的port值，注意两个地方[client]和[mysqld] 注意，如果要修改一定要同步修改为同一个值。服务器的端口号和客户端的端口号一定要保持一致，这样才能保证它两能顺利建立TCP/IP连接 重启mysql服务 1net start mysql80 3. 修改my.ini遇到权限问题由于修改my.ini文件需要管理员权限。如果没有权限会提示没有权限打开该文件。有两种解决方法： 发现没有权限，如果右键有用管理员打开，直接打开然后修改报错即可。 如果右键没有用管理员打开，就window下用管理员打开记事本，然后用记事本打开my.ini，修改然后保存即可。 4. 解决net start mysql启动,提示发生系统错误 5 拒绝访问在cmd下运行net start mysql 不能启动mysql！提示发生系统错误 5；拒绝访问！切换到管理员模式就可以启动了。所以我们要以管理员身份来运行cmd程序来启动mysql。 如果每天都要启动mysql服务，这样不很麻烦？所以： 右键cmd找到它所在的位置：如下图： 右击选择属性，选择快捷方式，再选择高级，在选择以管理员身份运行，再单击确定即可！]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置文件my.ini介绍]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6my-ini%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[my.ini是什么？my.ini是MySQL数据库中使用的配置文件，修改这个文件可以达到更新配置的目的。 my.ini存放在哪里？my.ini存放在MySql安装的根目录，如图所示： my.ini具体内容介绍12345678910111213141516# CLIENT SECTION# ----------------------------------------------------------------------## The following options will be read by MySQL client applications.# Note that only client applications shipped by MySQL are guaranteed# to read this section. If you want your own MySQL client program to# honor these values, you need to specify it as an option during the# MySQL client library initialization.#[client]port=3306[mysql]default-character-set=gb2312 上面显示的是客户端的参数，[client]和[mysql]都是客户端，下面是参数简介： 1.port参数表示的是MySQL数据库的端口，默认的端口是3306，如果你需要更改端口号的话，就可以通过在这里修改。 2.default-character-set参数是客户端默认的字符集，如果你希望它支持中文，可以设置成gbk或者utf8。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# SERVER SECTION# ----------------------------------------------------------------------## The following options will be read by the MySQL Server. Make sure that# you have installed the server correctly (see above) so it reads this # file.#[mysqld]# The TCP/IP Port the MySQL Server will listen onport=3306#Path to installation directory. All paths are usually resolved relative to this.basedir="E:/Java/Mysql/"#Path to the database rootdatadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"# The default character set that will be used when a new schema or table is# created and no character set is definedcharacter-set-server=gb2312# The default storage engine that will be used when create new tables whendefault-storage-engine=INNODB# Set the SQL mode to strictsql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"# The maximum amount of concurrent sessions the MySQL server will# allow. One of these connections will be reserved for a user with# SUPER privileges to allow the administrator to login even if the# connection limit has been reached.max_connections=100# Query cache is used to cache SELECT results and later return them# without actual executing the same query once again. Having the query# cache enabled may result in significant speed improvements, if your# have a lot of identical queries and rarely changing tables. See the# "Qcache_lowmem_prunes" status variable to check if the current value# is high enough for your load.# Note: In case your tables change very often or if your queries are# textually different every time, the query cache may result in a# slowdown instead of a performance improvement.query_cache_size=0# The number of open tables for all threads. Increasing this value# increases the number of file descriptors that mysqld requires.# Therefore you have to make sure to set the amount of open files# allowed to at least 4096 in the variable "open-files-limit" in# section [mysqld_safe]table_cache=256# Maximum size for internal (in-memory) temporary tables. If a table# grows larger than this value, it is automatically converted to disk# based table This limitation is for a single table. There can be many# of them.tmp_table_size=35M# How many threads we should keep in a cache for reuse. When a client# disconnects, the client's threads are put in the cache if there aren't# more than thread_cache_size threads from before. This greatly reduces# the amount of thread creations needed if you have a lot of new# connections. (Normally this doesn't give a notable performance# improvement if you have a good thread implementation.)thread_cache_size=8#*** MyISAM Specific options# The maximum size of the temporary file MySQL is allowed to use while# recreating the index (during REPAIR, ALTER TABLE or LOAD DATA INFILE.# If the file-size would be bigger than this, the index will be created# through the key cache (which is slower).myisam_max_sort_file_size=100G# If the temporary file used for fast index creation would be bigger# than using the key cache by the amount specified here, then prefer the# key cache method. This is mainly used to force long character keys in# large tables to use the slower key cache method to create the index.myisam_sort_buffer_size=69M# Size of the Key Buffer, used to cache index blocks for MyISAM tables.# Do not set it larger than 30% of your available memory, as some memory# is also required by the OS to cache rows. Even if you're not using# MyISAM tables, you should still set it to 8-64M as it will also be# used for internal temporary disk tables.key_buffer_size=55M# Size of the buffer used for doing full table scans of MyISAM tables.# Allocated per thread, if a full scan is needed.read_buffer_size=64Kread_rnd_buffer_size=256K# This buffer is allocated when MySQL needs to rebuild the index in# REPAIR, OPTIMZE, ALTER table statements as well as in LOAD DATA INFILE# into an empty table. It is allocated per thread so be careful with# large settings.sort_buffer_size=256K 上面是服务器断参数，以下是参数的简介： 1.port参数也是表示数据库的端口，默认3306。 2.basedir参数表示MySQL的安装路径。 3.datadir参数表示MySQL数据文件的存储位置，也是数据库表的存放位置。 4.default-character-set参数表示默认的字符集，这个字符集是服务器端的。 5.default-storage-engine参数默认的存储引擎。 6.sql-mode参数表示SQL模式的参数，通过这个参数可以设置检验SQL语句的严格程度。 7.max_connections参数表示允许同时访问MySQL服务器的最大连接数，其中一个连接是保留的，留给管理员专用的。 8.query_cache_size参数表示查询时的缓存大小，缓存中可以存储以前通过select语句查询过的信息，再次查询时就可以直接从缓存中拿出信息。 9.table_cache参数表示所有进程打开表的总数。 10.tmp_table_size参数表示内存中临时表的总数。 11.thread_cache_size参数表示保留客户端线程的缓存。 12.myisam_max_sort_file_size参数表示MySQL重建索引时所允许的最大临时文件的大小。 13.myisam_sort_buffer_size参数表示重建索引时的缓存大小。 14.key_buffer_size参数表示关键词的缓存大小。 15.read_buffer_size参数表示MyISAM表全表扫描的缓存大小。 16.read_rnd_buffer_size参数表示将排序好的数据存入该缓存中。 17.sort_buffer_size参数表示用于排序的缓存大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#*** INNODB Specific options ***# Use this option if you have a MySQL server with InnoDB support enabled# but you do not plan to use it. This will save memory and disk space# and speed up some things.#skip-innodb# Additional memory pool that is used by InnoDB to store metadata# information. If InnoDB requires more memory for this purpose it will# start to allocate it from the OS. As this is fast enough on most# recent operating systems, you normally do not need to change this# value. SHOW INNODB STATUS will display the current amount used.innodb_additional_mem_pool_size=3M# If set to 1, InnoDB will flush (fsync) the transaction logs to the# disk at each commit, which offers full ACID behavior. If you are# willing to compromise this safety, and you are running small# transactions, you may set this to 0 or 2 to reduce disk I/O to the# logs. Value 0 means that the log is only written to the log file and# the log file flushed to disk approximately once per second. Value 2# means the log is written to the log file at each commit, but the log# file is only flushed to disk approximately once per second.innodb_flush_log_at_trx_commit=1# The size of the buffer InnoDB uses for buffering log data. As soon as# it is full, InnoDB will have to flush it to disk. As it is flushed# once per second anyway, it does not make sense to have it very large# (even with long transactions).innodb_log_buffer_size=2M# InnoDB, unlike MyISAM, uses a buffer pool to cache both indexes and# row data. The bigger you set this the less disk I/O is needed to# access data in tables. On a dedicated database server you may set this# parameter up to 80% of the machine physical memory size. Do not set it# too large, though, because competition of the physical memory may# cause paging in the operating system. Note that on 32bit systems you# might be limited to 2-3.5G of user level memory per process, so do not# set it too high.innodb_buffer_pool_size=107M# Size of each log file in a log group. You should set the combined size# of log files to about 25%-100% of your buffer pool size to avoid# unneeded buffer pool flush activity on log file overwrite. However,# note that a larger logfile size will increase the time needed for the# recovery process.innodb_log_file_size=54M# Number of threads allowed inside the InnoDB kernel. The optimal value# depends highly on the application, hardware as well as the OS# scheduler properties. A too high value may lead to thread thrashing.innodb_thread_concurrency=18 上面是InnoDB存储引擎使用的参数，一下是参数的简介： 1.innodb_additional_mem_pool_size参数表示附加的内存池，用来存储InnoDB表的内容。 2.innodb_flush_log_at_trx_commit参数是设置提交日志的时机，若设置为1，InnoDB会在每次提交后将事务日志写到磁盘上。 3.innodb_log_buffer_size参数表示用来存储日志数据的缓存区的大小。 4.innodb_buffer_pool_size参数表示缓存的大小，InnoDB使用一个缓冲池类保存索引和原始数据。 5.innodb_log_file_size参数表示日志文件的大小。 6.innodb_thread_concurrency参数表示在InnoDB存储引擎允许的线程最大数。 注意：每次修改参数后，必须重新启动MySQL服务才会有效。操作如下： 12net stop mysql80net start mysql80]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL客户端与服务器连接过程]]></title>
    <url>%2F2020%2F03%2F09%2FMySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 我们现在已经知道如何启动MySQL的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！ ​ TCP/IP是客户端和服务器之间最常用的通信方式。真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。MySQL采用TCP作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程有需要采用TCP协议进行网络通信方面的需求，可以向操作系统申请一个端口号，这是一个整数值，它的取值范围是0~65535。这样在网络中的其他进程就可以通过IP地址 + 端口号的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。 ​ MySQL服务器启动的时候会默认申请3306端口号，之后就在这个端口上等待客户端进程进行连接。用书面一点的话来说，MySQL服务器会默认监听3306端口。 ​ 如果3306端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加-P参数来明确指定一下端口号，比如这样： 1mysqld -P3307 如果采用windows服务打开MySQL服务器，则需要修改配置文件my.ini中的默认端口号。这样MySQL服务器在启动时就会去监听我们指定的端口号3307。这里要注意，服务器的端口号和客户端的端口号一定要保持一致，这样才能保证它两能顺利建立TCP/IP连接 ​ 如果客户端进程想要使用TCP/IP网络来连接到服务器进程，比如我们在使用mysql来启动客户端程序时，在-h参数后必须跟随IP地址来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用127.0.0.1来代表本机的IP地址。另外，如果服务器进程监听的端口号不是默认的3306，我们也可以在使用mysql启动客户端程序时使用-P参数（大写的P，小写的p是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写： 1mysql -h127.0.0.1 -uroot -P3307 -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站导航]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%85%A8%E7%AB%99%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到本学习交流网站，为了便于自己日后复习查看，特此设置全站导航。 MySQL一、MySQL基础知识 MySQL客户端与服务器连接过程 数据库基本操作 MySQL表的基本操作 MySQL数据类型 列的属性 MySQL之查询、去重、限制条数、排序 MySQL之带条件的查询 MySQL之使用通配符进行模糊查询 隐式类型转换 表达式与函数 SQL查询语句的定义顺序和执行顺序 二、MySQL配置问题 MySQL初始化与启动 MySQL配置文件my.ini介绍 三、MySQL注意事项与问题 MySQL密码错误如何修改 MySQL语句使用注意事项 MySQL常见问题汇总 算法机器学习算法 决策树 Java一、Java基础知识 Java入门（含Java基本介绍、数据类型、流程控制和数组操作） JDK和JRE间的那些事儿 Java环境变量那些事儿 彻底弄懂Unicode编码那些事儿 源文件名和类名的关系 Java的加载与执行 Java命令行参数 Java面向对象编程（类、继承、多态、抽象类、接口） 对象的创建与使用-内存分析 方法执行内存分析 面向对象封装性 方法调用时的参数传递问题 二、 JVM相关 从JVM角度看Java多态 class文件反汇编 Hexo 利用Hexo搭建个人博客 Hexo博客如何迁移至其它电脑]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java入门（含Java基本介绍、数据类型、流程控制和数组操作）]]></title>
    <url>%2F2020%2F02%2F06%2FJava%E5%85%A5%E9%97%A8%EF%BC%88%E5%90%ABJava%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Java介绍​ Java是目前全球Top 1的程序开发语言，是SUN公司James Gosling为手持设备开发的嵌入式编程语言，原名Oak，1995年改名为Java正式推出，有最大的开发社区；目前广泛应用于企业和互联网后端开发、Android开发和大数据开发。 1.1 Java的特点 一种面向对象的跨平台编程语言，语法比C++简单 以字节码的形式运行在虚拟机上 自带功能齐全的类库 有非常活跃的开源社区支持 1.2 Java的优缺点优点： 简单(语法比C++简单)、健壮(垃圾收集器让内存管理更容易)、安全(字节码运行在虚拟机上，无法操作硬件，因此安全) 跨平台，一次编写，到处运行 高度优化的虚拟机 缺点： 语法比较繁琐 无法直接操作硬件(不适用于底层操作系统的开发) GUI效果不佳(不适用于桌面应用程序的开发) 1.3 Java语言特性(开源、免费、纯面向对象、跨平台) 简单性 相对而言的，例如Java中不再支持多继承，C++是支持多继承的，多继承比较复杂。C++中右指针，Java中屏蔽了指针的概念。Java语言底层是C++实现的，不是C语言。 面向对象 可移植性（跨平台） 一次编译，到处运行 多线程 健壮性 和自动垃圾回收机制有关，自动垃圾回收机制简称GC机制。Java语言运行产生的垃圾是自动回收的，不需要程序员惯性 安全性 1.4 Java的版本 Java SE: Standard Edition(标准版) Java EE: Enterprise Edition(企业版) Java ME: Micro Edition(移动版) 1.5 Java的规范什么是规范？ ​ 比如USB就是一个规范，它规定了电源的正负极、信号线等等 ​ Java的规范是Java Specification Request，简称JSR。有个组织Java Community Process(JCP)，它负责维护JSR规范。 1.6 Java平台​ Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“一次编译，到处执行”（Compile once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。 Java平台实际上就是运行在各种操作系统上的JVM(虚拟机) JDK和JRE的区别 JRE（Java Runtime Environment）是Java运行时环境。它是运行编译后的Java程序所需的一切包，包括Java虚拟机JVM、Java类库（都是class文件，在lib目录下打包成了jar）、Java命令和其它基础设施。但是，它不能用于创建新程序。总而言之是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的，而不是面向开发者的。 JDK（Java Development Kit）顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。它拥有JRE所拥有的一切，但也有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 举个例子：程序员在本地开发时需要安装JDK。但将开发好的程序部署到客户端时，只需要在客户端安装JRE即可，无需再安装JDK。 1.7 Java为什么可以跨平台运行？Windows操作系统内核和Linux操作系统内核肯定不同，它们执行指令的方式也不同。因此Java程序不能直接和操作系统打交道，因为Java程序只有一份，操作系统执行原理却不同。 Sun团队让Java程序运行在一台虚拟机上，简称JVM（可认为是Java程序和操作系统之间的介质，屏蔽操作系统的差异）。JVM再和底层的操作系统打交道。 ​ ​ 1.首先开发好的java文件经过编译器Compiler的编译变为.class文件（字节码文件，非二进制文件），然而这个.class文件并不是真正的本地可以执行的指令 我们可以把这个.class文件称之为“中间码” ​ 2.不同的计算机操作系统有着相应的JVM 比如win32位的、win64位的、linux系统的，.class文件经过Interpreter（解释器，也就是JVM）的解释（或者称之为翻译），变为真正的本地可执行指令（“00101001001…”） 总结：“一处编译，到处运行”是因为程序的中间码.class文件是标准的，一致的，在各个系统对应的JVM上都可以被识别解释然后运行，所以可以实现跨平台 1.8 Java安装 上官网下载对应版本的JDK 官网网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 不更改安装路径，直接安装在C盘 配置JDK环境变量，将C:\ProgramFiles\Java\jdk\bin添加到系统path变量中。打开cmd，输入“javac -version”，如果出现版本号，即代表配置完成 2. Java程序基础2.1 Java程序基本结构标识符：在java源程序中凡是程序员有权利自己命名的单词都是标识符。标识符可以标识：类名、方法名、变量名、接口名、常量名等，且严格区分大小写，不能用关键字 标识符命名规范（驼峰）： 类名、接口名：首字母大写，后面每个单词首字母大写 变量名、方法名：首字母小写，后面每个单词首字母大写 常量名：全部大写 Java的基本程序结构如下： 123456789101112/** * 可用来自动创建文档注释 */public class Hello &#123; public static void main(String[] args)&#123; //程序入口 System.out.pringln("Hello world"); /* 多行注释 注释内容 注释结束 */ &#125;&#125; //class定义结束 ​ 类名必须是英文字母、数字、下划线和美元符号$的组合；类名不能以数字开头；不能用关键字作为类名 ​ Java有三种注释（注释是解释说明作用，增加可读性，不会被编译到字节码文件中）： 单行注释：以双斜线//开头，到当前行尾 多行注释：以/ … /表示，中间所有内容都被视为注释 javadoc注释：写在类和方法定义处，可用于自动创建文档。 1234/*** javadoc注释**/ javadoc注释可以被javadoc.exe提取解析生成帮助文档 2.2 变量什么是变量？ 变量本质上是内存中的一块空间，这块空间有数据类型、名字和字面值（数据）。变量是内存中存储数据的最基本的单元。 数据类型的作用？ 不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间。数据类型是知道程序在运行阶段应该分配多大的内存空间 有了变量的概念后，内存空间得到了重复使用 12345678// 下面两个100是不同的内存空间System.out.println(100);System.out.println(100);// 引入变量，可访问同一块内存空间int i = 100;System.out.println(i);System.out.println(i); 123456public class Hello &#123; public static void main(String[] args)&#123; int n = 100; //基本类型 String s = "Hello,world"; //对象 &#125;&#125; 变量可以持有某个基本类型的数值，或者指向某个对象 定义变量 1变量类型 变量名; 变量可被重新赋值 在同一个作用域中，变量名不能重名（但不同作用域下可以重名，比如局部变量和成员变量，且局部变量屏蔽成员变量），但可以重新赋值 Java用一对大括号作为语句块的范围，称为作用域，作为在作用域里定义的一个变量，它只有在哪个作用域结束之前才可使用。 下面举个容易错的例子 123456789101112131415// 报错public static void main(String[] args)&#123; String name = "l"; &#123; String name = "x"; &#125;&#125;// 没有报错public static void main(String[] args)&#123; &#123; String name = "l"; &#125; String name = "x";&#125; 为什么第一段代码报错了，而第二段代码没有报错？ ​ 因为第二种离开作用域，变量所分配的内存空间将被JVM回收，所以语法不会有错误，而第一种写法name并没有离开{}作用域，所以会语法错误。 变量必须被定义赋值才能访问，两种方式赋值： 变量名 = 字面值； 变量类型 变量名 = 字面值; （初始化） 123456public class hello&#123; public static void main(String[] args)&#123; int i; System.out.println(i); //报错，因为没有赋值 &#125;&#125; 变量的分类： 根据变量声明的位置类分类 局部变量：在方法体当中声明的变量叫局部变量 成员变量：在方法体外（类体内）声明的变量叫成员变量 成员变量没有手动赋值，系统会默认赋值。而局部变量不会，如果没有赋值就访问，会报错。八种数据类型默认值： byte、short、int、long：0 float、double：0.0 boolean：false char：‘\u0000’ 引用数据类型：null 2.3 数据类型数据类型的作用 程序当中有很多数据，每一个数据都是有相关类型的，不同数据类型的数据占用空间大小不同。数据类型的作用是指导JVM在运行程序时给该数据分配多大的内存空间 Java数据类型分两种： 基本数据类型（4大类8小种） 引用数据类型 2.4 基本数据类型 整数类型：long、int、short、byte 浮点类型：double、float 布尔类型：boolean 字符类型：char 计算机内存的最小存储单元是字节（byte），一个字节时8位二进制数：00000000 ~ 11111111（0 ~ 255）。内存单元从0开始编号，称为内存地址。 2.4.1 整形 byte：8位，1字节 short：16位，2字节 int：32位，4字节 long：64位，8字节 Java语言当中的”整数型字面值”默认是int型，要让这个字面值被当做是long型，需要在后面加L Java语言中的整数型字面值有三种表示方式 十进制，是一种缺省 默认的方式 1int a = 10; 八进制，需要以0开始 1int b = 010; // 8 十六进制，需要以0x开始 1int c = 0x10; // 16 123456789byte b = 127; //byte范围：-128 ~ 127short s = 32767; //short范围：-32768 ~ 32767int i = 2147483647;int i2 = -2147483648;int i3 = 2_000_000_000; //加下划线更容易识别int i4 = 0xff0000; //16进制表示的16711680int i5 = 0b1000000000; //2进制表示的512// 同一个数的不同进制表示完全相同long l = 9000000000000000000L; //由于java默认类型为int，因此需要在结尾加L 有个小问题，java默认整数都是int型。按理说int型是不能赋值给short、byte、char类型的，但是下面却可以编译通过。这是为什么？在java中10这个常量到底是怎么存放的呢？ 123short a = 10;byte b = 10;char c = 10; 因为在Java中规定所有整数默认是int型。但是只要在byte，short、char它们的取值范围内赋值都是可以的，比如byte=127 就是可以的，但是你给byte=128 就不行了，因为就超出byte 127 的最大范围了。char=数字并不代表那是一个数字，char赋值整数代表的是它背后的字符，因为每一个字符给它硬性对应一个整数值 2.4.2 浮点类型 float：32位，4字节 double：64位，8字节 在java语言当中，所有浮点型字面值默认被当做double类型来处理。要想该字面值被当做float类型来处理，需在字面值后面添加F/f。 1234float f1 = 3.14f; // Java浮点数默认为double类型，float类型需在结尾加ffloat f2 = 3.14e38f; // 科学计数法表示的3.14*10^38double d = 1.79e308;double d1 = 4.9e-324; // 4.9*10^(-324) double的精度太低（相对来说），不适合做财务软件。财务涉及到钱的问题，要求精度较高。所以SUN公司在基础SE类库中为程序员准备了精度更高的类型，只不过这种类型是一种引用数据类型，不属于基本数据类型，它是java.math.BigDecimal（定点数） 2.4.3 布尔类型只有true和false两个值，通常是计算结果，占用1个字节 不可以0或非 0 的整数替代false和true，这点和C语言不同 1boolean flag = 1; // 编译错误，不兼容的类型 boolean类型不可以转换为其它的数据类型 2.4.4 字符类型char：保存一个字符，用单引号表示，占用2个字节，取值范围是 0 ~ 65535。如果输入多个字符编译器将会报错。注意区分字符类型和字符串类型的区别。 123char c1 = 'A';// 或 char c1 = '\u0041';char c2 = '中'; short和char所表示的种类总数是一样的，只不过char可以表示更大的正整数，因为char没有负数 char类型表示的是现实世界中的文字，文字和计算机二进制之间默认情况下不存在转换关系。为了让计算机可以表示现实世界中的文字，我们需要人为干涉，需要人提前制定好文字和二进制之间的对照关系，这种对照关系被称为：字符编码。计算机最初只支持英文，最先出现的字符编码是ASCII码： ‘a’ —&gt; 97 ‘A’ —&gt; 65 ‘0’ —&gt; 48 ASCII码共定义了128个字符，因此用一个字节即可完全表示 编码和解码采用同一套编码集，不会出现乱码。否则会出现乱码 随着计算机的发展，后来出现了一种编码方式，是国际化标准组织ISO制定的，这种编码方式支持西欧语言，向上兼容ASCII码，仍然不支持中文。这种编码方式是：ISO-8859-1，又被称为latin-1 随着计算机向亚洲发展，计算机开始支持中文、日文、韩文等，其中支持简体中文的编码方式：GB2312、GBK、GB18030（容量从小到大，即支持的中文字符数量从小到大） 支持繁体中文：大五码（big5） 后来出现了一种编码方式统一了全球所有的文字，容量较大，这种编码方式叫做unicode编码。unicode编码方式有多种具体的实现：UTF-8、UTF-16、UTF-32等 Java语言源代码采用unicode编码方式，所以标识符可以写中文 Java中用两个字节表示char，在char中存储的是字符的Unicode码点，char只能表示 BMP子符（BMP的定义见另一篇文章：彻底弄懂Unicode编码那些事儿）。 这里我也疑惑很久Java是如何表示单个的补充码字符（即SMP中的字符），后来明白Java给出的方式就是 “表示不了” ，这样也很合理，65536个字符几乎已经涵盖世界主流语言用到的所有字符了，没必要为了极少出现的字符而构建一个复杂的char类型。 Java中的char本质上是UTF-16编码。而UTF-16实际上也是一个变长编码（2字节或4字节）。如果一个抽象的字符在UTF-16编码下占4字节，显然它是不能放到char中的。换言之，char中只能放UTF-16编码下只占2字节的那些字符，即BMP中的字符。 转义字符反斜杠 \ 在 Java语言中具有转义功能，转义字符出现在特殊字符前，会将特殊字符转义成普通字符 \n：换行符 \t：制表符（Table键，与空格不同） \\\\：反斜杠字符（’\\’这种会报错，因为\有转义功能，会与后面的单引号配对成转义字符，因此前面的单引号没人与它配对） \\’：单引号字符（’’’会报错，原因类似上面，后面两个单引号会配对） \\”：双引号字符。这里需要注意一点 \u####：代表后面的一串是一个字符的Unicode编码 12345System.out.println("\"Helloworld\""); //输出:"Helloworld"//System.out.println(""Helloworld""); //报错// 因此在字符串中表示双引号需要加反斜杠char c = '"'; // 代表双引号，无需加反斜杠，因为没人跟他配对，这里需要多注意 2.5 数据类型转换关于基本数据类型之间的互相转换，转换规则如下： 8种基本数据类型当中除boolean类型外，剩下的7种类型之间都可以互相转换 小容量可直接向大容量转换，称为自动类型转换。容量从小到大排序： byte &lt; short/char &lt; int &lt; long &lt; float &lt; double 注意：任何浮点类型不管占用多少字节，都比整数类型容量大。char和short容量相同。 123int a = 100;long b = a;long c = 10; 大容量不能直接转换为小容量，需要加强制类型转换符，称为强制类型转换。但是在运行阶段可能会损失精度，所以谨慎使用。强转原理：将左边的二进制位砍掉 123long a = 100L;// int b = a; // 编译错误int b = (int)a; //编译正确 当整数字面值没有超过byte、short、char的取值范围，可以直接赋值给byte、short和char类型的变量。但整型变量不能直接赋值给short、byte和char变量，也需要强制类型转换符 1234567// byte a = 1000; // 错误，因为1000超出了byte的范围byte a = 20; // 正确，因为20没有超出byte范围/*int r = 20;short t = r; // 编译错误short t = (short)r; // 编译正确*/ byte、short和char类型混合运算的时候，各自先转换成int类型再做运算 1234byte i = 5;short j = 10;//short k = i + j; //编译错误，short和byte运算，首先会转换成int再运算，所以i+j运算结果为int，int赋值给short就会出错short k = (short)(i+j); // 编译正确 多种数据类型混合运算时，先转换成容量最大的那种类型再做运算 当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。 2.6 常量常量就是用final修饰的变量： 常量初始化后不可再次赋值 常量名通常全部大写 常量用来避免意外赋值 常量用来替代Magic Number：魔数导致代码可读性差，修改不方便的问题。 12345678// 常量的好处就是如果需要更改常量的值，只需在定义处修改final double PI = 3.14;double r = 4.0;double area = PI*r*r;//magic number:增加可读性，后续能看懂final double tax_rate = 0.2;double pay = 1-tax_rate; 2.7 基本类型和引用类型Java提供了两种变量类型：基本类型和引用类型。 基本类型：byte、short、int、long、float、double、char、boolean 引用类型：String、类、接口类型、数组类型、枚举类型、注解类型 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。 基本类型的变量是”持有”某个数值，引用类型的变量是”指向“某个对象 注意：栈存放的是基本数据类型(基本数据类型包括：int、short、double、long、float、boolean、char、byte；注意没有String)以及对象的引用。栈还有一个很大的特点就是栈中的数据可以共享。比如定义两个int类型的变量：int a = 3; int b = 3;这里a和b是一个指向int型的引用，指向”3”这个字面值。编译器先处理int a = 3;这句语句的时候，先在栈中创建一个变量为a的引用，然后查找有没字面值为3的地址，如果没有就开辟出一个存储3的地址，然后将a指向这个3对应的地址。接着处理int b = 3;，也是先创建一个变量b的引用，由于栈中已经有字面量3了，于是就把b也指向3对应的这个地址，所以a和b都指向了一个地址。当我们执行 b = 4;的时候，首先还是去栈中查找有没字面量值为4对应的地址，如果没有就开辟个，然后将b指向这个新开辟的地址。如果已经有了就直接将b指向这个地址，此时a还是指向3，但b指向4了，而且他俩不再指向同一个地址了。当声明基本类型变量时，变量名和字面值（变量名和字面值是两个概念）均放在栈中，变量名指向字面值。 2.8 引用类型Java的引用与C++的指针在原理上是相类似的，但Java没有指针，只有引用。 简单的说，引用其实就像是一个对象的名字或者别名 (alias)，一个对象在内存中会请求一块空间来保存数据，根据对象的大小，它可能需要占用的空间大小也不等。访问对象的时候，我们不会直接是访问对象在内存中的数据，而是通过引用去访问。引用也是一种数据类型，我们可以把它想象为类似 C++ 语言中指针的东西，它指示了对象在内存中的地址——只不过我们不能够观察到这个地址究竟是什么。 如果我们定义了不止一个引用指向同一个对象，那么这些引用是不相同的，因为引用也是一种数据类型，需要一定的内存空间（stack，栈空间）来保存。但是它们的值是相同的，都指示同一个对象在内存（heap，堆空间）的中位置。 123String a = "hello";String b = a;//表示a和b是两个不同的引用，但它们的值是一样的，都指向同一个对象"hello" 总结： 引用是一种数据类型（保存在stack中），保存了对象在内存（heap，堆空间）中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)； 不同的引用可能指向同一个对象，换句话说，一个对象可以有多个引用，即该类类型的变量。 2.9 整数运算计算机数字运算均是基于补码的。 运算规则： 基本四则运算法则 除法结果为整数 除数为0时，运行将报错 ++运算和—运算 123int s = 100;System.out.println(s++); // 100System.out.println(s); // 101 +=运算、-=运算、*=运算、/=运算、%=运算 先执行等号右边的表达式，将执行结果赋值给左边的变量 1234567byte b = 10;// b = b+5; // 编译错误，因为b+5将转为int变量b += 5; // 编译正确，等同于 b = (byte)(b+5);byte i =0;i += 128; // 最终i的结果是-128，因为进行强制类型转换 所以这5种赋值运算符默认会进行强制类型转换，不改变运算结果类型。假设最初这个变量的类型时byte类型，无论怎么进行追加或追减，最终该变量的数据类型还是byte类型 取余运算% 注意：运算符有优先级，不确定的加小括号()，优先级得到提升 Java源码中经常会使用移位运算来代替乘除运算，因为移位运算的性能比乘除运算的高（PS：对于计算机而言，移位运算只是移了个位置），所以了解移位运算的计算过程对于我们阅读源码会有一定的帮助。 原码：第一位表示符号, 其余位表示值 反码：正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。通常上述这种解释谁也看不懂，下面介绍一种别的说法。举一个生活中的例子来说明这个问题： 如果说现在时针现在停在10点钟，那么什么时候时针会停在八点钟呢？简单，过去隔两个小时的时候，是八点钟。未来过十个小时的时候也是八点钟。也就是说时间正拨10小时，或是倒拨2小时都是八点钟。也就是10-2=8，而10+10=8（10+10=10+2+8=12+8=8）这个时候满12说明时针在走第二圈了，又走了8小时，所以时针正好又停在八点钟。也就是说， 10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。既然是等效的，那在时钟运算中，减去一个数，其实就相当于加上另外一个数（这个数与减数相加正好等于12）。这里12被称为模，本质上是将溢出的部分舍去而不改变结果。易得，单字节(8位)运算的模为256=2^8。故可以得到以下结论： 负数的补码为模减去该数的绝对值的二进制。 如-5的补码为： -5=256-5=251=1111 1011(二进制，此时不考虑符号位，单纯二进制表示) 同样的，临界值-128也可以表示出来： -128=256-128=128=1000 0000(二进制) 计算负数补码当然可以用上面的方法，也可以用下面我们介绍的小技巧，口算就能算出负数补码 计算负数补码的小技巧：首先记住该数的数据类型字节大小对应的负数补码原点。例如对于4位，-8是补码远点；对于8位，负数补码原点是-128；十六位可以把-32768当补码原点。负数补码原点总是最高位是1，其他位是0 如果我们把-8当成负数的原点。那么-5的补码是多少呢？ -5 = -8 + 3 1000（-8） +0011（3）=1011(-5) 所以可口算出-5的补码是1011 移位运算（3种）： 左移&lt;&lt;：丢弃左边指定位数，右边补0 带符号右移&gt;&gt;：丢弃右边指定位数，左边补上符号位 不带符号右移&gt;&gt;&gt;：丢弃右边指定位数，左边补上0 byte和short会先转换为int再进行移位 结论：对于机器而言，java中的移位运算都是对补码执行移位运算的，下面以-1&lt;&lt;1=-2为例进行讲解: -1的原码：10000000 00000000 00000000 00000001 -1的反码：11111111 11111111 11111111 11111110 -1的补码：11111111 11111111 11111111 11111111 执行移位操作 -1移位后的补码：11111111 11111111 11111111 11111110 -1移位后的反码：11111111 11111111 11111111 11111101 -1移位后的原码：10000000 00000000 00000000 00000010 得到最后的原码十进制值为-2 举例如下： 12345int n1 = 5;int n2 = n1&lt;&lt;10; //5120int n3 = n2&gt;&gt;11; //2int n4 = n1&lt;&lt;29; //-1610612736int n5 = n4&gt;&gt;29; //-3 类型自动提升与强制转型 在运算过程中，计算结果为较大类型的整型 12short s = 12;int i = 100+s; //100为int型，计算结果自动转为int型 较大类型的整数不能直接赋值给一个较小类型的整数，相反较小类型的整数能直接赋值给较大类型的整数 12long a = 100L;int b = a; //编译错误 可将结果强制转型 123(类型)变量或数值long a = 100L;int b = (int)a; 强制转型可能会丢失精度，因为int是32位，long是64位，所以如果数值大于32位会损失精度 2.10 浮点数运算浮点数运算的特点： 很多浮点数无法精确表示(详情可见另一篇博客：MySQL数据类型) 计算有误差，因为浮点数无法精确表示 1double b = 1-9.0/10; //0.09999999999999998 计算时如果浮点数和整数进行运算，整型可以自动提升为浮点型 浮点数运算特殊值（三种）： 1double d1 = 0.0/0; //NAN，不报错 1double d2 1.0/0; //Infinity 1double d3 = -1.0/0; //Infinity 强制转型 强制转为整型会直接扔掉小数位 12int n1 = (int)12.3; //12int n2 = (int)12.7; //12 四舍五入的技巧 1int n3 = (int)(12.7+0.5); 超出整型范围自动变为最大值 1int n4 = (int)1.2e20; //2147483647 2.11 布尔运算 关系运算符：&gt; , &gt;= , &lt; , &lt;= , == , != 关系运算符的运算结果一定是boolean类型，true or false 逻辑运算符 &amp;：逻辑与（两边的算子都是true，结果才是true） |：逻辑或（两边的算子只要有一个是true，结果就是true） ^：逻辑异或（两边的算子结果不一样，结果就是true） 逻辑非：！（取反，！false是true，！true是false） 短路与运算：&amp;&amp;（运算结果与&amp;完全相同，只不过这个有短路） 短路或运算：||运算结果与|完全相同，只不过这个有短路） 逻辑运算符要求两边的算子都是boolean类型，并且逻辑运算符的最终结果也是一个boolean类型 短路运算符： 与运算&amp;&amp;：与运算中，如果有任何一个表达式的计算结果为false，则后面的表达式将不再计算 或运算||：或运算中，如果有任何一个表达式的计算结果为true，则后面的表达式将不再计算 三元运算符：b ? x : y 语法规则：布尔表达式 ？ 表示式1 ： 表达式2 根据条件b计算x或y，b为true计算x，b为false计算y x和y只计算其中一个 x和y类型必须相同 2.12 字符和字符串 字符类型是基本数据类型，保存一个字符。Java使用Unicode编码，因此可将字符类型直接赋值给一个int类型。还可直接用Unicode编码表示字符类型： 12// '\u####',4位16进制char c = '\u0041'; //'A' 字符串类型不是一个基本类型，是引用类型。String保存一个字符串。 1String s = "ABC"; 字符串连接用+，可以连接字符串和其它数据类型 12String s = "hello" + "world";String a = "age is" + 12; 因为字符串类型是引用类型，所以字符串不可变，只能改变其引用指向的对象。 所有的引用类型可以指向空值null，表示不指向任何对象。空值null和空字符串””是不一样的，注意区分。 1String s = null; 2.13 数组类型当有一组类型相同的变量时，可以用数组表示： 数组类型是：类型[] 数组初始化用new int[数组长度] 数组所有元素初始化为默认值 数组创建后大小不可改变 数组索引从0开始 12345678910public class hello&#123; public static void main(String[] args)&#123; int[] ns = new int[5]; ns[0] = 1; ns[1] = 2; ns[2] = 3; ns[3] = 4; ns[4] = 5; &#125;&#125; 用数组变量.length获取数组大小 12int[] ns = new int[5];System.out.println(ns.length); 数组变量是引用类型 可以指定初始化的元素，由编译器自动推算数组大小 123int[] ns = new int[] &#123;1,2,3,4,5&#125;;//可进一步简写int[] ns = &#123;1,2,3,4,5&#125;; 数组变量是引用类型，数组大小不可变，可指向不同的数组对象 数组元素是值类型（如int[]）或引用类型（如String[]） 3. 流程控制3.1 输入和输出输出： 输出并换行 1System.out.println() 输出但不换行 1System.out.print() 输入: 导入java.util.Scanner 创建Scanner并传入System.in 使用scanner.nextLine()读字符串 使用scanner.nextInt()读Int整数 使用scanner.nextDouble()读长整型 …… 1234567891011import java.util.Scanner;public class hello&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("Input your name:"); String name = scanner.nextLine(); System.out.println("Input your age:"); int age = scanner.nextInt(); &#125;&#125; 格式化输出： 格式化输出使用System.out.printf() 使用占位符%### 1System.out.printf("%s is %d years old\n","Bob",12); 常用占位符： 占位符 含义 %d 整数 %x 十六进制整数 %f 浮点数 %s 字符串 %% 百分号字符本身 %e 科学计数法表示浮点数 %c 字符 %b 布尔值 12345678public class hello&#123; public static void main(String[] args)&#123; double d = 3.1415926; System.out.println(d); System.out.printf("PI = %.2f\n",d); System.out.printf("PI = %7.2f\n",d); &#125;&#125; 运行结果如下： 1233.1415926PI = 3.14PI = 3.14 //3前面补充了三个空格 格式标识符解释 %7.2f： 7为域宽度.输出的浮点数条目宽度至少为7,包括小数点和小数点后两位数字.这样,给小数点前分配了4位数字.如果该条目小数点前的位数小于4,就在数字前面加空格.如果该条目小数点前的位数大于4,则自动增加宽度. 2为精度().即想要输出的小数点的长度. f为转换码 指定宽度和精度的例子 举例 输出 %5c 输出字符并在这个字符条目前面加4个空格 %6b 输出字符并在这个字符条目前面加4个空格 %5d 输出整个条目,宽度至少为5.如果该条目的数字位数小于5,就在数字前面加空格.如果该条目的位数大于5,则自动增加宽度 %10.2f 输出的浮点条目宽度至少为10,包括小数点、和小数点后两位数字.这样,给小数点前分配了7位数字. 如果该条目小数点前的位数小于7,就在数字前面加空格. 如果该条目小数点前的位数大于7,则自动增加宽度. %10.2e 输出的浮点条目的宽度至少为10,包括小数点、小数点后面两位数字和指数部分(包括e、正负号和指数数字).如果按科学计数法显示的数字位数小于10,就给数字前加空格 %12s 输出的字符串至少为12个字符.如果该字符串条目小于12个字符,就在该字符串前加空格.如果该字符串条目多余12个字符,则自动增加宽度 注意的问题： 默认情况下,输出是右对齐的（即如果宽度不够，在左边补齐空格）.可以在格式标识符中放一个符号(-),表明该条目在特定区域中的输出是左对齐的. 123456System.out.printf("%8.4f",1.12);System.out.printf("%-8.4f",1.12);// 输出 1.12001.1200 使用符号%来标记格式标识符,要在格式字符串里输出直接量%,需要使用%% 如果在补齐时不希望以空格进行补齐，而希望以0进行补齐，如下所示： 1234System.out.printf("PI = %08d\n",1234);// 输出00001234 如果想显示符号位，如下所示： 1234System.out.printf("PI = %+8d\n",1234);// 无论正负都可以用上述形式显示符号位// 输出 +1234 //符号也占一位 如何控制输出顺序 1234567// #$表示第几个变量System.out.printf("%2$d, %1$d",13,14);System.out.printf("%2$s, %1$s","a","b");// 输出14, 13b, a 3.2 引用类型判断是否相等 判断两个引用是否指向堆中的同一个实例，用”==” 123String a = "hello";String b = "world";Sytsem.out.println(a==b); 判断两个引用指向的实例是否相等，用equals。如果变量为null，调用equals()会报错，利用短路运算符&amp;&amp;解决。 1234String a = "hello";String b = "world";if(a!=null &amp;&amp; a.equals(b)) System.out.println("yes"); 3.3 if语句语法结构：四种编写方式 if(布尔表达式){java语句} if(布尔表达式){java语句} else{java语句} if(布尔表达式){java语句} elseif(布尔表达式){java语句} else if{java语句} … if(布尔表达式){java语句} elseif(布尔表达式){java语句} else if{java语句} else{java语句} if语句最多只能执行一个分支（0个或1个） 以上的第二种和第四种方式都带有else分支，这两种方式可以保证会有一条分支执行。第一种和第三种可能一个分支也不执行 可以嵌套使用 if语句分支中只有一条java语句，大括号可以省略，不推荐 3.4 Switch语句1234567891011121314int opt = 2;switch(opt)&#123; case 1: System.out.println("1"); break; case 2: System.out.println("2"); break; case 3: System.out.println("3"); break; default: System.out.println("none");&#125; switch后面的括号里只能写int或string类型的字面值或变量 注意case语句没有{} case语句具有”穿透性“，如果不加break会导致意想不到的结果。当opt=2，如果不写break导致case2、case3和default顺序执行（case3和default不用管是否匹配） 如果都没有匹配，则执行default switch和case后面的计算结果必须是整形、字符串（字符串比较内容相等）。从JDK7开始，byte、short和char也可以，因为可以自动类型转换 case可以合并 12345int i = 1;switch(i)&#123; case 1: case2: case3: // i=1、2、3都可以执行下述语句 System.out.println("Test");&#125; 如何避免漏写break和default？ 打开eclipse中的窗口-&gt;首选项 Java-&gt;编译器-&gt;错误/警告-&gt;可能的编程问题，将”switch缺少default语句”和”switch case跳转”修改为警告： 这样以后如果忘了写break或default时会有警告 3.5 While循环 while循环首先判断条件 条件满足时循环 条件不满足时退出 可能一次都不循环 注意逻辑，避免无限死循环 123456int sum = 0;int n = 1;while(n&lt;10)&#123; sum = sum+n; n++;&#125; 3.6 do-while循环 do-while先执行循环，再判断条件 条件满足时继续循环 条件不满足时退出 至少循环一次 123456int sum = 0;int n = 1;do&#123; sum += n; n++;&#125; while(n&lt;10); 3.7 for循环for循环分别设置： 计数器初始值 循环前检测条件 每次循环后如何更新计数器 1234int[] ns = &#123;1,2,3,4,5&#125;;for(int i=0;i&lt;ns.length;i++)&#123; System.out.println(ns[i]);&#125; for里面的三个语句可以都没有 当嵌套for循环时，内层循环和外层循环的变量不能重名 初始化计数器总是被执行 可能循环0次 for each循环 1234int[] ns = &#123;1,2,3,4,5&#125;;for(n:ns)&#123; System.out.println(n);&#125; for each循环可以更简单的遍历数组 for each循环能够遍历数组和”可迭代”数据类型，包括List、Map等 for each循环无法指定遍历顺序 for each循环无法获取数组索引，因此无法同时遍历多个数组。只能通过for循环 12345int[] ns1 = &#123;1,2,3,4,5&#125;;int[] ns2 = &#123;6,7,8,9,10&#125;;for(int i=0;i&lt;ns1.length;i++)&#123; ns2[i] = ns1[i]*ns1[i];&#125; 3.8 break和continue在循环中，可以使用break语句和continue语句。 break跳出循环 循环过程中，可以使用break语句跳出循环 如果有多层循环嵌套，break语句总是跳出最近的一层循环。 break通常配合if，在满足条件时提前结束循环 continue提前结束当前循环 continue可提前结束本轮循环，直接继续下次循环 continue通常配合if，在满足条件时提前结束本轮循环 数组操作遍历数组 for循环可以遍历数组 for(;;)循环通过下标遍历数组 for each循环直接遍历数组元素 直接打印数组变量，得到的是数组在JVM中的引用地址。for each循环打印也很麻烦。Arrays.toString()可以快速打印数组内容 1234import java.util.Arrays;int[] ns = &#123;1,1,2,3,5,8&#125;;System.out.println(Arrays.toString(ns)); 数组排序有两种方法： 自己写排序算法，比如冒泡排序、快排等 使用JDK的Arrays.sort()排序。使用ctrl+鼠标左键可以快速查看JDK源码 12345import java.util.Arrays;int[] ns = &#123;28,12,89,73,65&#125;;Arrays.sort(ns);System.out.println(Arrays.toString(ns)); 对数组排序修改了数组本身 多维数组二维数组 二维数组就是数组的数组 12345int[][] ns = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;; 二维数组的内存空间分配如图所示： 数组变量分配在栈内存中，其指向一个三维数组，该三维分配在堆内存上。每一维数组元素由指向一个一维数组，同样分配在堆内存上。 访问二维数组元素使用array[rows] [cols] 二维数组每个数组元素长度不要求相同 三维数组与二维数组类似，内存分配如图所示 123456789101112131415int[][][] ns = &#123; &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;, &#123; &#123;10,11&#125;, &#123;12,13&#125; &#125;, &#123; &#123;14,15,16&#125;, &#123;17,18&#125; &#125;&#125;; 其余多维数组类似]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL表的基本操作]]></title>
    <url>%2F2019%2F11%2F13%2FMySQL%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ 创建表的时候首先需要描述清楚这个表是什么样的，它有哪些列，这些列都是用来存什么类型的数据等等。表中的一行叫做一条记录，一列就做一个字段。 展示当前数据库的表​ 下面的语句用于展示当前数据库中有哪些表： 1mysql&gt; SHOW TABLES; 创建表1、基本语法创建一个表时至少需要完成下列事情： （1）给表起个名 （2）给表定义一些列，并且给这些列都起个名 （3）每个列都需要定义一种数据类型 （4）如果有需要的话，可以给这些列定义一些列的属性，比如不许存储NULL，设置默认值等，具体列可以设置哪些属性可以在后面再详细说一下 创建表的基本语法如下： 123456CREATE TABLE 表名( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性],); 注意事项： 在CREATE TABLE后写清楚我们要创建的表的名称 在小括号 () 中定义这个表各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性(列的属性用中括号 [] 包起来的意思是这部分是可选的) 列名、数据类型、列属性之间用空白字符分开就好，然后各个列的信息之间用逗号分隔开 下面我们建个表为例展示一下： 1234CREATE TABLE first_table( first_column INT, second_column VARCHAR(100)); 执行结果如下： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; );Query OK, 0 rows affected (0.02 sec) 如何查看已建立的表的列属性信息？ 1234567mysql&gt; show create table first_table;// 结果如下CREATE TABLE `first_table` ( `first_column` int(11) DEFAULT NULL, `second_column` varchar(100) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 2、为建表语句添加注释​ 我们可以在创建表时将该表的用处以注释的形式添加到语句中，只要在建表语句最后加上COMMIT语句即可： 123CREATE TABLE 表名 ( 各个列的信息 ...) COMMENT '表的注释信息'; 比如我们可以这样写first_table的建表语句： 1234CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100)) COMMENT '第一个表'; 注释没必要太长，言简意赅即可，毕竟是给人看的，让人看明白是个啥意思就好了。为了我们自己的方便，也为了阅读你创建的人的方便，请遵守一下职业道德，写个注释吧～ 3、IF NOT EXISTS​ 和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，我们来试试重复创建一下first_table表： 12345mysql&gt; CREATE TABLE first_table ( -&gt; first_column INT, -&gt; second_column VARCHAR(100) -&gt; ) COMMENT '第一个表';ERROR 1050 (42S01): Table 'first_table' already exists 如果想要避免这种错误发生，可以在创建表的时候使用这种形式： 123CREATE TABLE IF NOT EXISTS 表名( 各个列的信息 ...); 4、简单的查询和插入语句简单的查询语句 如果我们想查看某个表里已经存储了哪些数据，可以用下边这个语句： 1SELECT * FROM 表名; 比如我们想看看前边创建的first_table表中有哪些数据，可以这么写： 12mysql&gt; SELECT * FROM first_table;Empty set (0.01 sec) 很遗憾，我们从来没有向表中插入过数据，所以查询结果显示的是Empty set，表示什么都没查出来～ 简单的插入语句 MySQL插入数据的时候是以行为单位的，语法格式如下： 1INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...); 也就是说我们可以在表名后边的括号中指定要插入数据的列，然后在VALUES后边的括号中按指定的列顺序填入对应的值，我们来为first_table表插入第一行数据： 12mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(1, 'aaa');Query OK, 1 row affected (0.00 sec) 这个语句的意思就是我们要向first_table表中插入一行数据，first_column列的值是1，second_colum列的值是’aaa’。看一下现在表中的数据： 1234567mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa |+--------------+---------------+1 row in set (0.00 sec) 我们也可以只指定部分的列，没有显式指定的列的值将被设置为NULL，NULL的意思就是此列的值尚不确定。比如这样写： 12345mysql&gt; INSERT INTO first_table(first_column) VALUES(2);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO first_table(second_column) VALUES('ccc');Query OK, 1 row affected (0.00 sec) 这两条语句的意思就是： 第一条插入语句我们只指定了first_column列的值是2，而没有指定second_column的值，所以second_colum的值就是NULL。 第二条插入语句我们只指定了second_column的值是’ccc’，而没有指定first_column的值，所以first_column的值就是NULL。 执行完这两条语句后，再看一下现在表中的数据： 123456789mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc |+--------------+---------------+3 rows in set (0.00 sec) 批量插入 每插入一行数据写一条语句也不是不行，但是对人来说太烦了，而且每插入一行数据就向服务器提交一个请求远没有一次把所有插入的数据提交给服务器效率高，所以MySQL为我们提供了批量插入记录的语句： 1INSERT INTO 表名(列1,列2, ...) VAULES(列1的值，列2的值, ...), (列1的值，列2的值, ...), (列1的值，列2的值, ...), ...; 也就是在原来的单条插入语句后边多写几条记录的内容，用逗号分隔开就好了，举个例子： 12345678910111213141516mysql&gt; INSERT INTO first_table(first_column, second_column) VALUES(4, 'ddd'), (5, 'eee'), (6, 'fff');Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM first_table;+--------------+---------------+| first_column | second_column |+--------------+---------------+| 1 | aaa || 2 | NULL || NULL | ccc || 4 | ddd || 5 | eee || 6 | fff |+--------------+---------------+6 rows in set (0.01 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库层面基本操作]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ MySQL中把一些标的集合成为一个数据库，MySQL服务器管理着若干个数据库，每个数据库下都可以有若干个表，即 展示数据库​ 在刚安装好MySQL的时候，它内建了许多数据库和表了，我们可以使用下述命令来看一下都有哪些数据库： 1SHOW DATABASES; 创建数据库1CREATE DATABASE 数据库名; ​ 注意如果一个数据库已经存在的情况下再使用CREATE DATABASE去创建这个数据库会产生错误！如果我们并不清楚数据库是否存在，可以使用下边的语句来创建数据库： 1CREATE DATABASE IF NOT EXISTS 数据库名; 上述命令的意思是如果指定数据库不存在的话就创建它，否则什么都不做。 切换当前数据库​ 对于每一个连接到MySQL服务器的客户端，都有一个当前数据库的概念（也可以称之为默认数据库），我们创建的表默认都会被放到当前数据库中，切换当前数据库的命令也贼简单： 1USE 数据库名称; ​ 如果显示了Databases changed，说明当前数据库已经切换成功了。需要注意的是，在退出当前客户端之后，也就是你输入了exit或者quit命令之后或者直接把当前的黑框框页面关掉，当你再次打开MySQL时，相当于重新开启了一个客户端，需要重新调用USE 数据库名称的语句来选择一下当前数据库。 ​ 其实我们在新客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，只要把数据库名称写在启动客户端的命令后面就好，如下： 1mysql -hlocalhost -uroot -p 数据库名称; 删除数据库​ 如果我们觉得某个数据库没用了，可以把它删除掉，语法如下： 1DROP DATABASE 数据库名; ​ 在真实的工作环境里，在删除数据库之前你需要先拿体温计量量是不是发高烧了，然后再找至少两个人核实一下自己是不是发烧了，然后你才敢执行删除数据库的命令。删除数据库意味着里边的表就都被删除了，也就意味着你的数据都没了，所以是个极其危险的操作，使用时需要极其谨慎。 ​ ​ 如果某个数据库并不存在，我们仍旧调用DROP DATABASE语句去删除它，会报错。 ​ 如果想要避免这种报错，可以使用这种形式的语句来删除数据库： 1DROP DATABASE IF EXISTS 数据库名;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F10%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL支持所有的SQL数据类型，主要分为以下四类： 数值类型 字符串类型 时间日期类型 二进制类型 一、数值类型​ MySQL数值类型有9种，其中整数类型有5种（INTEGER、TINYINT、SMALLINT、MEDIUMINT和BIGINT）、浮点类型2种（float(M,D)、double(M,D)）、定点数1种（decimal(M,D)）和bit(M)类型1种。 整数类型 ​ 使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间。根据表示一个数占用字节数的不同，MySQL把整数划分成如下所示的类型： 类型 占用的存储空间（单位：字节） 无符号数取值范围 有符号数取值范围 含义 TINYINT 1 0~255 -128~127 非常小的整数 SMALLINT 2 0~65535 -32768~32767 小的整数 MEDIUMINT 3 0~16777215 -8388608~8388607 中等大小的整数 INT(INTEGER) 4 0~4294967 295 -2147483648~2147483647 标准的整数 BIGINT 8 0~2^64^-1 -2^63^~2^63^-1 大整数 以TINYINT为例，用1个字节，也就是8位表示有符号数的话，就是既可以表示正数，也可以表示负数的话，需要有一个比特位表示正负号。但是如果表示无符号数的话，也就是只表示非负数的话，就不需要表示正负号，这就是有符号数和无符号数的区别。 注意，对于INT(M)类型，M值不代表可以存储的数字长度，代表的是数据在显示时显式的最小长度。在 INT(M) 中，M 的值跟 INT(M) 所占多少存储空间并无任何关系。 INT(3)、INT(4)、INT(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，INT(M) 跟 INT 数据类型是相同的。当数据长度超过M时，相当于啥也没发生，正常显示。如果数据长度小于M，需要指定某个字符来填充。要查看出不同效果记得在创建类型的时候加 zerofill（见”列的属性”一节）这个值，表示用0填充，否则看不出效果的 浮点数类型 ​ 浮点数是用来表示小数的，平时用的十进制小数也可以转换成二进制后被计算机存储。比如9.875，这个小数可以被表示成这样： 19.875 = 8 + 1 + 0.5 + 0.25 + 0.125 = 1 × 2³ + 1 × 2⁰ + 1 × 2⁻¹ + 1 × 2⁻² + 1 × 2⁻³ 即，如果十进制小数9.875转换成二进制小数的话就是：1001.111。为了在计算机中存储这种二进制小数，统一把它们表示成 a*2^n 的科学计数法的形式，其中1&lt;=|a|&lt;2，比如1001.111可以表示为1.001111*2^3，我们把小数点后的001111成为尾数，把3称为指数，然后只需要在计算机中的比特位中表示出尾数和指数就行了。另外，小数也有正负之分，我们还需要单独的部分来表示小数的正负号。综上所述，表示一个浮点数需要下边几个部分： 符号部分：占用1个比特位即可 指数部分：视具体浮点数格式而定 尾数部分：视具体浮点数格式而定 ​ 很显然，表示一个浮点数使用的字节数越多，表示尾数和指数的范围就越大，也就是说可以表示的小数范围就越大。MySQL根据表示一个小数需要的不同字节数定义了如下的两种浮点数类型： 类型 占用的存储空间（单位：字节） 绝对值最小非零值 绝对值最大非零值 含义 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 单精度浮点数 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 双精度浮点数 MySQL中，FLOAT占4字节（1位符号位，8位表示指数，23位表示尾数），DOUBLE占8字节（1位符号位，11位表示指数，52位表示尾数）。这里以单精度浮点数类型FLOAT为例，它占用的4个字节的各个组成部分如下图所示： 另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的（即可能存在精度损失的问题）。 ​ 这里我们补充一下浮点数类型在内存中的存储方式： ​ 先来卡一下浮点数二进制表达的三个组成部分： ​ 三个主要部分是： 符号：表示浮点数是正数还是负数，0表示正数，1表示负数 指数部分：类似于科学计数法中的M*10^N^中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中以2^7^-1即127，也即01111111代表指数部分为0，转换时需要根据127作偏移调整。 尾数部分：浮点数中具体数值的实际表示。 ​ 下面展示实际转换过程： step 1：改写整数部分 ​ 以数值5.2为例。先不考虑小数部分，我们先单纯的将十进制数改写成二进制。即5转换为101 step 2：改写小数部分 ​ 把十进制的小数部分乘以2，取整数部分作为作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。 ​ 例如0.2可以转换为： ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ 0.6*2 = 1.2 1 ​ 0.2*2 = 0.4 0 ​ 0.4*2 = 0.8 0 ​ 0.8*2 = 1.6 1 ​ …… ​ 即最后转换结果为：.0011001……（它是一个无限循环的二进制数，明白为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况了吗） step 3：规格化 ​ 现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。 step 4：填充 ​ 指数部分（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。 ​ 尾数部分：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分1在填充时被舍去了。因为规格化后的数值整部部分总是为1。那省略整数部分后岂不是1.010011和0.010011就混淆了么？其实并不会，如果仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。（那么如何表示指数为-2的形式呢？即127-2=125，二进制表示为01111101） 举两个例子吧，比较直观一些（浮点数二进制转换工具） 1、9.875 其中打钩代表对应的二进制位为1，否则为0 2、0.3 ​ 设置最大位数和小数位数 ​ 在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，即 12FLOAT(M,D)DOUBLE(M,D) ​ 对我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M,D)或DOUBLE(M,D)来限制可以存储到本列中的小数范围。其中： M表示该小数最多需要的十进制有效数字个数 注意是有效数字个数，比如对于2.3，有效数字个数是2，对于0.9来说有效数字个数就是1 D表示该小数的小数点后的十进制数字个数 小数点后有几个十进制数字，D的值就是什么 举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化： 类型 取值范围 FLOAT(4,1) -999.9~999.9 FLOAT(5,1) -9999.9~9999.9 FLOAT(4,0) -9999~9999 FLOAT(4,2) -99.99~99.99 M取值范围为0~255。FLOAT只保证7位有效数字的准确性，所以FLOAT(M,D)中，M&lt;=6时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 D取值范围为0~30，同时必须&lt;=M。double只保证16位有效数字的准确性，所以DOUBLE(M,D)中，M&lt;=16时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。 FLOAT和DOUBLE中，若M的定义分别超出7和16，则多出的有效数字部分，取值是不定的，通常数值上会发生错误。因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。 定点数类型 ​ 因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了定点数类型，它也是存储小数的一种方式： 类型 占用的存储空间（单位：字节） 取值范围 DECIMAL(M,D) 取决于M和D 取决于M和D ​ M和D的含义与浮点数中M和D的含义一样。但单精度浮点数类型FLOAT(M,D)占用的字节一直都是4字节，双精度浮点数类型DOUBLE(M,D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动。但对于定点数类型DECIMAL(M,D)来说，它占用的存储空间大小就和M、D的取值有关。 ​ 定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。如何才能保证精确存储呢？只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么。比如对于十进制小数9.85来说，我们可以把小数点左右的两个整数，也就是9和85分别保存起来，那么不就相当于保存了一个精确的小数。 ​ ​ 下面详细说一下DECIMAL(M,D)的存储方式，以DECIMAL(16,4)为例： 1、首先确定小数左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图： 2、从小数点位置出发，每个整数每隔9个十进制位划分为一组，如图： 从上图可以看出，如果不足9个十进制位，也会被划分为一组 3、针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表： 组中包含的十进制位数 占用的存储空间大小（单位：字节） 1或2 1 3或4 2 5或6 3 7或8或9 4 所以DECIMAL(16,4)共需要占用8个字节的存储空间大小，这8个字节由下边三个部分组成： 第一组包含3个十进制位，需要2个字节 第二组包含9个十进制位，需要4个字节 第三组包含4个十进制位，需要2个字节 4、 将转换完成的比特位序列的最高位设置为1 举个例子吧，要不这咋可能弄得懂嘛，哼！ 比如用DECIMAL(M,D)存储十进制小数1234567890.1234，这个小数会被分为三部分： 11 234567890 1234 然后将每一组中的十进制数字转换成对应的二进制数字 第一组占用2个字节，即对应的二进制数为： 100000000 00000001(0x0001) 第二组占用4个字节，整数234567890对应的十六进制数为 10x0DFB38D2 第三组占用2个字节，整数1234对应的十六进制数为 10x04D2 所以将这些十六进制数字连起来之后就是： 10x00010DFB38D204D2 ​ 最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(M,D)存储时共占用8个字节，具体为： 10x80010DFB38D204D2 ​ 如果用定点数类型DECIMAL(16,4)存储一个负数怎么办？比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就行，即 10x7FFEF204C72DFB2D ​ 对于定点数类型，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。 ​ 对于定点数类型DECIMAL(M,D)来说，M和D都是可选的，默认的M的值是10，默认的D的值为0，即 12DECIMAL = DECIMAL(10) = DECIMAL(10,0)DECIMAL(n) = DECIMAL(n,0) M的范围是1-65，D的范围是0-30，且D的值不能超过M。 ​ 注意：比如DECIMAL(5,2)，取值范围为-999.99~999.99 如果存储时，整数部分超出了范围（如1000.01）,MySQL就会报错，不允许存这样的值。 如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。 如：999.994实际被保存为999.99。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如999.995和-999.995都会报错。 无符号数值类型 ​ unsigned是MySQL自定义的类型，主要有以下用途： 起到约束数值的作用，即非负数 增加数值范围 unsigned可以用于整数、浮点数和定点数。MySQL提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词unsigned 1数值类型 unsigned 注意：在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。 二、日期时间类型​ MySQL提供了多种关于时间和日期的类型，各种类型能表示的范围如下： 类型 存储空间要求（单位：字节） 取值范围 含义 YEAR 1 1901~2155 年份值 DATE 3 ‘1000-01-01’ ~ ‘9999-12-31’ 日期值 TIME 3 ‘-838:59:59’ ~ ‘838:59:59’ 时间值 DATETIME 8 ‘1000-01-01 00:00:00’ ～ ‘9999-12-31 23:59:59’ 日期加时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ ～ ‘2038-01-19 03:14:07’ 时间戳 ​ 在MySQL5.6.4这个版本后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持，称为小数秒。MySQL最多支持6为小数秒的支持，各个位代表的意思如下： 如果想让TIME、DATETIME、TIMESTAMP支持小数秒，可以这样写： 12类型(小数秒位数)其中的小数秒位数可以在0,1,2,3,4,5,6中选择 比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果多了小数秒，就需要额外的存储空间： 保留的小数秒位数 额外需要的存储空间（单位：字节） 0 0 1或2 1 3或4 2 5或6 3 注意，要特别注意下DATETIME和TIMESTAMP的区别 占用空间不同，datetime占8字节，timestamp占用4字节 表示范围不同，timestamp表示当前时间到Unix元年（1970 年 1 月 1 日 0 时 0 分 0 秒）的秒数。 时区。timestamp以UTC的格式存储，它会自动检索当前时区并进行转换，datetime不会进行时区的检索。也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。比如 1set time_zone = "+9:00";(时区设为东九区) 此时就相当于是改变了时区。 如果存进去的是NULL，timestamp会自动存储当前时间，而datetime会储存NULL timestamp类型可以在修改时自动更新 1uptime timestamp default current_timestamp on update current_timestamp 三、字符串类型​ 字符是面向人的概念，如果想在计算机中表示字符，那就需要将该字符与一个特定的二进制序列对应起来，这个映射过程称为编码。但这种映射关系不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种： 固定长度的编码方案 表示不同的字符所需要的字节数量是相同的。比方说ASCII编码方案采用1个字节来编码一个字符，usc2采用2个字节来编码一个字符。 变长的编码方案 表示不同的字符所需要的字节数量是不同的。比如utf8编码方案采用1-3个字节来编码一个字符，gb2312采用1-2个字节来编码一个字符。 注意：正儿八经的UTF-8编码占用1~ 4个字节，这里的utf8占用1~3个字节是阉割版的。如果我们之后有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集。 MySQL的字符串类型 ​ 下表示MySQL中提供的字符串类型，其中M代表该数据类型最多能存储的字符数量，L代表实际向该类型中存储的字符串在特定字符集下所占的字节数，W代表该特定字符集下，编码一个字符最多需要的字节数： 类型 最大程度 存储空间要求 含义 CHAR(M) M个字符 M*W个字节 固定长度字符串 VARCHAR(M) M个字符 L+1或L+2个字节 可变长度字符串 TINYTEXT 2^8^-1个字节 L+1个字节 非常小型的字符串 TEXT 2^18^-1个字节 L+2个字节 小型的字符串 MEDIUMTEXT 2^24^-1个字节 L+3个字节 中等大小的字符串 LONGTEXT 2^32^-1个字节 L+4个字节 大型的字符串 CHAR(M) ​ M是该类型最多可以存储的字符数量（非字节数量），M的取值范围是0-255。如果省略掉M的值，那它的默认值就是1，也就是说CHAR和CHAR(1)是一个意思。CHAR(0)是一种特别的类型，它只能存储空字符串或者NULL值。 ​ CHAR(M)在不同的字符集下需要的存储空间也是不一样的，我们假设某个字符集编码一个字符最多需要W个字节，那么类型CHAR(M)占用的存储空间大小就是M×W个字符。比方说： 对于采用ASCII字符集的CHAR(5)类型来说，ASCII字符集编码一个字符最多需要1个字节，也就是M=5，W=1，所以占用的内存空间大小是5*1=5个字节。 对于采用gbk字符集的CHAR(5)类型来说，gbk字符集编码一个字符最多需要2个字节，也就是M=5，W=2，所以占用的内存空间大小是5*2=10个字节。 对于采用utf8字符集的CHAR(5)类型来说，utf8字符集编码一个字符最多需要3个字节，也就是M=5，W=3，所以占用的内存空间大小是5*3=15个字节。 ​ 如果我们实际存储的字符串在特定字符集编码下占用的字节数不足M*W，那么剩余的那些存储空间用空格字符补齐。即一旦确定了CHAR(M)类型的M，如果M的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费。 VARCHAR(M) ​ 如果某个列存储的字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，因此可以使用VARCHAR(M)。 ​ VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是0-65535。但是，MySQL中有一个规定，表中某一行包含的所有列中存储的数据大小总共不能超过65535个字节，也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。 ​ VARCHAR(M)类型表示的数据由以下两部分组成： 1、真正的字符串内容 ​ 假设真正的字符串在特定字符集编码后占用的字节数为L 2、占用字节数 ​ 假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么： 当M*W&lt;256时，只需要一个字节来表示占用的字节数 当M*W&gt;=256且M*W&lt;65536时，需要两个字节来表示占用的字节数 （因为一个字节能表示的最大无符号数是255，两个字节能表示的最大无符号数十65535） 各种TEXT类型 ​ 虽然VARCHAR(M)已经可以存储很长的字符串了，可有时候还是不够怎么办？对于很长的字符串，可以用TEXT存储大型字符串，它们都是变长类型。 ​ MySQL有个规定，某一行包含的所有列中存储的数据大小总和不得超过65535个字节。这个规定对于这些TEXT类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了。 ENUM类型和SET类型 ENUM类型称为枚举类型，它表示在给定的字符串列表里选择一个。比如性别，只能在’男’和’女’里面选一个，相当于一个单选框 1ENUM('str1','str2','str3',...) SET类型表示可以在给定的字符串列表里选择多个。比如兴趣列表，相当于一个多选框 1SET('str1','str2','str3',...) SET类型怎么insert？ 123456789101112131415mysql&gt; create table enum_set_table( -&gt; id int auto_increment primary key, -&gt; gender enum('M','F'), -&gt; hobby set('music','movie','swimming','footbal') -&gt; );Query OK, 0 rows affected (0.01 sec)/* 一个enum值，一个set值，二者均使用选项的字符串格式 */mysql&gt; insert into enum_set_table(id,gender,hobby) values(null,'M','music');Query OK, 1 row affected (0.01 sec)/* 一个enum值，多个set值，二者均使用选项的字符串格式 */// 这种同时输入多个set值的方法要注意mysql&gt; insert into enum_set_table(id,gender,hobby) values(null,'F','music,movie,footbal');Query OK, 1 row affected (0.00 sec) 综上所述，ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。 四、二进制类型 BIT类型 ​ 有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型： 类型 字节数 含义 BIT(M) 近似为(M+7)/8 存储M个比特位的值 M默认为1，M的取值范围为1~64，M可以省略，即BIT和BIT(1)一样。 BINARY(M)和VARBINARY(M) ​ 前者是固定长度的类型，后者是可变长度的类型，其中M代表该类型最多能存放的字节数量。BINARY(M)和VARBINARY(M)对应于我们前边提到的CHAR(M)和VARCHAR(M)，都是前者是固定长度的类型，后者是可变长度的类型，只不过BINARY(M)和VARBINARY(M)是用来存放字节的，其中的M代表该类型最多能存放的字节数量，而CHAR(M)和VARCHAR(M)是用来存储字符的，其中的M代表该类型最多能存放的字符数量。它们M的取值范围一样，对于CHAR 和BINARY是0 ~ 255；对于VARCHAR和VARBINARY是0 ~ 65535。 其它的二进制类型 ​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB是针对数据量很大的二进制数据提出的，比如图片、音乐、压缩文件啥的。BLOB和TEXT一样也是变长的，有相同的最大长度和存储需求。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句使用注意事项]]></title>
    <url>%2F2019%2F10%2F25%2FMySQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[​ MySQL的基本运行过程是：通过客户端发送命令给服务器程序，服务器程序按照接收的命令去操作实际的数据。在我们使用黑框框启动了MySQL客户端程序之后，界面上会一直显示一行字儿：mysql&gt;，这是一个提示符，你可以在它后边输入我们的命令然后按下回车键就把命令从客户端程序发送到了服务器程序，在书写命令的时候需要注意下边这几点： 1、命令结束符号 ​ 在书写完一个命令后需要以下面几个符号之一结尾： ； \g \G 其中；和\g的效果一样，如下所示： 123456789101112131415161718192021mysql&gt; show tables;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+mysql&gt; show tables\g+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 其中\G有一点特殊，它并不以表格的形式返回查询结果，而是以垂直的形式将每个列都展示在单独的一行中： 1234567891011mysql&gt; show tables\G*************************** 1. row ***************************Tables_in_run: student_info*************************** 2. row ***************************Tables_in_run: student_score*************************** 3. row ***************************Tables_in_run: t1*************************** 4. row ***************************Tables_in_run: t1_view*************************** 5. row ***************************Tables_in_run: t2 如果查询结果的列数非常多的话，使用\G可以让我们看清结果。 注意：使用Navicat第三方工具是不支持\g和\G的，只能在cmd界面中使用。 2、命令可以随意换行 ​ 并不是按了回车键就提交命令了，只要按回车键的时候输入的语句里没有；、\g或\G这些语句结束符号，该语句就算是没有结束。比如上面的语句可以写成： 123456789101112mysql&gt; show -&gt; tables -&gt;;+---------------+| Tables_in_run |+---------------+| student_info || student_score || t1 || t1_view || t2 |+---------------+ 3、可以一次提交多个命令 ​ 我们可以在一条语句里面写多个命令（命令之间用上面说的结束符间隔，但记住在写完前不要回车），只要没按回车键，就不会提交命令，如： 1234567891011121314151617181920212223mysql&gt; SELECT NOW(); SELECT NOW(); SELECT NOW();+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)+---------------------+| NOW() |+---------------------+| 2018-02-06 18:00:05 |+---------------------+1 row in set (0.00 sec)mysql&gt; 4、使用 \c 放弃本次操作 ​ 如果你想放弃本次编写的命令，可以在输入的命令后边加上\c，比如 12mysql&gt; SELECT NOW()\cmysql&gt; 如果不使用\c，那客户端会以为这是一个多行命令，还在一直傻傻的等你输入命令。 注意：\c在Navicat第三方软件中不能用，只能用于cmd窗口中。 5、大小写 ​ MySQL默认对命令的大小写并没有限制。但是如果是表、列的名称就会对大小写敏感了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL密码错误如何修改？]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[​ 前两天我在用MySQL的时候，出现了一个小问题：就是我在注册完windows服务后，然后用net start MySQL80登录到数据库服务器，却无法使得客户端连接到服务器，即在输入完mysql -uroot -p后，会报如下的错误： (这种问题一般是由于密码错误引起的) ​ 于是我就查了一个解决方法，特此记录一下： 1、首先打开一个cmd窗口A： 首先关闭MySQL服务器 1net stop MySQL80 无密码启动MySQL服务 1mysqld --console --skip-grant-tables --shared-memory 2、再开一个cmd窗口B： 无密码登录（密码处直接enter） 12mysql -uroot -p//注意下面出现密码时，直接enter即可连接至MySQL 免密码登录设置空密码 ​ 设置空密码 1UPDATE mysql.user SET authentication_string=&apos;&apos; WHERE user=&apos;root&apos; and host=&apos;localhost&apos;; ​ 刷新 1flush privileges; 设置加密的密码 ​ 以caching_sha2_password加密密码并设置 1ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH caching_sha2_password BY &apos;新密码&apos;; ​ 刷新 1flush privileges; 这样修改完之后，就可以设置新的密码了，也就可以解决上述问题。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初始化与启动那些事]]></title>
    <url>%2F2019%2F09%2F28%2FMySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[​ MySQL采用客户端/服务端架构，即它是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可以有多种形式，比如手机APP，电脑软件或者网页版微信。每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器程序，我们平时操作微信其实都是用客户端来和这个服务器来打交道。 ​ MySQL的使用过程大概为：它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器程序就响应这些请求，从而操作它维护的数据。日常使用MySQL的场景一般是这样的： 启动MySQL服务器程序 启动MySQL客户端程序并连接到服务器程序 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。 MySQL默认安装位置：C:\Program Files\MySQL\MySQL Server 8.0\，也可以自定义安装路径，为了方便就按照默认路径来安装吧~ 如何启动MySQL服务器程序？​ 这里以windows系统为例介绍。在windows系统下提供了手动启动和以服务的形式启动两种启动方式。 以服务的形式启动 ​ 什么是windows服务呢？如果需要长时间的运行某个程序，而且需要在计算机启动的时候启动它，一般我们都会把它注册为一个windows服务，操作系统会帮助我们管理它。 在MySQL根目录下(C:\Program Files\MySQL\MySQL Server 8.0)手动创建一个data文件夹 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld install MySQL80 进入到bin文件夹，打开cmd命令行，输入命令： 1mysqld --initialize-insecure --user=mysql80 打开MySQL服务器程序： 12net start MySQL80 //打开net stop MySQL80 //关闭 手动启动 ​ MySQL安装目录下的bin目录下的mysqld可执行文件代表着服务器程序，我们运行这个可执行文件就会启动MySQL服务器。 ​ MySQL服务器运行过程中严重依赖一个称之为数据目录的路径，不过我们安装MySQL时使用的MySQL Installer把这个数据目录的路径设置为了： 1C:\ProgramData\MySQL\MySQL Server 8.0\data 当然不同版本的MySQL Installer可能将数据目录的路径设置为不同的值。 ​ 在使用mysqld可执行文件启动MySQL服务器程序时，它默认并不会将上述路径设置为数据目录的路径，此时需要我们在启动MySQL服务器时显式地指定一个称之为datadir的参数，该参数就代表着数据目录的路径，所以使用下面的命令启动MySQL服务器： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; 特别要注意的是，当我们按下回车键后，cmd命令窗似乎卡住不动了，这就意味着MySQL服务器启动了，如果此时我们把这个cmd命令窗关掉，或者按下Ctrl+C键，就会停止MySQL服务器程序的运行。因此，还是推荐使用windows服务的方式来启动或停止MySQL服务器程序。 ​ 如果想查看使用mysqld启动MySQL服务器的过程中输出的日志信息，可以在上述命令后边加上—console： 1mysqld --datadir=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\data&quot; --console 如何启动MySQL客户端程序？​ 在服务器程序启动之后（不管是使用mysqld可执行文件启动的还是使用Windows服务的方式启动的），就可以接着启动客户端程序来连接到这个服务器喽。bin目录下有许多客户端程序，比方说mysqladmin、mysqldump、mysqlcheck等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件mysql.exe，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求以及接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下： 1mysql -h主机名 -u用户名 -p密码 参数意义： 参数名 含义 -h 表示启动服务器程序的计算机的域名或者IP地址，如果服务器程序就运行在本机的话，可以省略这个参数，也可以填localhost或127.0.0.1。也可以写成—host=主机名 -u 表示用户名，作为超级管理员的我们的用户名是root。也可以写成—user=root -p 表示密码。也可以写成—password=密码 连接注意事项 最好不要再一行命令中输入密码 这样容易导致密码泄露，可以这样写 1mysql -hlocalhost -uroot -p 如果非要显示的把密码写出来，那密码值和-p之间不能有空格，其他参数之间可以有空格。且各个参数的摆放顺序没有硬性规定。 如果你的服务器和客户端安装在同一台机器上，-h参数可以忽略，就像这样 1mysql -uroot -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客如何迁移至其它电脑]]></title>
    <url>%2F2019%2F07%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[​ 当你在一台电脑上写博客写的蛮爽的，但突然有一天你的电脑坏了或者被偷了咋办？你那些本地的博客可咋整！一想到这种有可能发生的危险，我就夜不能寐呀。于是我就开始疯狂地查找资料，但网上的资料良莠不齐。于是本人就自己慢慢的摸索嘛，这是一个程序员最基本的素质(其实还是自己太菜了)。下面我就把我的总结写一下，希望能对以后的自己和大家有帮助。 1、在新电脑上安装NodeJs和Git​ 这一步很简单，具体怎么安装，可以参见我的上一篇博文：利用hexo框架搭建个人博客(手把手教学) 2、GitHub新建分支​ 在pringce.github.io仓库下： 这里的分支名可以任意设置。 3、设置分支为默认仓库当前仓库-&gt;Settings-&gt;Branches-&gt;Default Branch 4、clone至本地​ 将该分支克隆至本地 1git clone https://github.com/pringce/pringce.github.io.git ​ cd进入 clone 下来的pringce.github.io文件夹，在此文件夹目录下git bash执行git branch命令，应该是新建的分支名 new。 5、新电脑生成ssh key并添加至GitHub​ 依次按照下述步骤生成本机ssh key： 1git config --global user.email "GitHub注册并验证时的邮箱" 1git config --global user.name "GitHub用户名" 1ssh-keygen // 一直按enter就行 在本机目录“C:\Users\10530\.ssh”会生成两个文件：id_rsa(私钥)和id_rsa.pub(公钥)。打开id_rsa.pub，复制里面的内容到GitHub: Settings -&gt; SSH and GPG keys -&gt; (填写)Title -&gt; (粘贴)Key -&gt; Add SSH Key 测试是否成功： 1ssh -T git@github.com 输出 You’ve successfully authenticated 表示添加key 成功。 6、安装hexo1npm install hexo-cli -g 7、将原博客文件拷贝至pringce.github.io文件夹​ 将原博客文件夹下的文件拷贝至pringce.github.io，需要拷贝6个：_config.yml（站点配置文件）、themes\（主题）、source\（博客源文件）、scaffolds\（文章的模板）、package.json、.gitignore。 此时，我们不需要再用hexo init来生成博客了，因为需要的文件我们已经拷贝过来了。 8、提交本地至new分支​ 进入pringce.github.io文件夹，依次执行 1git add . 1git commit -m &quot;新电脑&quot; 1git push 这样，master分支用于保存博客静态资源，提供博客页面供人访问；new分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突。 9、安装hexo依赖的包1npm install ​ 所依赖的包都在上一步中的package.json备份文件里，所以直接这一个命令就可以了。就可以把你以前配置的那些包都安装上了。 10、新旧电脑更新博客​ 依次按照以下步骤来更新博客： 1git pull 1hexo new &quot;name&quot; 1hexo clean 1hexo g 1hexo s(测试时候在localhost看一下) 1hexo d(部署) 1git add . 1git commit -m &quot;新电脑&quot; 1git push //保证new分支版本为最新 因此，如果我们电脑又坏了或者又被偷了。。。那我们可以先获得新电脑的ssh key，然后添加到GitHub。然后把new分支下文件git clone下来，然后再新建、编辑、部署一步一步来即可。 好啦，心理的最大隐患解除了，可以安心睡觉啦。大家晚安！！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树全解析]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言​ 其实大家都说决策树简单，但个人觉得如果想学好这个算法其实还是需要下一些功夫的。决策树是一种基本的分类与回归方法(不要觉得决策树只能分类哦，它也可以做回归的)。 ​ 为了方便下面的讨论，我们先做一下说明： ​ 假设有一组训练数据 D=(x1,y1),(x2,y2),\cdots,(xn,yn)​ 表示有n个样本，样本共分为K类情况下，yi的取值来自K个类别值 (C1,C2,\cdots,Ck) ​ 另外，无论是ID3树、C4.5树还是CART树都是差不多的，都由特征选择(分裂特征选择算法)、树的生成和剪枝组成。它们之间的区别主要是特征选择和剪枝算法不同，这些我们后面会详细讨论，这里先留个伏笔。 ID3树​ 在介绍ID3决策树之前，我想先说一个概念：信息增益。 ​ 一个离散型随机变量x的概率分布为 P(x=x_i)=p_i​ ，则x的信息熵定义为 H(x)=-\sum_{i=1}^{n}{p_i}​ 数据集的熵表征其类别的不确定程度，而数据集关于某个特征的条件熵则表征着给定某个特征后，其类别的不确定程度： 数据集的熵—条件熵 = 该特征使数据集不确定性减小程度 设数据集D的熵为H(D)，关于特征Am的条件熵为H(D|Am)，因此可以获得信息增益为 g(D|A_m)=H(D)-H(D|A_m)其中， H(D)=-\sum_{k=1}^{K}{\frac{|C_k|}{|D|}}log_2\frac{|C_k|}{|D_k|} H(D|A_m)=\sum_{i=1}^{K}{\frac{|D_i|}{|D|}}H(D_i)​ Di 表示训练样本中特征A取值为 ai 的样本点集合(比如说特征A有三个可能的取值，则K为3)。 ID3决策树构建​ 自根节点开始，选择信息增益最大的特征作为节点的分类特征，并根据该特征的可能取值将训练数据分配到不同的子节点(对子节点进行同样的操作)。 ​ 若子节点的所有样本属于同一类别或该子节点处所有特征的信息增益均小于给定阈值或无可供选择的特征，此时我们判定该子节点为一个叶节点，将该叶节点的样本数量最多的类别作为该叶节点的类别。 ​ 算法步骤如下： 若D中样本特征为空，那么树T为一棵单节点树，将样本数量最大的类别作为节点类别，返回T。否则转到第二步； 计算D关于所有特征的信息增益，若信息增益均小于某一阈值，则T为单节点树。否则转到第三步； 选择信息增益最大的特征作为分裂特征，依据该分裂特征的所有可能取值建立相应子节点。若子节点样本全为同一类别，则子节点为叶节点。若均为叶节点，返回T。否则转到第四步； 对非叶节点 i，以 Di 为训练集，将特征集减去刚才的分裂特征(这里特别需要注意一点，如果该特征是类别特征，则在分裂完成后删除该特征；如果为连续特征，则不删除该特征)，以得到新的特征集，然后递归调用第一步至第三步。 总结 ID3树在选取分裂特征时采用信息增益原则(其实个人理解，无论是ID3、C4.5还是CART树，在选取分裂特征时，基于的总原则都是使分裂前后的数据复杂度减少程度最多，因为选取该特征才能使得这样构建出来的决策树分类或回归效果最好)。 ID3树后剪枝的策略是PEP(悲观误差剪枝)，这里后面再介绍，这里先占个坑哈哈哈。 C4.5树​ 上述ID3树采用的是信息增益来进行节点分裂特征的选取。信息增益原则对于每个分支节点，都会乘以其权重，也就是说，由于权重之和为1，所以分支节点分的越多，即每个节点数据越少，纯度可能越高。这样会导致信息增益准则偏爱那些取值数目较多的属性。 ​ 为了解决该问题，引入了信息增益率，这个也就是C4.5树的分裂准则。C4.5树的基本构建流程与ID3树类似，唯一的区别就是C4.5树采用信息增益率进行特征选择，而ID3树采用信息增益进行特征选择。 ​ 信息增益率的定义如下： G_{ratio}=\frac{g(D|A_m)}{H_{A_m}(D)}​ 其中， H_{A_m}(D)=-\sum_{i=1}^{K}\frac{|D_i|}{|D|}log2{\frac{|D_i|}{|D|}}​ 需要注意的是，信息增益率原则可能对取值数目较少的属性更加偏爱。因此，C4.5并不是直接选择增益最大的候选划分属性。为了解决这个问题，C4.5采用了一种启发式算法，可以先从候选划分属性中找出信息增益在平均值以上的属性，再从中选择信息增益率最高的。 CART树​ 这里先强调一点，CART树是二叉树。与ID3和C4.5的决策树所不同的是，ID3和C4.5生成的决策树可以是多叉的，每个节点下的叉树由该节点特征的取值种类而定，比如特征年龄分为(青年，中年，老年)，那么该节点下可分为3叉。而CART决策树为二叉树，内部节点特征取值为“是”和“否”。左分支取值为“是”，右分支取值为“否”。因此在搜索分裂特征时，是递归地二分每一个特征。个人理解为不仅要遍历每一个特征，还要遍历每一个特征的二分取值，等于是做了一次双层遍历。相比于ID3和C4.5要更加复杂一些。 ​ 另外，我们还需要注意一点，ID3和C4.5只能用于分类，而CART树既可以用于分类，也能用于回归。 ​ CART树的基本构建流程与ID3树和C4.5树类似。唯一的区别就在于特征选择准则不同，另外CART树不仅要选择最优特征，还要选择最优二值切分点。别的都一样哈哈哈！！ ​ CART分类树特征选择​ CART分类树通过基尼指数选择最优特征，同时决定该特征的最优二值切分点，而ID3和C4.5直接选择最有特征，不用划分二值点。 ​ 这里先介绍一下基尼指数，我个人的理解是基尼指数和前面的信息熵的概念是一样的，都是表征数据集的不纯度，因此我们如何选择最优特征和最优二值切分点呢？也就是分裂后如何使基尼指数下降最大！ ​ 分类问题，假设有数据集D有K个类，样本点属于第k个类的概率为 pk，则基尼指数定义为 Gini(D)=1-\sum_{k=1}^{K}p_k^2​ 在特征A下，集合D的基尼指数定义为 Gini_A(D)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)​ 那么如何选择最优特征和最优二值切分点呢？就是使切分前后的不确定性下降最大！即切分前的基尼指数和在特征A下切分后的基尼指数之间的差越大，越应该为最优特征和最优二值切分点。同理也可以得到，在特征A下切分后的基尼指数越小，越应该为最优特征和最优二值切分点。 CART回归树特征选择​ 跟CART分类树大致相同，区别主要在以下几点： ​ 分裂准则：选择特征A以及对应的属性值s将当前节点分到两个区域 R1 和 R2 中， R_1={(x|x_is)}​ 如何选择呢？就是使上述两个区域的均方误差和最小！ ​ 最终预测值：最终节点值为该节点下所有数据的平均值。 剪枝​ 剪枝很好理解，它的目的就是防止过拟合。它主要分为预剪枝和后剪枝。 预剪枝 通过提前停止树的构建而对树剪枝。一旦停止，节点就是叶节点。 停止决策树生长最简单的方法有： 定义一个高度，当决策树达到该高度时就停止决策树的生长； 当节点实例个数小于某一阈值； 当分裂增益小于某一阈值。 后剪枝 ​ 它首先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的结点子树用叶子结点来代替，该叶子的类标号用该结点子树中最频繁的类标记。相比于先剪枝，这种方法更常用，正是因为在先剪枝方法中精确地估计何时停止树增长很困难。 ​ 后剪枝方法主要有以下几个方法： ​ Reduced-Error Pruning(REP，错误率降低剪枝） ​ Pessimistic-Error Pruning(PEP，悲观错误剪枝） ​ Cost-Complexity Pruning（CCP，代价复杂度剪枝) REP REP方法是一种最简单的后剪枝方法，对每个非叶子节点，从下往上遍历，尝试将该子树从叶子节点代替。然后利用验证集进行验证，看精度是否提升。若提升，则剪枝。这种方法一般不采用。 PEP PEP的策略主要用于ID3和C4.5树。悲观错误剪枝法是根据剪枝前后的错误率来判定子树的修剪。 把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代的话，在训练集上的误判率肯定是上升的，但是在新数据上不一定。于是我们需要把子树的误判计算加上一个经验性的惩罚因子。 对一个叶子节点，有n个样本，其中e个错误，则该叶子节点错误率为 (e+0.5)/n其中，0.5为惩罚因子 对一棵子树，有L个叶子节点，则该子树的错误率为 err\_ratio=\frac{(\sum_{i=1}^{L}e_i)+0.5L}{\sum_{i=1}^{L}n_i}这样的话，我们可以看到一颗子树虽然具有多个子节点，但由于加上了惩罚因子，所以子树的误判率计算未必占到便宜。 我们可以得到子树的错误次数均值和标准差 err\_mean=err\_ratio*\sum_{i=1}^{L}n_i err\_std=\sqrt{err\_ratio*\sum_{i=1}^{L}n_i*(1-err\_ratio)}当把子树替换成叶子节点后，该叶子节点的错误率和错误次数均值为 err\_ratio^{'}=\frac{(\sum_{i=1}^{L}e_i)+0.5}{\sum_{i=1}^{L}n_i} err\_mean^{'}=err\_ratio^{'}*\sum_{i=1}^{L}n_i剪枝条件为： err\_mean+err\_std>=err\_mean^{'}PEP的缺点： PEP算法采用的是自上而下的剪枝策略，这种剪枝会导致和预剪枝同样的问题，即剪枝过度。 CCP CCP的策略主要用于CART树。 代价指在剪枝过程中因子树 Tt 叶节点替代而增加的错分样本，复杂度表示剪枝后子树 Tt 减少的叶结点数，则定义每个非叶节点剪枝后树的复杂度降低程度与代价间的关系： α(t)=\frac{C(t)-C(T_t)}{|T_t|-1}其中， C(t) = r(t) * p(t)代表剪枝后叶子节点的误差代价 对于分类树，r(t) 为该节点的错误率；对于回归树，代表该节点的均方误差。 p(t) 为该节点数据占总数据的比例。 C(T_t)=\sum_{i=1}^{m}r_i(t)p_i(t)代表剪枝前的子树误差代价 对于分类树，ri(t) 为该子树某叶子节点的错误率；对于回归树，代表该子树某叶子节点的均方误差。 pi(t) 为该子树某叶子节点占总数据的比例。 CCP剪枝算法分为两个步骤： 对于完全决策树 T 自下而上的计算每个非叶结点的 α 值，然后自上而下的循环(注意，每剪枝一次，就重新计算表面误差增益率，再循环第一步)剪掉具有最小 α 值的子树(自上而下代表若有多个非叶子节点的表面误差率增益值相同小，则选择非叶子节点中子节点数最多的非叶子节点进行剪枝)，直到剩下根节点。在该步可得到一系列的剪枝树序列｛T0，T1，T2……Tn｝,其中 T0 为原有的完全决策树，Tn为根结点，Ti+1为对 Ti 进行剪枝的结果； 从子树序列中，根据真实的验证集误差选择最佳剪枝后决策树。 例. 下图是一棵子树，设决策树的总数据量为40 C(t)=\frac{8}{18}*\frac{18}{40}=\frac{1}{5} C(T_t)=\frac{1}{3}*\frac{3}{40}+\frac{4}{9}*\frac{9}{40}+\frac{1}{6}*\frac{6}{40}=\frac{6}{40} α(t)=\frac{\frac{1}{5}-\frac{6}{40}}{3-1}=\frac{1}{40}​ 好啦，到了这里，基本就把所有的决策树知识说完啦！希望能对大家有帮助。]]></content>
      <categories>
        <category>机器学习算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo框架搭建个人博客]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%88%A9%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言​ 本文是在Windows 10环境下搭建个人博客，对于Linux和Mac环境，搭建工作基本类似，区别无非在于个别命令行指令的区别，读者只需作相应的调整即可。 1. 安装NodeJs​ hexo是基于NodeJs环境的静态博客，里面的npm工具很有用（个人感觉类似于python里面的pip或者anaconda里面的conda，是一个包管理工具），所以说NodeJs是搭建个人博客的第一步。 下载地址：https://nodejs.org/en/ 下载下图的10.16.0 LTS即可。 然后点击下载的安装包，无脑点yes安装即可。至此NodeJs已经全部安装完成。 2. 安装Git Bash​ 由于本人使用的是Windows环境，cmd指令过于难用（也难怪众多开发者投入了Linux的怀抱）。所以本人下载了Git Bash（其实也就是下载了Git工具）。在网上搜索Git可以下载一个下面这个应用程序： ​ 然后依旧无脑点yes，安装完成后，在左面点击鼠标右键，如果出现了Git Bash和Git GUI即代表Git安装成功。 ​ 然后打开Git Bash可以查看NodeJs和npm的版本： NodeJs版本 1$ node -v npm版本 1$ npm -v 3. 安装hexo​ 我们是需要借助npm来安装hexo框架的。但是由于墙的原因，国内使用npm的下载速度很慢。因此我们需要更换源（使用淘宝的那个源），利用npm来安装一个cnpm。安装完成后，后面完全可以用cnpm全面取代npm。 ​ 如何安装cnpm？ 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org ​ 安装完成后，可以查看一下cnpm的版本 1$ cnpm -v ​ 随后，开始正式安装hexo框架 1$ cnpm install -g hexo-cli ​ 如何判断hexo是否安装成功，我们只需要查看hexo的版本，如果出现版本信息，则代表hexo安装成功 1$ hexo -v 4. 开始正式搭建博客​ 首先我们需要先建立一个空的目录，存储我们的博客信息。这样的好处就是，一旦这个博客出错了或者你不想要了，直接把这个文件夹删除即可，不会影响其他的文件，保持独立性。 12$ mkdir blog$ cd blog ​ 随后在blog目录下利用hexo生成博客，很简单 1$ hexo init ​ 可以看到，生成完成后会出现下面这些文件 ​ 随后启动博客 1$ hexo s ​ 可以看到，博客可以在本地的4000端口进行访问 ​ 我们利用浏览器打开该端口，即可访问到我们最初始的博客。该博客默认有一篇hello word的博文 ​ 随后我们可以新建一篇文章，里面写上我们想要的内容即可。如何新建一篇文章？ 1$ hexo new &quot;我的第一篇文章&quot; ​ 生成完成后，便可以在blog/source/_post目录下找到我们生成的这篇文章，文件名为”我的第一篇文章.md”。随后便可以用Typora来写该博客了（markdown语法）。 ​ 因为我们现在新建了一篇文章，如何把它上传呢？（即在浏览器中也可以看到改文章）。这里就要用到hexo中著名的“素质三连”指令了 123$ hexo clean (清理)$ hexo g (生成)$ hexo s (启动) ​ 随后便可以在本地4000端口看见我们刚才新建的那篇文章了。 一切都是这么简单，一切都是这么优雅！ 5. 远端部署​ 我们写个人博客的目的不是为了只自己访问，也希望别人能看见，因此需要部署到远端服务器。这里有一种免费的部署方式，即把我们的博客部署到github上公开使用。 5.1 新建仓库 ​ 一定要注意仓库的命名方式，仓库的名称一定要和你的github昵称保持一致，否则将无法访问。例如我的github昵称为pringce，那么仓库的名称一定要命名为pringce.github.io。如下图 5.2 安装Git部署插件1$ cnpm install hexo-deployer-git --save 5.3 配置config文件​ 在我们的blog目录下，找到_config.yml这个文件，然后到文件的最底部，写入如下配置 5.4 部署到远端1$ hexo d ​ 随后输入”https://pringce.github.io&quot;，即可访问我们部署到远端服务器上的博客了。至此任何人都可以访问你的博客了，博客的部署工作完成。 一切都是这么简单，一切都是这么优雅！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
