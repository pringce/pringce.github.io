---
title: 事务
date: 2020-04-13 16:06:51
tags:
- MySQL
- 个人博客
categories:
- MySQL
mathjax: true
---

### 什么是事务

英文名是Transactions

一个事务是一个完整的业务逻辑单元，不可再分

比如：银行账户转账，从A账户向B账户转账10000，需要执行两条update语句

```mysql
update t_act set balance = balance-10000 where actno = 'act001';
update t_act set balance = balance+10000 where actno = 'act002';
```

以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败

要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的事务机制

**与事务相关的语句只有：DML语句（insert、delete、update）**。为什么？因为它们这三个语句都是和数据库表当中的数据相关的，**事务的存在是为了保证数据的完整性，安全性**



假设所有的事务都能使用一条DML语句搞定，还需要事务机制么？答案：**不需要事务了！**然而在现实世界中是很少存在的，说这个只是为了说明事务的作用是保证数据的完整性和安全性



### 事务原理

假设一个需求：需要先执行一条insert，再执行一条update，最后执行一条delete。它的过程是这样的：

- 开启事务机制（开始）：**start transaction;**或**begin;**放在最开始，代表开启一个事务
- 执行insert语句：这个执行成功之后，是把这个执行记录到数据库的操作历史缓存中，并不会向文件中保存一条数据，不会真正的修改硬盘上的数据
- 执行update语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据
- 执行update语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据
- 执行delete语句：这个执行也是记录到历史操作缓存中，不会真正的修改硬盘上的数据
- 提交事务或者回滚事务（结束）：放在最后，代表结束一个事务
  - 如果选择回滚**ROLLBACK**：只是把上述历史操作缓存中的记录清空，并不和数据打交道
  - 如果选择提交**COMMIT**：会先让硬盘中的数据根据上述操作进行修改，然后清空上述历史操作缓存中的记录清空



还可以设置保存点savepoint：

- 在某些DML语句下面写一条：**savepoint 保存点名;**代表在这里设置了一个保存点。一个事务当中可以设置多个保存点。
- 如果不想回滚整个事务，只想回滚一部分怎么办？

```mysql
mysql> rollback to 保存点名;
```

这样会回滚到该savepoint处。



### 事务的特性

事务包括四大特性：**ACID**

- **Atomicity**：原子性，整个事务中的所有操作，必须作为一个单元全部完成（或全部取消）。事务是最小的工作单元，不可再分
- **Consistency**：一致性，事务必须保证多条DML语句同时成功或同时失败
- **Isolation**：隔离性，一个事务不会影响其他事务的运行
- **Durability**：持久性，在事务完成以后，该事务对数据库所作的更改将持久地保存在数据库之中，并不会被回滚



### 关于事务之间的隔离性

事务隔离性存在隔离级别，理论上隔离级别包括四个（所有数据库都是从第二级别往上的，没人用第一级别）：

- 第一级别：读未提交（read uncommitted），允许一个事务可以看到其他事务未提交的修改。一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交，这就出现了脏读取。读未提交存在**脏读**现象（Dirty Read），表示读到了脏的数据，数据很不稳定
- 第二级别：读已提交（read commited），允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。但存在一个问题：**不可重复读（在同一个事务中，同一个读操作对同一个数据的前后两次读取产生了不同的结果）**。这种隔离级别解决了脏读现象
- 第三级别：可重复读（repeatable read），确保如果在一个事务中执行两次相同的SELECT语句，都能得到相同的结果，不管其他事务是否提交这些修改。这种隔离级别解决了不可重复读问题。
- 第四级别：串行化读/序列化读（serializable），一个事务没结束的时候，另一个事务不允许开启。解决了所有问题，但效率低，需要事务排队

**Oracle数据库默认的隔离级别是读已提交，MySQL默认的隔离级别是可重复读**



**MySQL事务默认情况下是自动提交的**（只要执行任意一条DML语句则提交一次，即默认添加commit）

- 怎么关闭自动提交：start transaction;



如何设置MySQL数据库事务隔离级别：

```mysql
mysql> set global transaction isolation level <read uncommitted | read committed | repeatable read | serializable>
```

如何查询当前事务隔离级别：

```mysql
mysql> select @@transaction_isolation;
```



当多个客户端并发地访问同一个表时，可能出现下面的一致性问题：

- 脏读取（Dirty Read） 
  -  一个事务读到另一个事务，尚未提交的修改，就是脏读。这里所谓的修改，除了Update操作,不要忘了还包括Insert和Delete操作。
  - 脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。

- 不可重复读（Non-repeatable Read） 
  - 在同一个事务中，同一个读操作对**同一个数据**的前后两次读取产生了不同的结果，这就是不可重复读。针对update和delete

- 幻像读（Phantom Read） 
  - 幻像读是指在同一个事务中以前没有的行，由于其他事务的提交而**出现的新行**。针对insert

|     隔离级别     | 脏读取 | 不可重复读 |     幻象读     |
| :--------------: | :----: | :--------: | :------------: |
| read uncommitted |  可能  |    可能    |      可能      |
|  read committed  | 不可能 |    可能    |      可能      |
| repeatable read  | 不可能 |   不可能   | 对InnoDB不可能 |
|   serializable   | 不可能 |   不可能   |     不可能     |

注意：**InnoDB存储引擎通过多版本并发控制（MVCC）解决了repeatable read中的幻象读的问题**



**不可重复读和幻读的区别**
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但**不可重复读重点在于update和delete，而幻读的重点在于insert**。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该SQL第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免（**当然了在InnoDB引擎中，采用可重复读就解决了幻象读的问题**）。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

**对于这两种问题解决采用不同的办法，防止读到更改数据，只需对操作的数据添加行级锁，防止操作中的数据发生变化；而防止读到新增数据，往往需要添加表级锁，将整张表锁定，防止新增数据。**