---
title: MySQL数据类型
date: 2019-10-27 13:35:04
tags:
- MySQL
- 个人博客
categories:
- MySQL
---

​		MySQL支持所有的SQL数据类型，主要分为以下四类：

1. **数值类型**
2. **字符串类型**
3. **时间日期类型**
4. **二进制类型**



### 一、数值类型

​		MySQL数值类型有9种，其中**整数类型有5种（INTEGER、TINYINT、SMALLINT、MEDIUMINT和BIGINT）、浮点类型2种（float(M,D)、double(M,D)）、定点数1种（decimal(M,D)）和bit(M)类型1种**。

- **整数类型**

  ​	使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间。根据表示一个数占用字节数的不同，MySQL把整数划分成如下所示的类型：

|     类型     | 占用的存储空间（单位：字节） | 无符号数取值范围 |    有符号数取值范围    |      含义      |
| :----------: | :--------------------------: | :--------------: | :--------------------: | :------------: |
|   TINYINT    |              1               |      0~255       |        -128~127        |  非常小的整数  |
|   SMALLINT   |              2               |     0~65535      |      -32768~32767      |    小的整数    |
|  MEDIUMINT   |              3               |    0~16777215    |    -8388608~8388607    | 中等大小的整数 |
| INT(INTEGER) |              4               |  0~4294967 295   | -2147483648~2147483647 |   标准的整数   |
|    BIGINT    |              8               |    0~2^64^-1     |     -2^63^~2^63^-1     |     大整数     |

以**TINYINT**为例，用1个字节，也就是8位表示有符号数的话，就是既可以表示正数，也可以表示负数的话，需要有一个比特位表示正负号。但是如果表示无符号数的话，也就是只表示非负数的话，就不需要表示正负号，这就是有符号数和无符号数的区别。

注意，对于**INT(M)**类型，**M值不代表可以存储的数字长度，代表的是数据在显示时显式的最小长度。**在 INT(M) 中，M 的值跟 INT(M) 所占多少存储空间并无任何关系。 INT(3)、INT(4)、INT(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，INT(M) 跟 INT 数据类型是相同的。当数据长度超过M时，相当于啥也没发生，正常显示。如果数据长度小于M，需要指定某个字符来填充。**要查看出不同效果记得在创建类型的时候加 zerofill（见"列的属性"一节）这个值，表示用0填充，否则看不出效果的**



- **浮点数类型**

  ​	浮点数是用来表示小数的，平时用的十进制小数也可以转换成二进制后被计算机存储。比如9.875，这个小数可以被表示成这样：

  ```java
  9.875 = 8 + 1 + 0.5 + 0.25 + 0.125 = 1 × 2³ + 1 × 2⁰ + 1 × 2⁻¹ + 1 × 2⁻² + 1 × 2⁻³ 
  ```

  即，如果十进制小数9.875转换成二进制小数的话就是：1001.111。为了在计算机中存储这种二进制小数，统一把它们表示成 **a*2^n** 的科学计数法的形式，其中**1<=|a|<2**，比如1001.111可以表示为1.001111\*2^3，我们把小数点后的001111成为**尾数**，把3称为**指数**，然后只需要在计算机中的比特位中表示出**尾数**和**指数**就行了。另外，小数也有正负之分，我们还需要单独的部分来表示小数的正负号。综上所述，表示一个浮点数需要下边几个部分：

  - 符号部分：占用1个比特位即可
  - 指数部分：视具体浮点数格式而定
  - 尾数部分：视具体浮点数格式而定



​		很显然，表示一个浮点数使用的字节数越多，表示**尾数**和**指数**的范围就越大，也就是说可以表示的小数范围就越大。MySQL根据表示一个小数需要的不同字节数定义了如下的两种浮点数类型：

|  类型  | 占用的存储空间（单位：字节） |     绝对值最小非零值     |     绝对值最大非零值     |     含义     |
| :----: | :--------------------------: | :----------------------: | :----------------------: | :----------: |
| FLOAT  |              4               |     ±1.175494351E-38     |     ±3.402823466E+38     | 单精度浮点数 |
| DOUBLE |              8               | ±2.2250738585072014E-308 | ±1.7976931348623157E+308 | 双精度浮点数 |

MySQL中，**FLOAT占4字节（1位符号位，8位表示指数，23位表示尾数），DOUBLE占8字节（1位符号位，11位表示指数，52位表示尾数）**。这里以单精度浮点数类型FLOAT为例，它占用的4个字节的各个组成部分如下图所示：

{% asset_img  16d6779ae10315f9.png %}

另外需要注意的是，虽然有的十进制小数，比如1.875可以被很容易的转换成二进制数1.111，但是更多的小数是无法直接转换成二进制的，比如说0.3，它转换成的二进制小数就是一个无限小数，但是我们现在只能用4个字节或者8个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是**不精确的（即可能存在精度损失的问题）**。



​		**这里我们补充一下浮点数类型在内存中的存储方式**：

​		先来卡一下浮点数二进制表达的三个组成部分：

{% asset_img  20191027154807.png %}

​		三个主要部分是：

- 符号：表示浮点数是正数还是负数，0表示正数，1表示负数
- 指数部分：类似于科学计数法中的M*10^N^中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中以2^7^-1即127，也即01111111代表指数部分为0，转换时需要根据127作偏移调整。
  - **为什么要以127作为偏移量呢？**计算机表示单精度浮点数时，是用8位去存储指数部分，在数值上面，表示0 ~ 255，但是我们同样需要有负指数，正负指数的位数量为了均等，各自一半，-127 ~ 128，0是特殊点，特殊处理。储存时候会加上127，这样就刚刚好是0~255，就能很好的储存了，不然，不移量的话需要判断符号位来判断数值的正负。
- 尾数部分：浮点数中具体数值的实际表示。



​		下面展示实际转换过程：

- step 1：改写整数部分

  ​	以数值5.2为例。先不考虑小数部分，我们先单纯的将十进制数改写成二进制。即5转换为101

- step 2：改写小数部分

  ​	**把十进制的小数部分乘以2，取整数部分作为作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。**

  ​	例如0.2可以转换为：

  ​	0.2*2 = 0.4     0

  ​	0.4*2 = 0.8     0

  ​	0.8*2 = 1.6     1

  ​	0.6*2 = 1.2     1

  ​	0.2*2 = 0.4     0

  ​	0.4*2 = 0.8     0

  ​	0.8*2 = 1.6     1

  ​	......

  ​	即最后转换结果为：.0011001......（**它是一个无限循环的二进制数，明白为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况了吗**）

- step 3：规格化

  ​	现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。

- step 4：填充

  ​	**指数部分**（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。

  ​	**尾数部分**：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分1在填充时被舍去了。**因为规格化后的数值整部部分总是为1**。那省略整数部分后岂不是1.010011和0.010011就混淆了么？其实并不会，如果仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。（那么如何表示指数为-2的形式呢？即127-2=125，二进制表示为01111101）

  举两个例子吧，比较直观一些（[浮点数二进制转换工具](https://www.h-schmidt.net/FloatConverter/IEEE754.html)）

  1、9.875

  {% asset_img  20191027163017.png %}

  其中打钩代表对应的二进制位为1，否则为0

  2、0.3

  {% asset_img  20191027163227.png %}



​		**设置最大位数和小数位数**

​		在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，即

```
FLOAT(M,D)
DOUBLE(M,D)
```

​		对我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用FLOAT(M,D)或DOUBLE(M,D)来限制可以存储到本列中的小数范围。其中：

- M表示该小数最多需要的十进制**有效数字**个数

  注意是**有效数字**个数，比如对于2.3，有效数字个数是2，对于0.9来说有效数字个数就是1

- D表示该小数的小数点后的十进制数字个数

  小数点后有几个十进制数字，D的值就是什么

举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化：

|    类型    |    取值范围    |
| :--------: | :------------: |
| FLOAT(4,1) |  -999.9~999.9  |
| FLOAT(5,1) | -9999.9~9999.9 |
| FLOAT(4,0) |   -9999~9999   |
| FLOAT(4,2) |  -99.99~99.99  |

M取值范围为**0~255**。**FLOAT只保证7位有效数字的准确性**，所以FLOAT(M,D)中，M<=7时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。

D取值范围为**0~30**，同时必须**<=M**。**double只保证16位有效数字的准确性**，所以DOUBLE(M,D)中，M<=16时，数字通常是准确的。如果M和D都有明确定义，其超出范围后的处理同decimal。

**FLOAT和DOUBLE中，若M的定义分别超出7和16，则多出的有效数字部分，取值是不定的，通常数值上会发生错误。因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。**



- **定点数类型**

  ​	因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了**定点数**类型，它也是存储小数的一种方式：

| 类型         | 占用的存储空间（单位：字节） | 取值范围   |
| ------------ | ---------------------------- | ---------- |
| DECIMAL(M,D) | 取决于M和D                   | 取决于M和D |

  ​	M和D的含义与浮点数中M和D的含义一样。**但单精度浮点数类型FLOAT(M,D)占用的字节一直都是4字节，双精度浮点数类型DOUBLE(M,D)占用的字节数一直都是8字节，它们占用的存储空间大小并不随着M和D的值的变动而变动**。但对于定点数类型DECIMAL(M,D)来说，它占用的存储空间大小就和M、D的取值有关。

  ​	定点数是一种精确的小数，为了达到精确的目的我们就不能把它转换成二进制小数之后再存储(因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的)。如何才能保证精确存储呢？**只要把小数点左右的两个十进制整数给存储起来，那不就是精确的了么**。比如对于十进制小数9.85来说，我们可以把小数点左右的两个整数，也就是9和85分别保存起来，那么不就相当于保存了一个精确的小数。

  ​	

  ​	下面详细说一下DECIMAL(M,D)的存储方式，以DECIMAL(16,4)为例：

1、**首先确定小数左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位**，如图：

{% asset_img 16d6779ad10263a2.png %}

2、**从小数点位置出发，每个整数每隔9个十进制位划分为一组**，如图：

{% asset_img 16d6779ad21ff99f.png %}

从上图可以看出，如果不足9个十进制位，也会被划分为一组

3、针对**每个组**中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表：

| 组中包含的十进制位数 | 占用的存储空间大小（单位：字节） |
| :------------------: | :------------------------------: |
|         1或2         |                1                 |
|         3或4         |                2                 |
|         5或6         |                3                 |
|       7或8或9        |                4                 |

 	所以DECIMAL(16,4)共需要占用8个字节的存储空间大小，这8个字节由下边三个部分组成：

 - 第一组包含3个十进制位，需要2个字节
 - 第二组包含9个十进制位，需要4个字节
 - 第三组包含4个十进制位，需要2个字节

4、 **将转换完成的比特位序列的最高位设置为1**

举个例子吧，要不这咋可能弄得懂嘛，哼！

比如用DECIMAL(M,D)存储十进制小数1234567890.1234，这个小数会被分为三部分：

```java
1 234567890 1234
```

然后将每一组中的十进制数字转换成对应的二进制数字

- 第一组占用2个字节，即对应的二进制数为：

  ```java
  00000000 00000001(0x0001)
  ```

- 第二组占用4个字节，整数234567890对应的十六进制数为

  ```java
  0x0DFB38D2
  ```

- 第三组占用2个字节，整数1234对应的十六进制数为

  ```java
  0x04D2
  ```

所以将这些十六进制数字连起来之后就是：

```java
0x00010DFB38D204D2
```

​		最后还要将这个结果的最高位设置为1，所以最终十进制小数1234567890.1234使用定点数类型DECIMAL(M,D)存储时共占用8个字节，具体为：

```java
0x80010DFB38D204D2
```

​		**如果用定点数类型DECIMAL(16,4)存储一个负数怎么办？**比方说-1234567890.1234，这时只需要将0x80010DFB38D204D2中的每一个比特位都执行一个取反操作就行，即

```java
0x7FFEF204C72DFB2D
```



​		对于定点数类型，与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。

​		对于定点数类型DECIMAL(M,D)来说，M和D都是可选的，默认的M的值是10，默认的D的值为0，即

```java
DECIMAL = DECIMAL(10) = DECIMAL(10,0)
DECIMAL(n) = DECIMAL(n,0)
```

**M的范围是1-65，D的范围是0-30，且D的值不能超过M。**



​		**注意**：比如DECIMAL(5,2)，取值范围为-999.99~999.99

- **如果存储时，整数部分超出了范围（如1000.01）,MySQL就会报错，不允许存这样的值。**
- **如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。 如：999.994实际被保存为999.99。**
- **若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如999.995和-999.995都会报错。**



**无符号数值类型**

​		**unsigned**是MySQL自定义的类型，主要有以下用途：

- 起到约束数值的作用，即非负数（如果插入的数据是负数则会报错： Out of range value for column）

- 增加数值范围

  **unsigned可以用于整数、浮点数和定点数。**MySQL提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词unsigned

  ```java
  数值类型 unsigned
  ```

  **注意：在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。**



### 二、日期时间类型

​		MySQL提供了多种关于时间和日期的类型，各种类型能表示的范围如下：

|   类型    | 存储空间要求（单位：字节） |                    取值范围                    |     含义     |
| :-------: | :------------------------: | :--------------------------------------------: | :----------: |
|   YEAR    |             1              |                   1901~2155                    |    年份值    |
|   DATE    |             3              |          '1000-01-01' ~ '9999-12-31'           |    日期值    |
|   TIME    |             3              |           '-838:59:59' ~ '838:59:59'           |    时间值    |
| DATETIME  |             8              | '1000-01-01 00:00:00' ～ '9999-12-31 23:59:59' | 日期加时间值 |
| TIMESTAMP |             4              | '1970-01-01 00:00:01' ～ '2038-01-19 03:14:07' |    时间戳    |

​		在MySQL5.6.4这个版本后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持，称为**小数秒**。MySQL最多支持6为小数秒的支持，各个位代表的意思如下：

{% asset_img 16d6779ad395a41d.png %}

如果想让TIME、DATETIME、TIMESTAMP支持小数秒，可以这样写：

```java
类型(小数秒位数)
其中的小数秒位数可以在0,1,2,3,4,5,6中选择
```

比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果多了小数秒，就需要额外的存储空间：

| 保留的小数秒位数 | 额外需要的存储空间（单位：字节） |
| :--------------: | :------------------------------: |
|        0         |                0                 |
|       1或2       |                1                 |
|       3或4       |                2                 |
|       5或6       |                3                 |



**注意**，**要特别注意下DATETIME和TIMESTAMP的区别**

- **占用空间不同**，datetime占8字节，timestamp占用4字节

- **表示范围不同**，timestamp表示当前时间到Unix元年（1970 年 1 月 1 日 0 时 0 分 0 秒）的秒数。

- **时区**。timestamp以UTC的格式存储，它会自动检索当前时区并进行转换，datetime不会进行时区的检索。也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。比如

  ```java
  set time_zone = "+9:00";(时区设为东九区)
  ```

  此时就相当于是改变了时区。

- 如果存进去的是NULL，timestamp会自动存储当前时间，而datetime会储存NULL

- 在定义timestamp类型时，加入了default current_timestamp。则无需显示的插入时间数据，在插入数据时会默认插入系统时间

- timestamp类型可以在修改时自动更新，列定义如下：

  ```java
  uptime timestamp default current_timestamp on update current_timestamp
  ```

  上述定义后，如果更新某一列的数据时，会默认更新该列的为当前系统时间

### 三、字符串类型

​		字符是面向人的概念，如果想在计算机中表示字符，那就需要将该字符与一个特定的二进制序列对应起来，这个映射过程称为**编码**。但这种映射关系不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种：

- **固定长度的编码方案**

  表示不同的字符所需要的字节数量是相同的。比方说**ASCII**编码方案采用1个字节来编码一个字符，**usc2**采用2个字节来编码一个字符。

- **变长的编码方案**

  表示不同的字符所需要的字节数量是不同的。比如**utf8**编码方案采用1-3个字节来编码一个字符，**gb2312**采用1-2个字节来编码一个字符。	

**注意：正儿八经的UTF-8编码占用1~ 4个字节，这里的utf8占用1~3个字节是阉割版的。如果我们之后有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集。**

**MySQL的字符串类型**

​		下表表示MySQL中提供的字符串类型，其中**M**代表该数据类型最多能存储的字符数量，**L**代表实际向该类型中存储的字符串在特定字符集下所占的字节数，**W**代表该特定字符集下，编码一个字符最多需要的字节数：

|    类型    |   最大程度    |  存储空间要求  |       含义       |
| :--------: | :-----------: | :------------: | :--------------: |
|  CHAR(M)   |    M个字符    |   M*W个字节    |  固定长度字符串  |
| VARCHAR(M) |    M个字符    | L+1或L+2个字节 |  可变长度字符串  |
|  TINYTEXT  | 2^8^-1个字节  |   L+1个字节    | 非常小型的字符串 |
|    TEXT    | 2^18^-1个字节 |   L+2个字节    |   小型的字符串   |
| MEDIUMTEXT | 2^24^-1个字节 |   L+3个字节    | 中等大小的字符串 |
|  LONGTEXT  | 2^32^-1个字节 |   L+4个字节    |   大型的字符串   |



- **CHAR(M)**

  ​	M是该类型最多可以存储的**字符数量**（非字节数量），M的取值范围是0-255。如果省略掉M的值，那它的默认值就是1，也就是说CHAR和CHAR(1)是一个意思。CHAR(0)是一种特别的类型，它只能存储空字符串或者NULL值。

  ​	CHAR(M)在不同的字符集下需要的存储空间也是不一样的，我们假设某个字符集编码一个字符最多需要W个字节，那么类型CHAR(M)占用的存储空间大小就是M×W个字符。比方说：

  - 对于采用ASCII字符集的CHAR(5)类型来说，ASCII字符集编码一个字符最多需要1个字节，也就是M=5，W=1，所以占用的内存空间大小是5*1=5个字节。
  - 对于采用gbk字符集的CHAR(5)类型来说，gbk字符集编码一个字符最多需要2个字节，也就是M=5，W=2，所以占用的内存空间大小是5*2=10个字节。
  - 对于采用utf8字符集的CHAR(5)类型来说，utf8字符集编码一个字符最多需要3个字节，也就是M=5，W=3，所以占用的内存空间大小是5*3=15个字节。

  ​        **如果我们实际存储的字符串在特定字符集编码下占用的字节数不足M*W，那么剩余的那些存储空间用空格字符补齐。**即一旦确定了CHAR(M)类型的M，如果M的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费。

- **VARCHAR(M)**

  ​	如果某个列存储的字符串长短不一，那么使用CHAR(M)可能会浪费很多存储空间，因此可以使用VARCHAR(M)。

  ​	VARCHAR(M)中的M也是代表该类型最多可以存储的字符数量，理论上的取值范围是0-65535。但是，**MySQL中有一个规定，表中某一行包含的所有列中存储的数据大小总共不能超过65535个字节，也就是说VARCHAR(M)类型实际能够容纳的字符数量是小于65535的。**

  ​	VARCHAR(M)类型表示的数据由以下两部分组成：

  1、真正的字符串内容

  ​		假设真正的字符串在特定字符集编码后占用的字节数为L

  2、占用字节数

  ​		假设VARCHAR(M)类型采用的字符集编码一个字符最多需要W个字节，那么：

  - 当M*W<256时，只需要一个字节来表示占用的字节数

  - 当M\*W>=256且M*W<65536时，需要两个字节来表示占用的字节数

  （**因为一个字节能表示的最大无符号数是255，两个字节能表示的最大无符号数十65535**）

- **各种TEXT类型**

  ​	虽然VARCHAR(M)已经可以存储很长的字符串了，可有时候还是不够怎么办？对于很长的字符串，可以用TEXT存储大型字符串，它们都是**变长类型**。

  ​	MySQL有个规定，**某一行包含的所有列中存储的数据大小总和不得超过65535个字节**。**这个规定对于这些TEXT类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了。**

- **ENUM类型和SET类型**

  - ENUM类型称为**枚举类型**，它表示在给定的字符串列表里**选择一个**。比如性别，只能在'男'和'女'里面选一个，相当于一个单选框

    ```java
    ENUM('str1','str2','str3',...)
    ```

  - SET类型表示可以在给定的字符串列表里**选择多个**。比如兴趣列表，相当于一个多选框

    ```java
    SET('str1','str2','str3',...)
    ```

  **SET类型怎么insert**？
  
  ```java
  mysql> create table enum_set_table(
      -> id int auto_increment primary key,
      -> gender enum('M','F'),
      -> hobby set('music','movie','swimming','footbal')
      -> );
  Query OK, 0 rows affected (0.01 sec)
  
  /* 一个enum值，一个set值，二者均使用选项的字符串格式 */
  mysql> insert into enum_set_table(id,gender,hobby) values(null,'M','music');
  Query OK, 1 row affected (0.01 sec)
  
  /* 一个enum值，多个set值，二者均使用选项的字符串格式 */
  // 这种同时输入多个set值的方法要注意
  mysql> insert into enum_set_table(id,gender,hobby) values(null,'F','music,movie,footbal');
  Query OK, 1 row affected (0.00 sec)
  ```
  
  综上所述，**ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。**



### 四、二进制类型

- **BIT类型**

  ​	有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型：

|  类型  |    字节数     |       含义        |
| :----: | :-----------: | :---------------: |
| BIT(M) | 近似为(M+7)/8 | 存储M个比特位的值 |

  M默认为1，M的取值范围为1\~64，M可以省略，即BIT和BIT(1)一样。

- **BINARY(M)和VARBINARY(M)**

  ​	前者是固定长度的类型，后者是可变长度的类型，其中M代表该类型最多能存放的字节数量。`BINARY(M)`和`VARBINARY(M)`对应于我们前边提到的`CHAR(M)`和`VARCHAR(M)`，都是前者是固定长度的类型，后者是可变长度的类型，只不过`BINARY(M)`和`VARBINARY(M)`是用来存放字节的，其中的`M`代表该类型最多能存放的字节数量，而`CHAR(M)`和`VARCHAR(M)`是用来存储字符的，其中的`M`代表该类型最多能存放的字符数量。它们M的取值范围一样，对于CHAR 和BINARY是0 ~ 255；对于VARCHAR和VARBINARY是0 ~ 65535。

- **其它的二进制类型**

  ​	**TINYBLOB**、**BLOB**、**MEDIUMBLOB**、**LONGBLOB**是针对数据量很大的二进制数据提出的，比如图片、音乐、压缩文件啥的。**BLOB和TEXT一样也是变长的，有相同的最大长度和存储需求。**