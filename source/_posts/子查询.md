---
title: 子查询
date: 2020-04-10 20:42:21
tags:
- MySQL
- 个人博客
categories:
- MySQL
mathjax: true
---

**什么是子查询？子查询都可以出现在哪里？**

select语句当中嵌套select语句，被嵌套的语句是**子查询或内层查询**。同理，嵌套子查询的语句称为**外层查询**。

子查询可以出现在：

- select后面
- from后面
- where后面

**所有的子查询都必须用小括号扩起来，否则是非法的。**



# 按位置分类

## where子句中嵌套子查询

需求：找出高于平均薪资的员工

这里先写一个错误的方法：

```mysql
/*错误*/ 
mysql> select * from emp where sal > avg(sal);
```

为什么错误呢？**因为where子句中不能使用聚集函数**

正确做法如下：

- 第一步：找出平均薪资

```mysql
mysql> select avg(sal) from emp;
+-------------+
| avg(sal)    |
+-------------+
| 2073.214286 |
+-------------+
```

- 第二步：where过滤

```mysql
mysql> select * from emp where sal > 2073.214286;
+-------+-------+-----------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+-----------+------+------------+---------+------+--------+
|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |
|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |
|  7782 | CLARK | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |
|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |
|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |
|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |
+-------+-------+-----------+------+------------+---------+------+--------+
6 rows in set (0.00 sec)
```

**第一步和第二步合并**：

```mysql
mysql> select * from emp where sal > (select avg(sal) from emp);
+-------+-------+-----------+------+------------+---------+------+--------+
| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |
+-------+-------+-----------+------+------------+---------+------+--------+
|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |
|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |
|  7782 | CLARK | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |
|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |
|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |
|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |
+-------+-------+-----------+------+------------+---------+------+--------+
6 rows in set (0.00 sec)
```



## from子句中嵌套子查询

这个在实际应用中使用最多！！一定要掌握！！

from子句嵌套子查询的诀窍：**一定要将中间结果当做一张临时表**

**需求：找出每个部门平均薪水的薪资等级**

- 第一步：找出每个部门平均薪水（按照部门编号分组，求sal平均值）

```mysql
mysql> select deptno,avg(sal) as avgsal from emp group by deptno;
+--------+-------------+
| deptno | avg(sal)    |
+--------+-------------+
|     20 | 2175.000000 |
|     30 | 1566.666667 |
|     10 | 2916.666667 |
+--------+-------------+
3 rows in set (0.00 sec)
```

- 第二步：将以上的查询结果当作临时表t，让t表和salgrade表连接，连接条件是：t.avgsal between s.losal and s.hisal。

```mysql
mysql> select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) as t join salgrade as s on t.avgsal between s.losal and s.hisal;
+--------+-------------+-------+
| deptno | avgsal      | grade |
+--------+-------------+-------+
|     20 | 2175.000000 |     4 |
|     30 | 1566.666667 |     3 |
|     10 | 2916.666667 |     4 |
+--------+-------------+-------+
3 rows in set (0.00 sec)
```





**再来一个需求：找出每个部门平均的薪水等级**

- 第一步：找出每个员工的薪水等级，内连接查询，连接条件是e.sal between s.losal and s.hisal

```mysql
mysql> select e.ename,e.deptno,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal;
+--------+--------+-------+
| ename  | deptno | grade |
+--------+--------+-------+
| SMITH  |     20 |     1 |
| ALLEN  |     30 |     3 |
| WARD   |     30 |     2 |
| JONES  |     20 |     4 |
| MARTIN |     30 |     2 |
| BLAKE  |     30 |     4 |
| CLARK  |     10 |     4 |
| SCOTT  |     20 |     4 |
| KING   |     10 |     5 |
| TURNER |     30 |     3 |
| ADAMS  |     20 |     1 |
| JAMES  |     30 |     1 |
| FORD   |     20 |     4 |
| MILLER |     10 |     2 |
+--------+--------+-------+
14 rows in set (0.00 sec)
```

- 第二步：将以上查询结果当作一张临时表t，针对表t以deptno进行分组，然后再对分组后的薪水等级求平均（avg）

```mysql
mysql> select t.deptno,avg(t.grade) from (select e.ename,e.deptno,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal) as t group by t.deptno;
+--------+--------------+
| deptno | avg(t.grade) |
+--------+--------------+
|     20 |       2.8000 |
|     30 |       2.5000 |
|     10 |       3.6667 |
+--------+--------------+
3 rows in set (0.00 sec)
```

但是对于这个需求而言，没必要这么麻烦，下面有一种简单且效率更高的方法（不使用from子句嵌套子查询）：

```mysql
mysql> select e.deptno,avg(s.grade) as avg_salgrade from emp as e join salgrade as s on e.sal between s.losal and hisal group by e.deptno;
+--------+--------------+
| deptno | avg_salgrade |
+--------+--------------+
|     20 |       2.8000 |
|     30 |       2.5000 |
|     10 |       3.6667 |
+--------+--------------+
3 rows in set (0.00 sec)
```

**注意：不要一味的追求子查询！效率优先**



## select子句嵌套子查询

select嵌套子查询十分少用，基本不用！！

**需求：找出每个员工所在的部门名称，要求显示员工名和部门名**

这个用连接查询就可以解决

但是，这里为了学习子查询，我们重新考虑一下这个需求

```mysql
mysql> select e.ename,(select d.dname from dept as d where e.deptno = d.deptno) as dname from emp as e;
+--------+------------+
| ename  | dname      |
+--------+------------+
| SMITH  | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| JONES  | RESEARCH   |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| CLARK  | ACCOUNTING |
| SCOTT  | RESEARCH   |
| KING   | ACCOUNTING |
| TURNER | SALES      |
| ADAMS  | RESEARCH   |
| JAMES  | SALES      |
| FORD   | RESEARCH   |
| MILLER | ACCOUNTING |
+--------+------------+
14 rows in set (0.00 sec)
/* 这是一个相关子查询，具体介绍见后面*/
```

**当然，如果你想写这个语句，先量一下你是不是发烧了！！连接查询它不香么？**



# 按结果分类

上面的where子句嵌套子查询、from子句嵌套子查询和select子句嵌套子查询是根据子查询所处的位置来分类的。下面我们**根据子查询出来的结果进行分类**，主要包括：

- 标量子查询
- 列子查询
- 行子查询
- 表子查询

下面一一介绍！！



## 标量子查询

如果我们想查一下名叫`'杜琦燕'`的学生的各科成绩该怎么办呢？

```mysql
mysql> SELECT * FROM student_score WHERE number = (SELECT number FROM student_info WHERE name = '杜琦燕');
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
2 rows in set (0.01 sec)
```

我们把第二条查询语句用小括号`()`扩起来作为一个操作数放到了第一条的搜索条件处，这样就起到了合并两条查询语句的作用。小括号中的查询语句也被称为`子查询`或者`内层查询`，使用`内层查询`的结果作为搜索条件的操作数的查询称为`外层查询`。如果你在一个查询语句中需要用到更多的表的话，那么在一个子查询中可以继续嵌套另一个子查询。

在这个例子中的子查询的结果只有一个值(也就是`'杜琦燕'`的学号)，这种子查询称之为**标量子查询**。



## 列子查询

如果我们想查询`'计算机科学与工程'`专业的学生的成绩，我们需要先从`student_info`表中根据专业名称找到对应的学生学号，然后再通过学号到`student_score`表中找着对应的成绩信息，所以这个问题的解决方案就是书写下述两个查询语句：

- 第一步：找出计算机科学与工程相应学生的学号

```mysql
mysql> select number from student_info where major='计算机科学与工程';
+----------+
| number   |
+----------+
| 20180101 |
| 20180102 |
+----------+
2 rows in set (0.00 sec)
```

- 第二步：在student_score中找对应学号的成绩

```mysql
mysql> SELECT * FROM student_score WHERE number IN (20180101, 20180102);
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180101 | 母猪的产后护理              |    78 |
| 20180101 | 论萨达姆的战争准备          |    88 |
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
4 rows in set (0.00 sec)
```

第二条查询语句的搜索条件也是用到了第一条查询语句的查询结果，我们自然可以想到把第一条查询语句作为`内层查询`，把第二条查询语句作为`外层`查询来将这两个查询语句合并为一个查询语句，就像这样：

```mysql
mysql> SELECT * FROM student_score WHERE number IN (SELECT number FROM student_info WHERE major = '计算机科学与工程');
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180101 | 母猪的产后护理              |    78 |
| 20180101 | 论萨达姆的战争准备          |    88 |
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
4 rows in set (0.00 sec)
```

很显然第一条查询语句的结果集中并不是一个单独的值，而是一个列（本例中第一条查询语句的结果集中该列包含2个值，分别是：`20180101`和`20180102`），所以它对应的子查询也被称之为`列子查询`。因为`列子查询`得到的结果是多个值，相当于一个列表。我们前边的章节中说过，`IN`和`NOT IN`操作符正好是用来匹配列表的，上边使用的例子是使用`IN`操作符和子查询的结果组成表达式来作为外层查询的搜索条件的。`NOT IN`和`IN`的操作符的使用方式是一样的，只不过语义不同罢了，我们就不赘述了。



## 行子查询

有`列子查询`，大家肯定就好奇有没有`行子查询`。哈哈，当然有了，只要子查询的结果集中最多只包含一条记录，而且这条记录中有超过一个列的数据（如果该条记录只包含一个列的话，该子查询就成了`标量子查询`），那么这个子查询就可以被称之为`行子查询`，比如这样：

```mysql
mysql> SELECT * FROM student_score WHERE (number, subject) = (SELECT number, '母猪的产后护理' FROM student_info LIMIT 1);
+----------+-----------------------+-------+
| number   | subject               | score |
+----------+-----------------------+-------+
| 20180104 | 母猪的产后护理        |    55 |
+----------+-----------------------+-------+
1 row in set (0.01 sec)
```

该子查询的查询列表是`number, '母猪的产后护理'`，其中`number`是列名，`'母猪的产后护理'`是一个常数。我们在子查询语句中加了`LIMIT 1`这个子句，意味着子查询最多只能返回一条记录，所以该子查询就可以被看作一个`行子查询`。

由于上述的子查询执行后产生的结果集是一个行（包含2个列），所以用作等值比较的另一个操作数也得是2个值，本例中就是`(number, subject)`（注意，这两个值必须用小括号`()`扩住，否则会产生歧义）。它表达的语义就是：先获取到子查询的执行结果，然后再执行外层查询，如果`student_score`中记录的`number`等于子查询结果中的`number`列并且`subject`列等于子查询结果中的`'母猪的产后护理'`，那么就将该记录加入到结果集。



## 表子查询

如果子查询结果集中包含**多行多列**，那么这个子查询也可以被称之为`表子查询`，比如这样：

```mysql
mysql> SELECT * FROM student_score WHERE (number, subject) IN (SELECT number, '母猪的产后护理' FROM student_info WHERE major = '计算机科学与工程');
+----------+-----------------------+-------+
| number   | subject               | score |
+----------+-----------------------+-------+
| 20180101 | 母猪的产后护理        |    78 |
| 20180102 | 母猪的产后护理        |   100 |
+----------+-----------------------+-------+
2 rows in set (0.00 sec)
```



# 按查询顺序分类

按内层查询和外层查询的执行顺序，可分为两种：

- 不相关子查询
- 相关子查询



下面首先引入一个操作符

## EXISTS和NOT EXISTS

有时候外层查询并不关心子查询中的结果是什么，而**只关心子查询的结果集是不是为空集**，这时可以用到下边这两个操作符：

| 操作符     | 示例                  | 描述                               |
| ---------- | --------------------- | ---------------------------------- |
| EXISTS     | EXISTS(SELECT...)     | 当子查询结果集不是空集时表达式为真 |
| NOT EXISTS | NOT EXISTS(SELECT...) | 当子查询结果集是空集时表达式为真   |

我们来举个例子：

```MYSQL
mysql> SELECT * FROM student_score WHERE EXISTS (SELECT * FROM student_info WHERE number = 20180108);
Empty set (0.00 sec)
```

其中子查询的意思是在`student_info`表中查找学号为`20180108`的学生信息，很显然并没有学号为`20180108`的学生，所以子查询的结果集是一个空集，于是`EXISTS`表达式的结果为`FALSE`，所以外层查询也就不查了，直接返回了一个`Empty set`，表示没有结果。可以自己试一下`NOT EXISTS`的使用，和`EXISTS`用法一样。



## 不相关子查询

当子查询和外层查询没有依赖关系，也就是说子查询可以独立运行并产生结果之后，再拿结果作为外层查询的条件去执行外层查询，这种子查询称为`不相关子查询`，比如下边这个查询：

```mysql
mysql> SELECT * FROM student_score WHERE number = (SELECT number FROM student_info WHERE name = '杜琦燕');
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+
2 rows in set (0.00 sec)
```

子查询中只用到了`student_info`表而没有使用到`student_score`表，它可以单独运行并产生结果，这就是一种典型的`不相关子查询`。

**上面的不相关子查询如何执行呢？**

- 先执行外层查询的from把student_score加载进来；
- 然后执行外层循环的where
  - 先执行外层循环where子句中的子查询，由于是不相关子查询，所以查询结束后可以把查询结果缓存起来，将查询结果返回给外层查询
    - 子循环的查询语句也遵循以下顺序：from -> where -> select
  - 从student_score中一条一条的取记录，利用where条件进行筛选（记住，只有第一次筛选的时候才进入子查询，后面就不再进入了，直接去缓存里面取值！！**这里和相关子查询有区别**）。筛选完成后会得到一个结果集
- 最后再执行外层循环的select语句

对于不相关子查询而言，内层查询的执行独立于外层查询，**内层查询仅执行一次**，执行完毕后将结果作为外层查询的条件使用



## 相关子查询

而有时候我们需要在子查询的语句中引用到外层查询的值，这样的话子查询就不能当作一个独立的语句去执行，这种子查询被称为`相关子查询`。比方说我们想查看一些学生的基本信息，但是前提是这些学生在`student_score`表中有成绩记录，那可以这么写：

```mysql
mysql> SELECT number, name, id_number, major FROM student_info WHERE EXISTS (SELECT * FROM student_score WHERE student_score.number = student_info.number);
+----------+-----------+--------------------+--------------------------+
| number   | name      | id_number          | major                    |
+----------+-----------+--------------------+--------------------------+
| 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
| 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
| 20180103 | 范统      | 17156319980116959X | 软件工程                 |
| 20180104 | 史珍香    | 141992199701078600 | 软件工程                 |
+----------+-----------+--------------------+--------------------------+
4 rows in set (0.00 sec)
```

这个例子中的`相关子查询`的查询过程是这样的（**无论是相关子查询还是不相关子查询，都要严格遵守SQL查询语句执行顺序**，见[SQL查询语句的定义顺序和执行顺序](https://pringce.github.io/2020/03/31/SQL查询语句的定义顺序和执行顺序/#more)）：

- 先执行外层查询获得到`student_info`表的第一条记录，发现它的`number`值是`20180101`。把`20180101`当作参数传入到子查询，此时子查询的意思是判断`student_score`表的`number`字段是否有`20180101`这个值存在，子查询的结果是该值存在，所以整个`EXISTS`表达式的值为`TRUE`，那么`student_info`表的第一条记录可以被加入到结果集。
- 再执行外层查询获得到`student_info`表的第二条记录，发现它的`number`值是`20180102`，与上边的步骤相同，`student_info`表的第二条记录也可以被加入到结果集。
- 与上边类似，`student_info`表的第三条记录也可以被加入到结果集。
- 与上边类似，`student_info`表的第四条记录也可以被加入到结果集。
- 再执行外层查询获得到`student_info`表的第五条记录，发现它的`number`值是`20180105`，把`20180105`当作参数传入到它的子查询，此时子查询的意思是判断`student_score`表的`number`字段是否有`20180105`这个值存在，子查询的结果是该值不存在，所以整个`EXISTS`表达式的值为`FALSE`，那么`student_info`表的第五条记录就不被加入结果集中。
- 与上一步骤类似，`student_info`表的第六条记录也不被加入结果集中。
- `student_info`表没有更多的记录了，结束查询。

注意：在相关子查询中，**内层查询的执行依赖于外层查询的数据，外部查询每执行一次，内部查询也会执行一次**。这里和不相关子查询有较大的区别

个人理解：**由于相关子查询的内层查询依赖于外层查询，所以不能放在from子句后面，只能放在where和select子句后面！** 

**为什么呢？**个人理解是因为如果放在from子句中，肯定是存在连接查询的，和join共用。由于from...join...on是一套语句，基本可以认为同时进行，所以外层查询的表是不能用在内层查询中的（因为它们是同时载入进来的，当然不能用！只有from...join...on这一套语句用完之后，在其执行顺序后面的关键字语句才能使用该表名或者其表别名）