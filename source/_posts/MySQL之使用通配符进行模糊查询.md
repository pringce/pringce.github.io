---
title: MySQL之使用通配符进行模糊查询
date: 2020-03-24 16:32:52
tags:
- MySQL
- 个人博客
categories:
- MySQL
mathjax: true
---

有时候我们并不能精确地描述我们要查询的哪些结果，比如我们只想看看姓`'杜'`的学生信息，而不能精确的描述出这些姓`'杜'`的同学的完整姓名，我们称这种查询为`模糊查询`。`MySQL`中使用下边这两个操作符来支持`模糊查询`：

|  操作符  |     示例     |   描述   |
| :------: | :----------: | :------: |
|   LIKE   |   a LIKE b   |  a匹配b  |
| NOT LIKE | a NOT LIKE b | a不匹配b |

**注意：如果要进行模糊查询，只能使用上述操作符。不能使用 = 等操作符**



既然我们不能完整描述要查询的信息，那就用某个符号来替代这些模糊的信息，这个符号就被称为`通配符`。`MySQL`中支持下边这两个`通配符`：

-   `%`：表示任何字符出现任意次数 **(可以是0次)**

具体使用如下：

匹配以`"yves"`开头的记录:(包括记录`"yves"`)
`SELECT * FROM products WHERE prod_name like 'yves%';`



匹配包含`"yves"`的记录(包括记录`"yves"`)
`SELECT * FROM products WHERE prod_name like '%yves%';`



匹配以`"yves"`结尾的记录(包括记录`"yves"`)
`SELECT * FROM products WHERE prod_name like '%yves';`



- `_`：下划线通配符，表示只能匹配单个字符,不能多也不能少,就是一个字符
  - 有的时候我们知道要查询的字符串中有多少个字符，而使用`%`时匹配的范围太大，我们就可以用`_`来做通配符。

具体使用：

`SELECT * FROM products WHERE prod_name like '_yves';`
匹配结果为: 像`"yyves"`这样记录.



`SELECT * FROM products WHERE prod_name like 'yves__';`
匹配结果为: 像`"yvesHe"`这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)



**小细节**：**如果在使用like操作符时,后面的没有使用通用匹配符效果是和`=`一致的**,`SELECT * FROM products WHERE prod_name like '1000';`只能匹配的结果为`1000`,而不能匹配像`JetPack 1000`这样的结果.



**注意：LIKE或者NOT LIKE操作符只用于字符串匹配。通配符不能代表NULL，如果需要匹配NULL的话，需要使用IS NULL或者IS NOT NULL。**`%`通配符可以匹配任意字符,但是不能匹配NULL,也就是说`SELECT * FROM products WHERE prod_name like '%';`是匹配不到`prod_name`为NULL的的记录



**转义通配符**

如果待匹配的字符串中本身就包含普通字符`'%'`或者`'_'`该咋办，怎么区分它是一个通配符还是一个普通字符呢？

答：如果匹配字符串中需要普通字符`'%'`或者`'_'`的话，需要在它们前边加一个反斜杠`\`来和通配符区分开来，也就是说：

- `'\%'`代表普通字符`'%'`
- `'\_'`代表普通字符`'_'` 比方说这样：



上面我们说到了LIKE和NOT LIKE只能用于字符串匹配，但我在实际中却发现了这个问题：

```mysql
mysql> select * from student_score where score like '_8';
+----------+--------------------+-------+
| number   | subject            | score |
+----------+--------------------+-------+
| 20180101 | 母猪的产后护理     |    78 |
| 20180101 | 论萨达姆的战争准备 |    88 |
| 20180102 | 论萨达姆的战争准备 |    98 |
+----------+--------------------+-------+
3 rows in set
```

这里score字段是INT型，但为什么还是可以进行模糊查询？后来发现是这里发生了**隐式类型转换**（具体介绍见：[隐式类型转换](https://pringce.github.io/2020/03/30/隐式类型转换/#more)）。



正如所见， MySQL的通配符很有用。但这种功能是有代价的：**通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长**。这里给出一些使用通配符要记住的技巧。

- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。
- 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。
- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.

