---
title: 隐式类型转换
date: 2020-03-30 11:52:54
tags:
- MySQL
- 个人博客
categories:
- MySQL
mathjax: true
---

### 隐式类型转换的场景

只要某个值的类型与上下文要求的类型不符，`MySQL`就会根据上下文环境中需要的类型对该值进行类型转换，由于这些类型转换都是`MySQL`自动完成的，所以也可以被称为`隐式类型转换`。我们列举几种常见的隐式类型转换的场景：

- **把操作数类型转换为适合操作符计算的相应类型**

比方说对于加法操作符`+`来说，它要求两个操作数都必须是数字才能进行计算，所以如果某个操作数不是数字的话，会将其隐式转换为数字，比方说下边这几个例子：

```mysql
1 + 2       →   3
'1' + 2     →   3
'1' + '2'   →   3
```

虽然`'1'`、`'2'`都是字符串，但是如果它们作为加法操作符`+`的操作数的话，都会被强制转换为数字，所以上边几个表达式其实都会被当作`1 + 2`去处理的，这些表达式被放在查询列表时的效果如下：

```mysql
mysql> SELECT 1 + 2, '1' + 2, '1' + '2';
+-------+---------+-----------+
| 1 + 2 | '1' + 2 | '1' + '2' |
+-------+---------+-----------+
|     3 |       3 |         3 |
+-------+---------+-----------+
1 row in set (0.00 sec)
```



- **将函数参数转换为该函数期望的类型**

我们拿用于拼接字符串的`CONCAT`函数举例，这个函数以字符串类型的值作为参数，如果我们在调用这个函数的时候，传入了别的类型的值作为参数，`MySQL`会自动把这些值的类型转换为字符串类型的：

```mysql
CONCAT('1', '2')    →   '12'
CONCAT('1', 2)      →   '12'
CONCAT(1, 2)        →   '12'
```

虽然`1`、`2`都是数字，但是如果它们作为`CONCAT`函数的参数的话，都会被强制转换为字符串，所以上边几个表达式其实都会被当作`CONCAT('1', '2)`去处理的，这些表达式被放到查询列表时的效果如下：

```mysql
mysql> SELECT CONCAT('1', '2'), CONCAT('1', 2), CONCAT(1, 2);
+------------------+----------------+--------------+
| CONCAT('1', '2') | CONCAT('1', 2) | CONCAT(1, 2) |
+------------------+----------------+--------------+
| 12               | 12             | 12           |
+------------------+----------------+--------------+
1 row in set (0.00 sec)
```



- **存储数据时，把某个值转换为某个列需要的类型**

我们先新建一个简单的表`t`：

```mysql
CREATE TABLE t (
    i1 TINYINT,
    i2 TINYINT,
    s VARCHAR(100)
);
```

这个表有三个列，列`i1`和`i2`是用来存储整数的，列`s`是用来存储字符串的，如果我们在存储数据的时候填入的不是期望的类型，就像这样：

```mysql
mysql> INSERT INTO t(i1, i2, s) VALUES('100', '100', 200);
Query OK, 1 row affected (0.01 sec)
```

我们为列`i1`和`i2`填入的值是一个字符串值：`'100'`，列`s`填入的值是一个整数值：`200`，虽然说类型都不对，但是由于隐式类型转换的存在，在插入数据的时候字符串`'100'`会被转型为整数`100`，整数`200`会被转型成字符串`'200'`，所以最后插入成功，我们来看一下效果：

```mysql
mysql> SELECT * FROM t;
+------+------+------+
| i1   | i2   | s    |
+------+------+------+
|  100 |  100 | 200  |
+------+------+------+
1 row in set (0.00 sec)
```



### 类型转换的注意事项

1. `MySQL`会尽量把值转换为表达式中需要的类型，而不是产生错误。

   按理说`'23sfd'`这个字符串无法转换为数字，但是`MySQL`规定**只要字符串的开头部分包含数字，那么就把这个字符串转换为开头的数字，如果开头并没有包含数字，那么将被转换成`0**`，比方说这样：

   ```mysql
   '23sfd'         →   23
   '2019-08-28'    →   2019
   '11:30:32'      →   11
   'sfd'           →   0
   ```

   看个例子：

   ```mysql
   mysql> SELECT '23sfd' + 0, 'sfd' + 0;
   +-------------+-----------+
   | '23sfd' + 0 | 'sfd' + 0 |
   +-------------+-----------+
   |          23 |         0 |
   +-------------+-----------+
   1 row in set, 2 warnings (0.00 sec)
   ```

   **不过需要注意的是，这种强制转换不能用于存储数据中**，比方说这样：

   ```mysql
   mysql> INSERT INTO t(i1, i2, s) VALUES('sfd', 'sfd', 'aaa');
   ERROR 1366 (HY000): Incorrect integer value: 'sfd' for column 'i1' at row 1
   ```

   

2. 在运算时会自动提升操作数的类型。

   我们知道不同数据类型能表示的数值范围是不一样的，在小的数据类型经过算数计算后得出的结果可能大于该可以表示的范围。比方说`t`表中有一条记录如下：

```mysql
mysql> SELECT * FROM t;
+------+------+------+
| i1   | i2   | s    |
+------+------+------+
|  100 |  100 | 200  |
+------+------+------+
1 row in set (0.00 sec)
```

其中的`i1`列和`i2`列的类型都是`TINYINT`，而`TINYINT`能表示的最大正整数是`127`，如果我们把`i1`列的值和`i2`列的值相加会发生什么呢？请看：

```mysql
mysql> SELECT i1 + i2 FROM t;
+---------+
| i1 + i2 |
+---------+
|     200 |
+---------+
1 row in set (0.00 sec)

```

可以看到最后的结果是`200`，可是它已经超过`TINYINT`类型的表示范围了。其实在运算的过程中，`MySQL`自动将整数类型的操作数提升到了`BIGINT`，这样就不会产生运算结果太大超过`TINYINT`能表示的数值范围的尴尬情况了。类似的，有浮点数的运算过程会把操作数自动转型为`DOUBLE`类型。