---
title: Java类初始化顺序
date: 2020-04-05 10:07:38
tags:
- Java
categories:
- Java
mathjax: true
---

对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）>（实例变量、普通初始化块）> 构造器。

代码初始化块是类的成员之一，每次类的创建会隐式的调用它。本质上是一个代码块，或方法体。初始化块分为静态初始化块和普通初始化块。其好处是减少多个构造器内重用的代码。

初始化顺序图示：

{% asset_img 1.png %}

```java
/**
 * 类的初始化顺序
 * 静态变量->静态初始化块->实例变量->初始化块->构造方法
 */
public class InitialOrderTest {   
  
    // 静态变量 
    public static String staticField = "静态变量";
  
    // 变量 
    public String field = "变量";   
  
    // 静态初始化块 
    static {   
        System.out.println(staticField);   
        System.out.println("静态初始化块");   
    }   
  
    // 初始化块 
    {   
        System.out.println(field);   
        System.out.println("初始化块");   
    }   
  
    // 构造器方法
    public InitialOrderTest() {   
        System.out.println("构造方法");   
    }   
  
    public static void main(String[] args) {
        new InitialOrderTest();   
    }   
}
```

上述代码的运行结果如下：

{% asset_img 2.png %}



而对于继承的情况初始化顺序又会是怎么样的呢？

{% asset_img 3.png}

```java
/**
 * 有继承关系的类初始化顺序
 */
class Parent {   
    // 静态变量 
    public static String p_StaticField = "父类--静态变量";
    protected int i = 1;
    protected int j = 8;
    // 变量 
    public String p_Field = "父类--变量";   
  
    // 静态初始化块 
    static {   
        System.out.println(p_StaticField);   
        System.out.println("父类--静态初始化块");   
    }   
  
    // 初始化块 
    {   
        System.out.println(p_Field);   
        System.out.println("父类--初始化块");   
    }   
  
    // 构造器 
    public Parent() {   
        System.out.println("父类--构造器"); 
        System.out.println("i=" + i + ", j=" + j);
        j = 9;
    }   
}   
  
public class SubClass extends Parent {
  
    // 静态变量 
    public static String s_StaticField = "子类--静态变量";
  
    // 变量 
    public String s_Field = "子类--变量";   
    
    // 静态初始化块 
    static {   
        System.out.println(s_StaticField);   
        System.out.println("子类--静态初始化块");   
    }   
    // 初始化块 
    {   
        System.out.println(s_Field);   
        System.out.println("子类--初始化块");   
    }   
  
    // 构造器 
    public SubClass() {   
        System.out.println("子类--构造器"); 
        System.out.println("i=" + i + ",j=" + j);
    }   
  
    // 程序入口 
    public static void main(String[] args) {
        new SubClass();   
    }   
} 
```

运行结果如下所示：

{% asset_img 4.png %}





初始化块的特点：

- 何时调用？
  - 普通初始化块：创建对象时隐式调用
  - 静态初始化块：类加载（包括加载、验证、准备、解析和初始化五个阶段）时隐式调用
- 静态初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。也就是说如果创建100个对象，静态初始化仍然只调用依次，而普通初始化块会调用100次
- 一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型（静态或普通）的初始化块的执行顺序取决于定义的先后顺序！
- 在一个类中如果有多个不同的初始化块，初始化属性，构造器执行顺序是：静态初始化块|静态属性初始化 > 普通初始化块|普通属性初始化 > 构造器
- 在父子类中，执行顺序是：
  - 爷爷类的静态初始化块|静态属性初始化
  - 父类静态初始化块|静态属性初始化
  - 子类静态初始化块|静态属性初始化
  - 爷爷类普通初始化块|普通属性初始化>构造方法
  - 父类普通初始化块|普通属性初始化>构造方法
  - 子类普通初始化块|普通属性初始化>构造方法
- 静态初始化块中遵循静态成员的特点，只能直接访问静态成员！也就是在静态初始化块只能修改静态成员



**个人底层小总结**：

- 类加载过程中包含一个**准备阶段**，该阶段正式为类中定义的静态变量（并不包括实例变量，并且只有静态变量，不包括静态代码块）分配内存（在方法区中）并设置初始值（注意这里的初始值**通常情况**下是系统默认的数据类型零值）。比如下面这个语句

```java
public static int val = 123;
```

变量val在准备阶段过后的初始值为0而不是123。只有当类加载中的初始化阶段后该变量才被赋值为123。

这里说了通常情况下在准备阶段被初始为数据类型零值。但也存在例外，如果是常量的话，那么在准备阶段就会被赋值为123。如下：

```java
public static final int val = 123;
```

- 进行准备阶段时，静态变量已经赋过一次系统要求的初始零值。在类加载的初始化阶段，会根据程序员编写的代码去初始化类变量。**初始化阶段就是执行类构造器< clinit >()方法的过程**。< clinit >()并不是程序员在Java代码中直接编写的代码，它是Javac编译器的自动生成物。< clinit >()方法是由编译器自动收集类中的**所有静态变量的赋值动作和静态代码块**中的语句合并产生的（静态变量的声明操作不会被收集）。编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块只能访问到定义在静态语句块之前的静态变量。定义在它之后的静态变量只能赋值，但不能访问。**所以最好把静态变量写在静态代码块前面。**
-   类初始化前，其直接超类已经被初始化，直接超类的直接超类也需如此。即**javac生成的 < clinit >方法由JVM在“类初始化阶段”调用，调用类的< clinit >方法前，必须先调用父类的< clinit >方法**。因此在Java虚拟机中第一个被执行的< clinit >()方法的类型肯定是java.lang.Object
- < clinit >方法只在类加载阶段的初始化过程中被执行一次，后续创建实例对象将不再执行该方法。也就是创建100个实例对象，只执行依次< clinit >方法，但会执行100次构造方法。
- < clinit >方法不是必须的，如果一个类中没有静态代码块，也没有对静态变量的赋值操作，那么编译器可以不为这个类生成< clinit >方法
- 上面说过，实例变量和普通代码块的初始化顺序要早于构造方法。实际情况是这样的：**编译的时候，javac编译器把“实例变量的初始化语句”和“实例代码块的语句”按照代码中的顺序编译到了构造方法中（并且该位置要放在构造方法里面已经有的代码的前面）**，所以才会造成实例变量和普通代码块要早于构造方法初始化。
- 执行构造方法在堆中创建一个对象。在没有显示调用父类构造方法情况下，所有构造方法的**首行**都会隐含调用**父类的无参构造方法**super()。所以才会造成父类的实例变量、普通代码块和构造方法的初始化要早于子类的实例变量、普通代码块和构造方法的初始化。
- 构造方法是在创建对象的时候才会调用的





## 类加载过程：

① JVM启动，加载所需要的class文件
② JVM加载class文件时，会把所有的静态内容(静态成员变量、静态方法、静态代码块)都先加载到**方法区中的静态区**中，**此时实例方法也会被加载到方法区的非静态区中**（这点很重要，一定要注意）。类加载的时候，静态方法和实例方法都会加载到方法区中，只不过要调用到实例方法时需要先实例化一个对象才能调用实例方法
③ 静态加载完成之后，JVM开始给所有的静态变量开辟空间并默认初始化。
④ 当给类中的所有静态成员变量默认初始化完成，开始按照代码的顺序依次执行(遇到静态代码块就执行，遇到静态成员变量就显示初始化)
⑤ 静态都执行完毕，类才彻底加载完成



## 对象的加载过程：

① 当类加载完成，使用new关键字创建对象，在堆给对象分配内存空间
② 给对象所属的类的实例变量分配空间并进行默认初始化（数据类型系统零值）
③ 在JVM自动调取构造函数时先执行隐式两步

- super()区访问父类构造，对父类进行初始化
- 给实例变量进行显示赋值，执行普通代码块（什么时候变量赋值，什么时候执行代码块，取决于他们在源文件中的顺序）

④ 执行构造函数中的其它代码
⑤ 构造函数执行完毕，对象创建完成。



**实际上，在jvm层面上，在执行构造方法之前，jvm已经为在堆中给对象分配好了内存空间，并将该对象的引用this当做参数传递到构造方法中，构造方法的执行，只是为了给对象进行初始化。所以，构造方法是由新创建的对象来调用的，构造方法中的this，仍然指代的是正在调用该构造方法的对象。**



注意：

- 静态方法存储在方法区的静态区里面，实例方法存储在方法区的非静态区里面（注意：**实例方法不随创建的对象保存于堆中**）
- 静态方法是在类加载的时候就在内存中加载完成，可以直接通过类名调用运行的函数。(**只要是函数最终都要进入栈内存，方法是什么时候调用，什么时候执行，不调用不执行**。记住：加载，是将类文件中的一行行内容存放到了内存当中，并不会执行任何语句)
- 静态方法和实例方法加载过程
  - 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。
  - 对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出才被取消。
- **静态不能访问非静态、非静态可以访问静态**
- 静态方法在类的字节码加载到内存时就分配了入口地址，因此，Java语言允许通过类名直接调用类方法，而实例方法不能通过类名调用。在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址。
- 静态变量/方法、实例变量/方法在内存中的存储：
  - 静态变量/方法：只有一份，共用一块记忆体
  - 实例方法：只有一份，共用一块记忆体
  - 实例变量：随着每个对象各有一块记忆体



**为什么实例方法共用一块记忆体呢？**

​		如果让类中所有的实例方法都随着对象的实例化而建立一次，那么会大量消耗内存资源，所以才会让所有对象共享这些实例方法，然后用this关键字指向调用实例方法的对象。