---
title: 分组查询
date: 2020-04-09 19:50:58
tags:
- MySQL
- 个人博客
categories:
- MySQL
mathjax: true
---

进行分组查询主要有两个关键字：

- group by：按照某个字段或者某些字段进行分组
- having：having是对分组后的数据再次过滤（注意和where的区别，**where子句**的作用是**在分组前就对数据进行过滤**，**having子句**的作用是**筛选满足条件的组，即在分组后过滤数据**）

## 分组数据

### 复杂的数据统计

前边介绍了一些用来统计数据的聚集函数，我们可以方便的使用这些函数来统计出某列数据的行数、最大值、最小值、平均值以及整列数据的和。但是有些统计是比较麻烦的，比如说老师想根据成绩表分别统计出`'母猪的产后护理'`和`'论萨达姆的战争准备'`这两门课的平均分，那我们需要下边两个查询：

```mysql
mysql> SELECT AVG(score) FROM student_score WHERE subject = '母猪的产后护理';
+------------+
| AVG(score) |
+------------+
|    73.0000 |
+------------+
1 row in set (0.00 sec)

mysql> SELECT AVG(score) FROM student_score WHERE subject = '论萨达姆的战争准备';
+------------+
| AVG(score) |
+------------+
|    73.2500 |
+------------+
1 row in set (0.00 sec)
```

如果课程增加到20门怎么办呢？我们一共需要写20个查询语句，这样神烦哎。为了在一条查询语句中就完成这20条语句的任务，所以引入了`分组`的概念，就是：针对某个列，将该列的值相同的记录分到一个组中。拿`subject`列来说，按照`subject`列分组的意思就是将`subject`列的值是`'母猪的产后护理'`的记录划分到一个组中，将`subject`列的值是`'论萨达姆的战争准备'`的记录划分到另一个组中，如果`subject`列还有别的值，则划分更多的组。其中分组依靠的列我们可以称之为`分组列`。所以在`student_score`表中按照`subject`列分组后的图示就是这样：

{% asset_img 1.png %}

`subject`列中有多少不重复的课程，那就会有多少个分组。幸运的是，只要我们在`GROUP BY`子句中添加上`分组列`就好了，`MySQL`会帮助我们自动建立分组来方便我们统计信息。

**group by：按照某个字段或某些字段对数据进行分组**

如果我们想统计每门课的平均分，具体语句如下：

```mysql
mysql> SELECT subject, AVG(score) FROM student_score GROUP BY subject;
+-----------------------------+------------+
| subject                     | AVG(score) |
+-----------------------------+------------+
| 母猪的产后护理              |    73.0000 |
| 论萨达姆的战争准备          |    73.2500 |
+-----------------------------+------------+
2 rows in set (0.01 sec)
```

这个查询的执行过程就是按照`subject`中的值将所有的记录分成两组，然后分别对每个分组中记录的`score`列调用`AVG`函数进行数据统计。

**注意**：SQL语句中有一个规则：**当一条语句中有group by 的话，select后面只能跟聚集函数（count、max、min、sum和avg，注意聚集函数里面的字段可以随意，不一定非要是参与分组的字段）和参与分组的字段**。如果select后面跟了别的字段，对于Oracle而言会报错，语法错误；**但是在MySQL中是有查询结果的，但是结果毫无意义**。Oracle的语法规则比MySQL的语法规则更严谨。



### 带有WHERE子句的分组查询

上边的例子是将表中每条记录都划分到某个分组中，我们也可以在划分分组前就将某些记录过滤掉，这时就需要使用`WHERE`子句了。比如老师觉得各个科目的平均分太低了，所以想先把分数低于`60`分的记录去掉之后再统计平均分，就可以这么写：

```mysql
mysql> SELECT subject, AVG(score) FROM student_score WHERE score >= 60 GROUP BY subject;
+-----------------------------+------------+
| subject                     | AVG(score) |
+-----------------------------+------------+
| 母猪的产后护理              |    89.0000 |
| 论萨达姆的战争准备          |    82.3333 |
+-----------------------------+------------+
2 rows in set (0.00 sec)
```

这个过程可以分成两个步骤理解：

1. 将记录进行过滤后再分组。

   在进行分组前就过滤掉不符合`WHERE`子句的记录，所以，最后的分组情况其实是这样的（少于60分的记录被过滤掉了）

   {% asset_img 2.png %}

2. 分别对各个分组进行数据统计。

   统计之后就产生了上述的结果。



### 多字段分组

有时候按照某个列进行分组太笼统，一个分组内可以被继续划分成更小的分组。比方说对于`student_info`表来说，我们可以先按照`department`来进行分组，所以可以被划分为2个分组：

{% asset_img 3.png %}

我们觉得这样按照`department`分组后，各个分组可以再按照`major`来继续分组，从而划分成更小的分组，所以再次分组之后的样子就是这样：

{% asset_img 4.png %}

所以现在有了2个大分组，4个小分组，我们把这种对大的分组下继续分组的的情形叫做`嵌套分组`，如果你乐意，你可以继续把小分组划分成更小的分组。我们只需要在`GROUP BY`子句中把各个分组列依次写上，用逗号`,`分隔开就好了。比如这样：

```mysql
mysql> SELECT department, major, COUNT(*) FROM student_info GROUP BY department, major;
+-----------------+--------------------------+----------+
| department      | major                    | COUNT(*) |
+-----------------+--------------------------+----------+
| 航天学院        | 电子信息                 |        1 |
| 航天学院        | 飞行器设计               |        1 |
| 计算机学院      | 计算机科学与工程         |        2 |
| 计算机学院      | 软件工程                 |        2 |
+-----------------+--------------------------+----------+
4 rows in set (0.00 sec)
```

可以看到，在`嵌套分组`中，**聚集函数将作用在最后一个分组列上**，在这个例子中就是`major`列。注意：select后面还是只能跟分组列和聚集函数，只不过这里可以写多个分组列。那能不能在select后面只写部分分组列呢？**答案是可以，但是聚集函数只针对最后一个分组列**。例如

```mysql
mysql> SELECT department, COUNT(*) FROM student_info GROUP BY department, major;
+------------+----------+
| department | COUNT(*) |
+------------+----------+
| 计算机学院 |        2 |
| 计算机学院 |        2 |
| 航天学院   |        1 |
| 航天学院   |        1 |
+------------+----------+
4 rows in set (0.00 sec)
```



### 分组和排序

如果我们想对各个分组查询出来的统计数据进行排序，**需要为select列表中有聚集函数的表达式添加别名**，比如想按照各个学科的平均分从大到小降序排序，可以这么写：

```mysql
mysql> SELECT subject, AVG(score) AS avg_score FROM student_score GROUP BY subject ORDER BY avg_score DESC;
+-----------------------------+-----------+
| subject                     | avg_score |
+-----------------------------+-----------+
| 论萨达姆的战争准备          |   73.2500 |
| 母猪的产后护理              |   73.0000 |
+-----------------------------+-----------+
2 rows in set (0.01 sec)
```

前面已经详细介绍了order by的用法。这里需要注意下当group by和order by一起使用时，有以下**注意事项**：

- **order by后面排序的字段必须是聚合函数（当然这里并不是只能放置在select中出现的聚集函数，只要是针对分组的聚集函数都可以）或者group by中参与分组的字段**（我在MySQL也尝试使用了非分组列，同样没有报错，但是排序结果毫无意义！）
- 当有group by时，order by后面也可以多列排序（用什么列见第一条）



## 作用于分组的过滤条件

有时候某个带有`GROUP BY`子句的查询中可能会产生非常多的分组，假设`student_score`表中存储了100门学科的成绩，也就是`subject`列中有100个不重复的值，那就会产生100个分组，也就意味着这个查询的结果集中会产生100条记录。如果我们不想在结果集中得到这么多记录，只想把那些符合某些条件的分组加入到结果集，从而减少结果集中记录的条数，那就需要把针对分组的条件放到`HAVING`子句了。比方说老师想要查询平均分大于`73`分的课程，就可以这么写：

```mysql
mysql> SELECT subject, AVG(score) FROM student_score GROUP BY subject HAVING AVG(score) > 73;
+-----------------------------+------------+
| subject                     | AVG(score) |
+-----------------------------+------------+
| 论萨达姆的战争准备          |    73.2500 |
+-----------------------------+------------+
1 row in set (0.00 sec)
```

那么问题来了，having子句后面可以跟什么东西来进行组筛选呢？

有两种：

- **分组列**：也就是说我们可以把group by中用于分组的列放到`HAVING`子句的条件中，比如这样：

```mysql
SELECT subject, AVG(score) FROM student_score GROUP BY subject having subject = '母猪的产后护理';
```

- **聚集函数**：当然，并不是`HAVING`子句中只能放置在select列表出现的那些聚集函数，只要是针对这个分组进行统计的聚集函数都可以，比方说老师想查询最高分大于98分的课程的平均分，可以这么写：

```mysql
mysql> SELECT subject, AVG(score) FROM student_score GROUP BY subject HAVING MAX(score) > 98;
+-----------------------+------------+
| subject               | AVG(score) |
+-----------------------+------------+
| 母猪的产后护理        |    73.0000 |
+-----------------------+------------+
1 row in set (0.00 sec)
```

其中的`MAX(score)`这个聚集函数并没有出现在查询列表中，但仍然可以作为`HAVING`子句中表达式的一部分。



下面我们考虑一个需求：有一个表emp，表中有每个人的部门字段no，薪资字段sal。查询每个部门的**最高薪资**，要求显示的最高薪资大于2000。可以用下面这种方式：

```mysql
mysql> select no,max(sal) from emp group by no having max(sal)>2000;
```

但是上面这种方式效率较低：它已经将所有的数据进行了分组，然后再进行分组后的筛选。下面给出一种效率高的方式

```mysql
mysql> select no,max(sal) from emp where sal>2000 group by no;
```

由于where子句在group by子句之前执行，即先进行数据筛选再分组，这样可大幅提高效率。**所以，在having和where都能用的情况下，尽量用where，这样效率高**



但是有的时候，有些需求只能用having，不能用where。例如：查询每个部门的**平均工资**，要求显示平均薪资大于2000的数据。

这里不能再用where了，只能使用having。如下所示

```mysql
mysql> select no,avg(sal) from emp group by no having avg(sal)>2000;
```



注意：**having是group by的搭档，只有group by出现的时候，having才能用！没有group by，having是不能用的**



## 使用分组注意事项

使用分组来统计数据给我们带来了非常大的便利，但是要随时提防有坑的地方：

1. 如果分组列中含有`NULL`值，那么`NULL`也会作为一个独立的分组存在。

2. 如果存在多个分组列，也就是`嵌套分组`，**聚集函数将作用在最后的那个分组列上。**

3. 如果查询语句中存在`WHERE`子句和`ORDER BY`子句，那么`GROUP BY`子句必须出现在`WHERE`子句之后，`ORDER BY`子句之前。

4. `非分组列`不能单独出现在select列表中(可以被放到聚集函数中)。

5. `GROUP BY`子句后也可以跟随`表达式`(但不能是聚集函数，**聚集函数只能出现在having、select和order by子句中**)。

   上边介绍的`GROUP BY`后跟随的都是表中的某个列或者某些列，其实一个表达式也可以，比如这样：

   ```mysql
   mysql> SELECT concat('专业：', major), COUNT(*) FROM student_info GROUP BY concat('专业：', major);
   +-----------------------------------+----------+
   | concat('专业：', major)           | COUNT(*) |
   +-----------------------------------+----------+
   | 专业：电子信息                    |        1 |
   | 专业：计算机科学与工程            |        2 |
   | 专业：软件工程                    |        2 |
   | 专业：飞行器设计                  |        1 |
   +-----------------------------------+----------+
   4 rows in set (0.00 sec)
   
   mysql>
   ```

   `MySQL`会根据这个表达式的值来对记录进行分组，使用表达式进行分组的时候需要特别注意，查询列表中的表达式和`GROUP BY`子句中的表达式必须完全一样。**不过一般情况下我们也不会用表达式进行分组，所以目前基本没啥用～**

6. `WHERE`子句和`HAVING`子句的区别。

   `WHERE`子句在分组前进行过滤，**作用于每一条记录**，`WHERE`子句过滤掉的记录将不包括在分组中。而`HAVING`子句在数据分组后进行过滤，**作用于整个分组**，所以使用having进行筛选就是一组一组的筛选，如果这个组不符合条件，那么这个组的数据我都不要，就是这么傲娇~。